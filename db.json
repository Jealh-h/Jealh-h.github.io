{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":0},{"_id":"source/images/beian.png","path":"images/beian.png","modified":1,"renderable":0},{"_id":"themes/amber/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/amber/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/amber/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/amber/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/dark.svg","path":"images/dark.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/amber/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/amber/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/amber/source/images/light.svg","path":"images/light.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/amber/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/fireworks.js","path":"js/fireworks.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/theme.js","path":"js/theme.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/amber/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/amber/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/amber/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/amber/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/amber/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/amber/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/amber/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/linklist.json","hash":"ffc41ed829725f348636d873f4694debf0bdb88b","modified":1672482393574},{"_id":"source/about/index.md","hash":"0954484413b4f7b7f362d16ef5ffddf2ffc45319","modified":1672482393604},{"_id":"source/CNAME","hash":"d4c178941bdc5e06b035393a72cfd390869dda1b","modified":1672482393572},{"_id":"source/_posts/2022-年终总结.md","hash":"99d15ae8d1d3f100a4f9315fe59b07d96c411bf9","modified":1672482393579},{"_id":"source/categories/index.md","hash":"7d5c0b30f80e3f2c04cf95c0f496913ddfaa53a1","modified":1672482393605},{"_id":"source/_posts/2021年终总结.md","hash":"39aaa956f0db212ba9bad5a8b876d100276f76ef","modified":1672482393577},{"_id":"source/_posts/Scroll-开发小记.md","hash":"651f9da00809bd3e48c57ef5dc82875ecf19efc9","modified":1672482393580},{"_id":"source/_posts/JavaScript-的隐式转换.md","hash":"50c5077f96f4af6f380262af2542e8d5e9986389","modified":1678369077735},{"_id":"source/_posts/actions进行轻服务的页面部署.md","hash":"9630036eb45b7f5ae839f6e62159608712203798","modified":1672482393581},{"_id":"source/_posts/numpy条件选择.md","hash":"bdfde083a673171c66841df32995f1ddbe41cf17","modified":1672482393587},{"_id":"source/_posts/hello-world.md","hash":"7ee4ed109899b0a0d8f95f26457cf7d5e8eceeec","modified":1672482393583},{"_id":"source/_posts/【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？.md","hash":"2f0cb68431e4c3a3b1ffac27246c278f22ce6f06","modified":1678454739351},{"_id":"source/_posts/svg基础.md","hash":"0987fb37dae14731c3e515d665e369ee978fa1b1","modified":1672482393590},{"_id":"source/_posts/一封阿里云的喝茶邮件.md","hash":"187b023883bc9f92fffd4e87ea0764b9b6c26555","modified":1672482393596},{"_id":"source/_posts/react合成事件.md","hash":"b78f1e7d100679c8618b1f65630df53f0466a34e","modified":1672482393588},{"_id":"source/_posts/一次base64指令的powershell.md","hash":"d0721afecf0cba25ec181eaba090a2962e86ce29","modified":1672482393597},{"_id":"source/_posts/对javaScript事件冒泡与事件捕获的再学习.md","hash":"05adbdf0b17b7a05a856656a4c18615c56926faa","modified":1672482393598},{"_id":"source/friendsLinks/index.md","hash":"a015e55f2c02420e1aeb93452a963bee0b546d05","modified":1672482393607},{"_id":"source/_posts/【译】优化长任务-Optimize-long-tasks.md","hash":"d881ea642ec88870649ba79ed347e8caf0be7d44","modified":1672482393594},{"_id":"source/images/avatar.png","hash":"6aaf9775d28026f8ce19d2a446776b6514b56d14","modified":1672482393609},{"_id":"source/tags/index.md","hash":"54d7b3e144a29527ad6b2475599520a574f06a2c","modified":1672482393613},{"_id":"source/_posts/聊聊JavaScript事件循环.md","hash":"9349d7d9fd54fbe44c32707237ee743c3492d493","modified":1672482393600},{"_id":"source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1672482393611},{"_id":"source/_posts/谈谈cookie、session与token-jwt.md","hash":"0fb294b44e95bccaeacc04d1df589c6fc4b9f62c","modified":1672482393601},{"_id":"themes/amber/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1672221079744},{"_id":"themes/amber/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1672221079745},{"_id":"themes/amber/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1672221079759},{"_id":"themes/amber/.eslintrc.json","hash":"767974753cdcea6a544811cd0cea40ba9a199b7c","modified":1672221079744},{"_id":"themes/amber/.prettierrc","hash":"0cb3ead6906a5616ba81f532ac634c607230f430","modified":1672221079759},{"_id":"themes/amber/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1672221079761},{"_id":"themes/amber/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1672221079760},{"_id":"themes/amber/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1672221079764},{"_id":"themes/amber/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1672221079761},{"_id":"themes/amber/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1672221079881},{"_id":"themes/amber/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1672221079762},{"_id":"themes/amber/_config.yml","hash":"7ba3187d680ec51f589b52132e1a8f4d366ff912","modified":1672221079764},{"_id":"themes/amber/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1672221079790},{"_id":"themes/amber/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1672221079746},{"_id":"themes/amber/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1672221079754},{"_id":"themes/amber/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1672221079753},{"_id":"themes/amber/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1672221079747},{"_id":"themes/amber/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1672221079752},{"_id":"themes/amber/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1672221079754},{"_id":"themes/amber/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1672221079755},{"_id":"themes/amber/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1672221079757},{"_id":"themes/amber/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1672221079756},{"_id":"themes/amber/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1672221079757},{"_id":"themes/amber/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1672221079758},{"_id":"themes/amber/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1672221079767},{"_id":"themes/amber/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1672221079768},{"_id":"themes/amber/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1672221079766},{"_id":"themes/amber/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1672221079768},{"_id":"themes/amber/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1672221079769},{"_id":"themes/amber/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1672221079774},{"_id":"themes/amber/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1672221079776},{"_id":"themes/amber/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1672221079770},{"_id":"themes/amber/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1672221079775},{"_id":"themes/amber/layout/_layout.swig","hash":"130baa6e6bcc56ab78074f8df4213aad6496b5c2","modified":1672221079809},{"_id":"themes/amber/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1672221079876},{"_id":"themes/amber/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1672221079873},{"_id":"themes/amber/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1672221079875},{"_id":"themes/amber/layout/links.swig","hash":"6a2c49caa9edf778e07102e2e5d5ae80d485f742","modified":1672221079877},{"_id":"themes/amber/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1672221079879},{"_id":"themes/amber/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1672221079906},{"_id":"themes/amber/layout/page.swig","hash":"5aca0f6a715edd87015f291d56c77ae7187b587b","modified":1672221079878},{"_id":"themes/amber/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1672221079880},{"_id":"themes/amber/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1672221079793},{"_id":"themes/amber/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1672221079791},{"_id":"themes/amber/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1672221079792},{"_id":"themes/amber/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1672221079795},{"_id":"themes/amber/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1672221079794},{"_id":"themes/amber/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1672221079796},{"_id":"themes/amber/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1672221079796},{"_id":"themes/amber/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1672221079797},{"_id":"themes/amber/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1672221079798},{"_id":"themes/amber/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1672221079799},{"_id":"themes/amber/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1672221079799},{"_id":"themes/amber/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1672221079800},{"_id":"themes/amber/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1672221079801},{"_id":"themes/amber/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1672221079802},{"_id":"themes/amber/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1672221079803},{"_id":"themes/amber/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1672221079802},{"_id":"themes/amber/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1672221079804},{"_id":"themes/amber/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1672221079804},{"_id":"themes/amber/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1672221079806},{"_id":"themes/amber/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1672221079805},{"_id":"themes/amber/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1672221079807},{"_id":"themes/amber/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1672221079807},{"_id":"themes/amber/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1672221079749},{"_id":"themes/amber/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1672221079750},{"_id":"themes/amber/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1672221079751},{"_id":"themes/amber/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1672221079751},{"_id":"themes/amber/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1672221079780},{"_id":"themes/amber/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1672221079780},{"_id":"themes/amber/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1672221079777},{"_id":"themes/amber/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1672221079778},{"_id":"themes/amber/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1672221079784},{"_id":"themes/amber/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1672221079782},{"_id":"themes/amber/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1672221079783},{"_id":"themes/amber/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1672221079783},{"_id":"themes/amber/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1672221079785},{"_id":"themes/amber/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1672221079786},{"_id":"themes/amber/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1672221079788},{"_id":"themes/amber/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1672221079787},{"_id":"themes/amber/layout/_macro/passage-end-tag.swig","hash":"0bd1e2cebdf9c0e1152868f16ec024cc933a8f9f","modified":1672221079810},{"_id":"themes/amber/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1672221079789},{"_id":"themes/amber/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1672221079811},{"_id":"themes/amber/layout/_macro/post.swig","hash":"f6c37b96942bde8e78d20b4f1338e696114860b9","modified":1672221079812},{"_id":"themes/amber/layout/_partials/footer.swig","hash":"a9afe3107c927f9871b3b14a2f59523d7f2131e4","modified":1672221079815},{"_id":"themes/amber/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1672221079822},{"_id":"themes/amber/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1672221079813},{"_id":"themes/amber/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1672221079825},{"_id":"themes/amber/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1672221079814},{"_id":"themes/amber/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1672221079836},{"_id":"themes/amber/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1672221079837},{"_id":"themes/amber/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1672221079841},{"_id":"themes/amber/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1672221079839},{"_id":"themes/amber/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1672221079842},{"_id":"themes/amber/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1672221079835},{"_id":"themes/amber/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1672221079857},{"_id":"themes/amber/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1672221079884},{"_id":"themes/amber/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1672221079849},{"_id":"themes/amber/scripts/filters/default-injects.js","hash":"b08be81819eeeb3c1dcf0a371f95d722246052a2","modified":1672221079897},{"_id":"themes/amber/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1672221079898},{"_id":"themes/amber/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1672221079897},{"_id":"themes/amber/scripts/filters/minify.js","hash":"4d3b771246a7212e94b3df5fb11de89083fe8b80","modified":1672221079899},{"_id":"themes/amber/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1672221079908},{"_id":"themes/amber/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1672221079900},{"_id":"themes/amber/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1672221079909},{"_id":"themes/amber/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1672221079910},{"_id":"themes/amber/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1672221079911},{"_id":"themes/amber/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1672221079862},{"_id":"themes/amber/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1672221079912},{"_id":"themes/amber/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1672221079861},{"_id":"themes/amber/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1672221079913},{"_id":"themes/amber/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1672221079914},{"_id":"themes/amber/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1672221079915},{"_id":"themes/amber/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1672221079916},{"_id":"themes/amber/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1672221079916},{"_id":"themes/amber/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1672221079902},{"_id":"themes/amber/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1672221079902},{"_id":"themes/amber/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1672221079903},{"_id":"themes/amber/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1672221079904},{"_id":"themes/amber/source/css/_colors.styl","hash":"0a9921cb32d95f6d850069d7e28acf8fcd286fd4","modified":1672221079919},{"_id":"themes/amber/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1672221079989},{"_id":"themes/amber/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1672221080029},{"_id":"themes/amber/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1672221080002},{"_id":"themes/amber/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1672221080001},{"_id":"themes/amber/source/css/main.styl","hash":"947ce6126b9a77340ec4ea98e9113d45be1f8f9c","modified":1672221079999},{"_id":"themes/amber/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1672221080008},{"_id":"themes/amber/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1672221080009},{"_id":"themes/amber/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1672221080012},{"_id":"themes/amber/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1672221080010},{"_id":"themes/amber/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1672221080011},{"_id":"themes/amber/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1672221080013},{"_id":"themes/amber/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1672221080016},{"_id":"themes/amber/source/images/dark.svg","hash":"50f8317b673578282236672968840e1d3aeedc29","modified":1672221080015},{"_id":"themes/amber/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1672221080012},{"_id":"themes/amber/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1672221080014},{"_id":"themes/amber/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1672221080017},{"_id":"themes/amber/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1672221080019},{"_id":"themes/amber/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1672221080020},{"_id":"themes/amber/source/images/favicon.ico","hash":"45a4501b730f68d716cb8e7571c49e93911c4ae5","modified":1672221080018},{"_id":"themes/amber/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1672221080021},{"_id":"themes/amber/source/images/light.svg","hash":"cfb6c5299622402c2a3bd3e7440857f127990857","modified":1672221080018},{"_id":"themes/amber/source/js/fireworks.js","hash":"e962f49ebf030da1df530b148eac0833d9610935","modified":1672221080022},{"_id":"themes/amber/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1672221080023},{"_id":"themes/amber/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1672221080024},{"_id":"themes/amber/source/js/motion.js","hash":"943b63c4ea05a9610b71bd739a11626da3a478eb","modified":1672221080023},{"_id":"themes/amber/source/js/theme.js","hash":"4f63ae5a2f75f5a85d8cfed46c84e8d9d1e5f48c","modified":1672221080027},{"_id":"themes/amber/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1672221079816},{"_id":"themes/amber/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1672221079824},{"_id":"themes/amber/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1672221079816},{"_id":"themes/amber/source/js/utils.js","hash":"a63ae3a3a65a0f54a5b5056c86263dbed296bece","modified":1672221080028},{"_id":"themes/amber/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1672221079829},{"_id":"themes/amber/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1672221079823},{"_id":"themes/amber/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1672221079827},{"_id":"themes/amber/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1672221079832},{"_id":"themes/amber/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1672221079832},{"_id":"themes/amber/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1672221079828},{"_id":"themes/amber/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1672221079833},{"_id":"themes/amber/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1672221079829},{"_id":"themes/amber/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1672221079830},{"_id":"themes/amber/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1672221079819},{"_id":"themes/amber/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1672221079820},{"_id":"themes/amber/layout/_partials/header/brand.swig","hash":"1c9c9fed3648f13af4f53c0521239ff3b996dbb4","modified":1672221079818},{"_id":"themes/amber/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1672221079821},{"_id":"themes/amber/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1672221079845},{"_id":"themes/amber/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1672221079840},{"_id":"themes/amber/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1672221079821},{"_id":"themes/amber/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1672221079847},{"_id":"themes/amber/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1672221079838},{"_id":"themes/amber/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1672221079846},{"_id":"themes/amber/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1672221079848},{"_id":"themes/amber/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1672221079834},{"_id":"themes/amber/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1672221079851},{"_id":"themes/amber/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1672221079860},{"_id":"themes/amber/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1672221079850},{"_id":"themes/amber/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1672221079859},{"_id":"themes/amber/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1672221079861},{"_id":"themes/amber/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1672221079852},{"_id":"themes/amber/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1672221079856},{"_id":"themes/amber/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1672221079854},{"_id":"themes/amber/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1672221079853},{"_id":"themes/amber/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1672221079855},{"_id":"themes/amber/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1672221079867},{"_id":"themes/amber/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1672221079856},{"_id":"themes/amber/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1672221079869},{"_id":"themes/amber/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1672221079885},{"_id":"themes/amber/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1672221079867},{"_id":"themes/amber/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1672221079868},{"_id":"themes/amber/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1672221079887},{"_id":"themes/amber/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1672221079870},{"_id":"themes/amber/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1672221079886},{"_id":"themes/amber/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1672221079890},{"_id":"themes/amber/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1672221079891},{"_id":"themes/amber/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1672221079892},{"_id":"themes/amber/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1672221079893},{"_id":"themes/amber/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1672221079893},{"_id":"themes/amber/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1672221079894},{"_id":"themes/amber/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1672221079895},{"_id":"themes/amber/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1672221079896},{"_id":"themes/amber/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1672221079871},{"_id":"themes/amber/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1672221079864},{"_id":"themes/amber/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1672221079864},{"_id":"themes/amber/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1672221079865},{"_id":"themes/amber/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1672221079997},{"_id":"themes/amber/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1672221079872},{"_id":"themes/amber/source/css/_variables/base.styl","hash":"cb96d50db6ad958292bafa77d58a06ea09b4f535","modified":1672221079998},{"_id":"themes/amber/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1672221080025},{"_id":"themes/amber/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1672221080026},{"_id":"themes/amber/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1672221080037},{"_id":"themes/amber/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1672221079922},{"_id":"themes/amber/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1672221079924},{"_id":"themes/amber/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1672221079941},{"_id":"themes/amber/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1672221079923},{"_id":"themes/amber/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1672221079971},{"_id":"themes/amber/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1672221080038},{"_id":"themes/amber/source/css/_common/scaffolding/base.styl","hash":"5c6e42274a9ef7c5eafeea9896adec346360fc5d","modified":1672221079970},{"_id":"themes/amber/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1672221079972},{"_id":"themes/amber/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1672221079979},{"_id":"themes/amber/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1672221079977},{"_id":"themes/amber/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1672221079978},{"_id":"themes/amber/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1672221079980},{"_id":"themes/amber/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1672221079958},{"_id":"themes/amber/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1672221079988},{"_id":"themes/amber/source/css/_schemes/Muse/_header.styl","hash":"a170484458cbca51ee8e8375137ff295f143a1ac","modified":1672221079991},{"_id":"themes/amber/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1672221079992},{"_id":"themes/amber/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1672221079958},{"_id":"themes/amber/source/css/_schemes/Muse/_sidebar.styl","hash":"78c7db347614d39ee23d9c8c739ac32132f28b08","modified":1672221079994},{"_id":"themes/amber/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1672221079995},{"_id":"themes/amber/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1672221079996},{"_id":"themes/amber/source/css/_schemes/Muse/_menu.styl","hash":"fcb9e8107fed93c72c7ee24884a9b796d399f7ab","modified":1672221079993},{"_id":"themes/amber/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1672221080032},{"_id":"themes/amber/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1672221080034},{"_id":"themes/amber/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1672221079925},{"_id":"themes/amber/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1672221079926},{"_id":"themes/amber/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1672221079927},{"_id":"themes/amber/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1672221079929},{"_id":"themes/amber/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1672221079931},{"_id":"themes/amber/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1672221079928},{"_id":"themes/amber/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1672221079930},{"_id":"themes/amber/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1672221079931},{"_id":"themes/amber/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1672221079932},{"_id":"themes/amber/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1672221079934},{"_id":"themes/amber/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1672221079933},{"_id":"themes/amber/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1672221079935},{"_id":"themes/amber/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1672221079938},{"_id":"themes/amber/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1672221079935},{"_id":"themes/amber/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1672221079938},{"_id":"themes/amber/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1672221079937},{"_id":"themes/amber/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1672221079939},{"_id":"themes/amber/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1672221079943},{"_id":"themes/amber/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1672221079943},{"_id":"themes/amber/source/css/_common/components/post/post.styl","hash":"8d884bb9f3386d710588749a7da2df40c7c49b42","modified":1672221079940},{"_id":"themes/amber/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1672221079944},{"_id":"themes/amber/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1672221079946},{"_id":"themes/amber/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1672221079945},{"_id":"themes/amber/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1672221079974},{"_id":"themes/amber/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1672221079973},{"_id":"themes/amber/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1672221079981},{"_id":"themes/amber/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1672221079975},{"_id":"themes/amber/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1672221079982},{"_id":"themes/amber/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1672221079982},{"_id":"themes/amber/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1672221079976},{"_id":"themes/amber/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1672221079985},{"_id":"themes/amber/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1672221079987},{"_id":"themes/amber/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1672221079983},{"_id":"themes/amber/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1672221079986},{"_id":"themes/amber/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1672221079951},{"_id":"themes/amber/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1672221079949},{"_id":"themes/amber/source/css/_common/outline/header/github-banner.styl","hash":"1283ee3dce7b47cdf6c4b89a9e36fe699fd49797","modified":1672221079952},{"_id":"themes/amber/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1672221079954},{"_id":"themes/amber/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1672221079953},{"_id":"themes/amber/source/css/_common/outline/header/menu.styl","hash":"638718693167f0308e2374b20cff3560b3ee4626","modified":1672221079955},{"_id":"themes/amber/source/css/_common/outline/header/site-meta.styl","hash":"5cd570ca9540ae72bbcf3d2019b27da01d85893a","modified":1672221079956},{"_id":"themes/amber/source/css/_common/outline/header/site-nav.styl","hash":"2f81f5d303d33920d0d0caec49ccebb377166deb","modified":1672221079957},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1672221079962},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1672221079960},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1672221079963},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"6a448a5838579993d6e99323dbda40389df449c6","modified":1672221079961},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1672221079963},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1672221079966},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1672221079964},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1672221079965},{"_id":"themes/amber/source/css/_common/outline/sidebar/sidebar.styl","hash":"a844c63d0c8bdd586f0c73a9dee99841d7556d9d","modified":1672221079967},{"_id":"themes/amber/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1672221079968},{"_id":"themes/amber/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1672221080033},{"_id":"themes/amber/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1672221080035},{"_id":"public/atom.xml","hash":"300e4043f956bab9055f307b6534468ed6c1149a","modified":1678454776348},{"_id":"public/search.xml","hash":"228615c055e9e82b139c8dd0ed114e7addbc2693","modified":1678454776348},{"_id":"public/about/index.html","hash":"058c58fe86a4ab6a940655047404063f9cb7de34","modified":1678454776348},{"_id":"public/categories/index.html","hash":"219562877f03aad9ec3d277928f58a7154952215","modified":1678454776348},{"_id":"public/tags/index.html","hash":"eb8c6284625cc601d96864d35e872d972fb95478","modified":1678454776348},{"_id":"public/archives/2021/07/index.html","hash":"e75fabe559146a8d3d1bb208f0b9bb921ddbbdba","modified":1678454776348},{"_id":"public/archives/2021/10/index.html","hash":"153d4aed69d8170b18217133f0c75a8427eece99","modified":1678454776348},{"_id":"public/archives/2021/11/index.html","hash":"3d874b78762a220095affa734c4c77b9f3e38205","modified":1678454776348},{"_id":"public/archives/2021/12/index.html","hash":"fb71c6d8ad389db2bebedcef2f6140908dacd310","modified":1678454776348},{"_id":"public/archives/2022/01/index.html","hash":"7cb0aacf5519f69e4c4a3f3b35f71558fd89c5f6","modified":1678454776348},{"_id":"public/archives/2022/02/index.html","hash":"78cc488566e21c921456fadd63473304265e9c82","modified":1678454776348},{"_id":"public/archives/2022/05/index.html","hash":"fff36e74f1c5343190a942e585086208a53fb533","modified":1678454776348},{"_id":"public/archives/2022/07/index.html","hash":"478e1e214a0dea869316b9702f42746950430aef","modified":1678454776348},{"_id":"public/archives/2022/09/index.html","hash":"0a474260a3eec6e1c581f1e43d8d8b5b6f00bef9","modified":1678454776348},{"_id":"public/archives/2022/10/index.html","hash":"08ee11647bc88a1f7101f5c2ff7b915e89516b15","modified":1678454776348},{"_id":"public/archives/2022/12/index.html","hash":"cf26b3dfc3bbe23b4649591b5ac44965b3280ed4","modified":1678454776348},{"_id":"public/archives/2023/02/index.html","hash":"1c283d6a8650e1af4e52d88285b95a7fb8d9d372","modified":1678454776348},{"_id":"public/archives/2023/03/index.html","hash":"ff6fe6b0c056e145a370ade2562ecf08f5f6c1b9","modified":1678454776348},{"_id":"public/archives/2023/index.html","hash":"2182a97f490fdb31f8d136caf5d9a579a849b41e","modified":1678454776348},{"_id":"public/categories/年终总结/index.html","hash":"b1f2bea2ce7508fa321da813c298ded31e3fb75b","modified":1678454776348},{"_id":"public/categories/javascript/index.html","hash":"87b971ac1bf34b1b38c098dc2e0c2534343484a8","modified":1678454776348},{"_id":"public/categories/python/index.html","hash":"f8793699b5bf7a6c3044defb6d892ce1246f6a60","modified":1678454776348},{"_id":"public/categories/react/index.html","hash":"00c4d9a818dcfa840ce08e32ecad66f9c3c1aa41","modified":1678454776348},{"_id":"public/categories/一些趣事的🌟/index.html","hash":"390b639ddd2a22b7b76fe44e6c8b4ec2c30210e1","modified":1678454776348},{"_id":"public/categories/web/index.html","hash":"9176b3c81267e61608629f14db417e8c2cea3732","modified":1678454776348},{"_id":"public/tags/隐式转换/index.html","hash":"56ddd0becabf41234fd42525e5f97a140d94c6b9","modified":1678454776348},{"_id":"public/tags/deploy-qingfuwu/index.html","hash":"831dd0e56f054c00a3538ca092a1f7aae80011b2","modified":1678454776348},{"_id":"public/tags/numpy/index.html","hash":"63504abd2abb558a186742a1ae8dcfaa5f43e32a","modified":1678454776348},{"_id":"public/tags/Event/index.html","hash":"8aa31f25a5e30fcd1151f00bf8c1f427a204802c","modified":1678454776348},{"_id":"public/friendsLinks/index.html","hash":"9f3dfd66f1a663159799a34b671592e94f3c3126","modified":1678454776348},{"_id":"public/2023/03/09/JavaScript-的隐式转换/index.html","hash":"07c501ce040e7cc82b427a826ddfc9379a6bb696","modified":1678454776348},{"_id":"public/2023/02/10/【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？/index.html","hash":"7a70ab330ccc340928c3a7b6712f29dc7b58a07a","modified":1678454776348},{"_id":"public/2022/12/31/2022-年终总结/index.html","hash":"6b49ecd99a1848381d1a03650b4bfec0b9e82acd","modified":1678454776348},{"_id":"public/2022/10/11/【译】优化长任务-Optimize-long-tasks/index.html","hash":"7dc60b79cc36527a1cdfe0bd49e5e16144e72511","modified":1678454776348},{"_id":"public/2022/09/11/Scroll-开发小记/index.html","hash":"b62bdaf369a18adbafa39a05844e4050a10c03d9","modified":1678454776348},{"_id":"public/2022/07/21/svg基础/index.html","hash":"878ccc66ab68b7750a89d083116f22ba036e73f9","modified":1678454776348},{"_id":"public/2022/05/01/react合成事件/index.html","hash":"f9bff10e958e66ce142f9dee49eab459a31977e4","modified":1678454776348},{"_id":"public/2022/02/08/一封阿里云的喝茶邮件/index.html","hash":"a4e970d5f8a99395cd232a56bc1362cf4042ef2e","modified":1678454776348},{"_id":"public/2022/01/12/聊聊JavaScript事件循环/index.html","hash":"67120a66c0b37e239455a0fe0d4417e112aeff06","modified":1678454776348},{"_id":"public/2021/12/31/2021年终总结/index.html","hash":"bad0b484f30e56d54c075ccf7b53c22ac47a681c","modified":1678454776348},{"_id":"public/2021/12/07/谈谈cookie、session与token-jwt/index.html","hash":"e13c5f94a4f5292b2d1e3b4c9fa745fc21731869","modified":1678454776348},{"_id":"public/2021/11/18/一次base64指令的powershell/index.html","hash":"686e5a7801df786992eab4c70160ed98aebf47df","modified":1678454776348},{"_id":"public/2021/10/22/actions进行轻服务的页面部署/index.html","hash":"e1a0d56378a634b9368a085184833672fba8e757","modified":1678454776348},{"_id":"public/2021/10/21/对javaScript事件冒泡与事件捕获的再学习/index.html","hash":"127145e398ed82ac4f924f92cb8d4213c5a71fc5","modified":1678454776348},{"_id":"public/2021/10/13/numpy条件选择/index.html","hash":"98fc9225b1cc7fa85f178bcf691f3620ac4ca0ff","modified":1678454776348},{"_id":"public/2021/07/21/hello-world/index.html","hash":"3190989de66e7807f96b978da66c9dcee0a9fc7a","modified":1678454776348},{"_id":"public/archives/index.html","hash":"cfda6d08cb0437924cf362239649f20527e093ba","modified":1678454776348},{"_id":"public/archives/page/2/index.html","hash":"50f8e0fabc8d92acb5ef06409b05aa977a229b2e","modified":1678454776348},{"_id":"public/archives/2021/index.html","hash":"d6230c19b79a7e614ac40748fcd634dcaf221706","modified":1678454776348},{"_id":"public/archives/2022/index.html","hash":"fc3c3091ef9bf38eedc1f658877f0601e0a17c93","modified":1678454776348},{"_id":"public/index.html","hash":"956a5922c93bd4b0a57a137806799bfc95d3e489","modified":1678454776348},{"_id":"public/page/2/index.html","hash":"de78cf1b69227136b639fd41ea77fd7827896724","modified":1678454776348},{"_id":"public/CNAME","hash":"d4c178941bdc5e06b035393a72cfd390869dda1b","modified":1678454776348},{"_id":"public/images/avatar.png","hash":"6aaf9775d28026f8ce19d2a446776b6514b56d14","modified":1678454776348},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1678454776348},{"_id":"public/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1678454776348},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1678454776348},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1678454776348},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1678454776348},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1678454776348},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1678454776348},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1678454776348},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1678454776348},{"_id":"public/images/dark.svg","hash":"50f8317b673578282236672968840e1d3aeedc29","modified":1678454776348},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1678454776348},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1678454776348},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1678454776348},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1678454776348},{"_id":"public/images/favicon.ico","hash":"45a4501b730f68d716cb8e7571c49e93911c4ae5","modified":1678454776348},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1678454776348},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1678454776348},{"_id":"public/images/light.svg","hash":"cfb6c5299622402c2a3bd3e7440857f127990857","modified":1678454776348},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1678454776348},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1678454776348},{"_id":"public/css/main.css","hash":"4db4905fe45ad234dd903116e656bd572adf023b","modified":1678454776348},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1678454776348},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1678454776348},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1678454776348},{"_id":"public/js/fireworks.js","hash":"545c23cb641073dba2e361674f264f32bf90f72b","modified":1678454776348},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1678454776348},{"_id":"public/js/motion.js","hash":"c44fed8b215611710f600b8b880c1d1f17ed97ac","modified":1678454776348},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1678454776348},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1678454776348},{"_id":"public/js/utils.js","hash":"c00604b8873f18c20d8b5d54965e55f344b37412","modified":1678454776348},{"_id":"public/js/theme.js","hash":"4ebcd56d1780bcbeb2ec81a53689845ec2c7e307","modified":1678454776348},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1678454776348},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1678454776348},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1678454776348},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1678454776348}],"Category":[{"name":"年终总结","_id":"clf2kmzxc0004g8v75jq64qpg"},{"name":"javascript","_id":"clf2kmzxr000dg8v7cequ3534"},{"name":"python","_id":"clf2kmzyk000mg8v73crn4wdg"},{"name":"react","_id":"clf2kmzyr000rg8v76l6751ge"},{"name":"一些趣事的🌟","_id":"clf2kmzyv000wg8v74xis7exv"},{"name":"web","_id":"clf2kmzz20014g8v75nwja8mk"}],"Data":[{"_id":"linklist","data":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}],"Page":[{"title":"· 关于 ·","date":"2021-10-01T11:24:48.000Z","_content":"\n```javascript\n喜欢 JavaScript;\n兴趣 python;\n害怕新东西，但又喜欢新东西;\n热爱前端，更爱大前端;\n喜欢生活，希望生活也喜欢我😂\n```\n\n> %E7%83%AD%E7%88%B1%E4%BD%A0%E6%89%80%E7%83%AD%E7%88%B1 ----------- _mySelf_（url encoded😀）\n","source":"about/index.md","raw":"---\ntitle: · 关于 ·\ndate: 2021-10-01 19:24:48\n---\n\n```javascript\n喜欢 JavaScript;\n兴趣 python;\n害怕新东西，但又喜欢新东西;\n热爱前端，更爱大前端;\n喜欢生活，希望生活也喜欢我😂\n```\n\n> %E7%83%AD%E7%88%B1%E4%BD%A0%E6%89%80%E7%83%AD%E7%88%B1 ----------- _mySelf_（url encoded😀）\n","updated":"2022-12-31T10:26:33.604Z","path":"about/index.html","comments":1,"layout":"page","_id":"clf2kmzwy0000g8v75s5jhr15","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">喜欢 JavaScript;</span><br><span class=\"line\">兴趣 python;</span><br><span class=\"line\">害怕新东西，但又喜欢新东西;</span><br><span class=\"line\">热爱前端，更爱大前端;</span><br><span class=\"line\">喜欢生活，希望生活也喜欢我😂</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>%E7%83%AD%E7%88%B1%E4%BD%A0%E6%89%80%E7%83%AD%E7%88%B1 ———– _mySelf_（url encoded😀）</p>\n</blockquote>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":147,"excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">喜欢 JavaScript;</span><br><span class=\"line\">兴趣 python;</span><br><span class=\"line\">害怕新东西，但又喜欢新东西;</span><br><span class=\"line\">热爱前端，更爱大前端;</span><br><span class=\"line\">喜欢生活，希望生活也喜欢我😂</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>%E7%83%AD%E7%88%B1%E4%BD%A0%E6%89%80%E7%83%AD%E7%88%B1 ———– _mySelf_（url encoded😀）</p>\n</blockquote>\n"},{"title":"下面的各位都是大佬","date":"2021-11-08T16:16:21.000Z","type":"links","_content":"","source":"friendsLinks/index.md","raw":"---\ntitle: 下面的各位都是大佬\ndate: 2021-11-09 00:16:21\ntype: links\n---\n","updated":"2022-12-31T10:26:33.607Z","path":"friendsLinks/index.html","comments":1,"layout":"page","_id":"clf2kmzx80002g8v71zwc4wid","content":"","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":0,"excerpt":"","more":""},{"title":"categories","date":"2021-10-01T11:23:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-10-01 19:23:20\ntype: \"categories\"\n---\n","updated":"2022-12-31T10:26:33.605Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clf2kmzxe0005g8v7cwfsauix","content":"","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":0,"excerpt":"","more":""},{"title":"tags","date":"2021-10-01T11:24:20.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-10-01 19:24:20\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-12-31T10:26:33.613Z","path":"tags/index.html","layout":"page","_id":"clf2kmzxh0007g8v75g0qbapr","content":"","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"2021年终总结","date":"2021-12-30T17:44:31.000Z","_content":"\n> 感想： 时间过得真的很快，而需要学习的东西一直在变多，从大二到大三的，慢慢地就觉得自己接触的领域所渺小。而这一年里感受最深的总还是时间不够的样子。\n\n---\n\n<!-- more -->\n\n### 学习\n\n在学习上，尽管不是所有课程安排得很妥当，但也有一些课程让我受益良多。记忆比较深刻得还是暑假前的 flutter 课程吧。那一次面临得挑战是未知、课程时间短。而最终的任务是使用 flutter 完成一个 APP。而我做的就是一个记笔记的 APP 了[(https://github.com/Jealh-h/lightNote)](https://github.com/Jealh-h/lightNote)，尽管功能不是那么完善，但这次让我体验到了全栈开发的一些困难吧，得益于 eggjs 框架能让我一个不太懂后端的轻松一点.......。数据分析这门课也挺好的，至少让我在机器学习方面能够调库了，能训练模型了。特别是在最后的房价预测的项目上，从数据获取到数据分析再到模型预测，这一套下来让我觉得 python 更加强大了。其次就是数据可视化了，虽然说理论课着实有一点无聊，好在实验课还比较有趣，这次让我体验了一把 d3js,给我的感觉就是 jquery 的一个兄弟一样，只不过更加适合于绘制图形。最后说说编译原理吧，这门课就感觉比较神奇吧？！从词法分析到语法分析，再到语义分析等等。都感觉有很强的理论支撑。单就对于给定的 test 来说，做一个词法分析、语法分析的工作量就挺大的（求 NFA、DFA,改写 LL(1)文法等等），可见哪些语言之父是有多 🐂 了。\n\n### 生活\n\n在这一年里依然那么喜欢逛 bi 站,喜欢听音乐。印象最深的还是《双城之战》了,一方面是我喜欢的画风，但是呢这剧情确实有点虐了,这大概就是角色设定吧。\n**qq 音乐年度报告**\n![qq音乐](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/qqmusic_2021.PNG)\n\n**bilibili 年度报告**\n![bilibili](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bilibili_2021.PNG)\n\n### 技术栈\n\n在技术栈上，对于 react 的使用更加熟悉了，尽管自己想用 vue 写一个个人博客，但写到一半还是放弃了（可能那时候还不知道一些强大的 nodejs 框架吧）。所以还是 hexo 香啊，就这样发现了写博客是一件强化记忆的事情。在这一年里，虽然在知识广度上有了提升，但在深度上感觉还学提升。比较纠结的还是对于一些工具不知到是要会到什么层度吧，比如 webpack,vite 是会按照官方文档配置，还是能熟练地写出来。暑期在实验室期间，把原有的 oj3 由 webpack 构建改成了 vite,只能说 vite 真快。使用 react 重写了一个会议室管理系统端。而对于微信小程序那边，虽然没有获得奖，但也收获了一些开发经验吧。而对于一些其他知识，比如 rust、electron、wasm、以及游戏开发都是很想学的，但都会感觉自由的时间太少，而学习又需要耗费大量时间。所以还需要控制自己、让自己珍惜时间啊。\n\n### 期望\n\n希望自己记忆力好一点。\n每一天都要崭新的一点。\n对渴望的事情执着一点。\n让自己的想法丰富一点。\n\n**就上面那么亿点就够了**\n","source":"_posts/2021年终总结.md","raw":"---\ntitle: 2021年终总结\ndate: 2021-12-31 01:44:31\ntags:\ncategories: 年终总结\n---\n\n> 感想： 时间过得真的很快，而需要学习的东西一直在变多，从大二到大三的，慢慢地就觉得自己接触的领域所渺小。而这一年里感受最深的总还是时间不够的样子。\n\n---\n\n<!-- more -->\n\n### 学习\n\n在学习上，尽管不是所有课程安排得很妥当，但也有一些课程让我受益良多。记忆比较深刻得还是暑假前的 flutter 课程吧。那一次面临得挑战是未知、课程时间短。而最终的任务是使用 flutter 完成一个 APP。而我做的就是一个记笔记的 APP 了[(https://github.com/Jealh-h/lightNote)](https://github.com/Jealh-h/lightNote)，尽管功能不是那么完善，但这次让我体验到了全栈开发的一些困难吧，得益于 eggjs 框架能让我一个不太懂后端的轻松一点.......。数据分析这门课也挺好的，至少让我在机器学习方面能够调库了，能训练模型了。特别是在最后的房价预测的项目上，从数据获取到数据分析再到模型预测，这一套下来让我觉得 python 更加强大了。其次就是数据可视化了，虽然说理论课着实有一点无聊，好在实验课还比较有趣，这次让我体验了一把 d3js,给我的感觉就是 jquery 的一个兄弟一样，只不过更加适合于绘制图形。最后说说编译原理吧，这门课就感觉比较神奇吧？！从词法分析到语法分析，再到语义分析等等。都感觉有很强的理论支撑。单就对于给定的 test 来说，做一个词法分析、语法分析的工作量就挺大的（求 NFA、DFA,改写 LL(1)文法等等），可见哪些语言之父是有多 🐂 了。\n\n### 生活\n\n在这一年里依然那么喜欢逛 bi 站,喜欢听音乐。印象最深的还是《双城之战》了,一方面是我喜欢的画风，但是呢这剧情确实有点虐了,这大概就是角色设定吧。\n**qq 音乐年度报告**\n![qq音乐](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/qqmusic_2021.PNG)\n\n**bilibili 年度报告**\n![bilibili](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bilibili_2021.PNG)\n\n### 技术栈\n\n在技术栈上，对于 react 的使用更加熟悉了，尽管自己想用 vue 写一个个人博客，但写到一半还是放弃了（可能那时候还不知道一些强大的 nodejs 框架吧）。所以还是 hexo 香啊，就这样发现了写博客是一件强化记忆的事情。在这一年里，虽然在知识广度上有了提升，但在深度上感觉还学提升。比较纠结的还是对于一些工具不知到是要会到什么层度吧，比如 webpack,vite 是会按照官方文档配置，还是能熟练地写出来。暑期在实验室期间，把原有的 oj3 由 webpack 构建改成了 vite,只能说 vite 真快。使用 react 重写了一个会议室管理系统端。而对于微信小程序那边，虽然没有获得奖，但也收获了一些开发经验吧。而对于一些其他知识，比如 rust、electron、wasm、以及游戏开发都是很想学的，但都会感觉自由的时间太少，而学习又需要耗费大量时间。所以还需要控制自己、让自己珍惜时间啊。\n\n### 期望\n\n希望自己记忆力好一点。\n每一天都要崭新的一点。\n对渴望的事情执着一点。\n让自己的想法丰富一点。\n\n**就上面那么亿点就够了**\n","slug":"2021年终总结","published":1,"updated":"2022-12-31T10:26:33.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzx20001g8v7h7e1bwxs","content":"<blockquote>\n<p>感想： 时间过得真的很快，而需要学习的东西一直在变多，从大二到大三的，慢慢地就觉得自己接触的领域所渺小。而这一年里感受最深的总还是时间不够的样子。</p>\n</blockquote>\n<hr>\n<span id=\"more\"></span>\n\n<h3 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h3><p>在学习上，尽管不是所有课程安排得很妥当，但也有一些课程让我受益良多。记忆比较深刻得还是暑假前的 flutter 课程吧。那一次面临得挑战是未知、课程时间短。而最终的任务是使用 flutter 完成一个 APP。而我做的就是一个记笔记的 APP 了<a href=\"https://github.com/Jealh-h/lightNote\">(https://github.com/Jealh-h/lightNote)</a>，尽管功能不是那么完善，但这次让我体验到了全栈开发的一些困难吧，得益于 eggjs 框架能让我一个不太懂后端的轻松一点…….。数据分析这门课也挺好的，至少让我在机器学习方面能够调库了，能训练模型了。特别是在最后的房价预测的项目上，从数据获取到数据分析再到模型预测，这一套下来让我觉得 python 更加强大了。其次就是数据可视化了，虽然说理论课着实有一点无聊，好在实验课还比较有趣，这次让我体验了一把 d3js,给我的感觉就是 jquery 的一个兄弟一样，只不过更加适合于绘制图形。最后说说编译原理吧，这门课就感觉比较神奇吧？！从词法分析到语法分析，再到语义分析等等。都感觉有很强的理论支撑。单就对于给定的 test 来说，做一个词法分析、语法分析的工作量就挺大的（求 NFA、DFA,改写 LL(1)文法等等），可见哪些语言之父是有多 🐂 了。</p>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h3><p>在这一年里依然那么喜欢逛 bi 站,喜欢听音乐。印象最深的还是《双城之战》了,一方面是我喜欢的画风，但是呢这剧情确实有点虐了,这大概就是角色设定吧。<br><strong>qq 音乐年度报告</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/qqmusic_2021.PNG\" alt=\"qq音乐\"></p>\n<p><strong>bilibili 年度报告</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bilibili_2021.PNG\" alt=\"bilibili\"></p>\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><p>在技术栈上，对于 react 的使用更加熟悉了，尽管自己想用 vue 写一个个人博客，但写到一半还是放弃了（可能那时候还不知道一些强大的 nodejs 框架吧）。所以还是 hexo 香啊，就这样发现了写博客是一件强化记忆的事情。在这一年里，虽然在知识广度上有了提升，但在深度上感觉还学提升。比较纠结的还是对于一些工具不知到是要会到什么层度吧，比如 webpack,vite 是会按照官方文档配置，还是能熟练地写出来。暑期在实验室期间，把原有的 oj3 由 webpack 构建改成了 vite,只能说 vite 真快。使用 react 重写了一个会议室管理系统端。而对于微信小程序那边，虽然没有获得奖，但也收获了一些开发经验吧。而对于一些其他知识，比如 rust、electron、wasm、以及游戏开发都是很想学的，但都会感觉自由的时间太少，而学习又需要耗费大量时间。所以还需要控制自己、让自己珍惜时间啊。</p>\n<h3 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h3><p>希望自己记忆力好一点。<br>每一天都要崭新的一点。<br>对渴望的事情执着一点。<br>让自己的想法丰富一点。</p>\n<p><strong>就上面那么亿点就够了</strong></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":1127,"excerpt":"<blockquote>\n<p>感想： 时间过得真的很快，而需要学习的东西一直在变多，从大二到大三的，慢慢地就觉得自己接触的领域所渺小。而这一年里感受最深的总还是时间不够的样子。</p>\n</blockquote>\n<hr>","more":"<h3 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h3><p>在学习上，尽管不是所有课程安排得很妥当，但也有一些课程让我受益良多。记忆比较深刻得还是暑假前的 flutter 课程吧。那一次面临得挑战是未知、课程时间短。而最终的任务是使用 flutter 完成一个 APP。而我做的就是一个记笔记的 APP 了<a href=\"https://github.com/Jealh-h/lightNote\">(https://github.com/Jealh-h/lightNote)</a>，尽管功能不是那么完善，但这次让我体验到了全栈开发的一些困难吧，得益于 eggjs 框架能让我一个不太懂后端的轻松一点…….。数据分析这门课也挺好的，至少让我在机器学习方面能够调库了，能训练模型了。特别是在最后的房价预测的项目上，从数据获取到数据分析再到模型预测，这一套下来让我觉得 python 更加强大了。其次就是数据可视化了，虽然说理论课着实有一点无聊，好在实验课还比较有趣，这次让我体验了一把 d3js,给我的感觉就是 jquery 的一个兄弟一样，只不过更加适合于绘制图形。最后说说编译原理吧，这门课就感觉比较神奇吧？！从词法分析到语法分析，再到语义分析等等。都感觉有很强的理论支撑。单就对于给定的 test 来说，做一个词法分析、语法分析的工作量就挺大的（求 NFA、DFA,改写 LL(1)文法等等），可见哪些语言之父是有多 🐂 了。</p>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h3><p>在这一年里依然那么喜欢逛 bi 站,喜欢听音乐。印象最深的还是《双城之战》了,一方面是我喜欢的画风，但是呢这剧情确实有点虐了,这大概就是角色设定吧。<br><strong>qq 音乐年度报告</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/qqmusic_2021.PNG\" alt=\"qq音乐\"></p>\n<p><strong>bilibili 年度报告</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bilibili_2021.PNG\" alt=\"bilibili\"></p>\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><p>在技术栈上，对于 react 的使用更加熟悉了，尽管自己想用 vue 写一个个人博客，但写到一半还是放弃了（可能那时候还不知道一些强大的 nodejs 框架吧）。所以还是 hexo 香啊，就这样发现了写博客是一件强化记忆的事情。在这一年里，虽然在知识广度上有了提升，但在深度上感觉还学提升。比较纠结的还是对于一些工具不知到是要会到什么层度吧，比如 webpack,vite 是会按照官方文档配置，还是能熟练地写出来。暑期在实验室期间，把原有的 oj3 由 webpack 构建改成了 vite,只能说 vite 真快。使用 react 重写了一个会议室管理系统端。而对于微信小程序那边，虽然没有获得奖，但也收获了一些开发经验吧。而对于一些其他知识，比如 rust、electron、wasm、以及游戏开发都是很想学的，但都会感觉自由的时间太少，而学习又需要耗费大量时间。所以还需要控制自己、让自己珍惜时间啊。</p>\n<h3 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h3><p>希望自己记忆力好一点。<br>每一天都要崭新的一点。<br>对渴望的事情执着一点。<br>让自己的想法丰富一点。</p>\n<p><strong>就上面那么亿点就够了</strong></p>"},{"title":"2022 年终总结","date":"2022-12-31T09:53:46.000Z","_content":"\n2022 年就要结束了，回想这一年可谓是五味杂陈啊。也是经历许多第一次的一年吧。\n\n<!-- more -->\n\n## 生活\n\n在这学期开始，也就是大三下，然后开始找实习了。在找实习的过程中还算坎坷吧，经历了人生的第一次面试。其实投的公司一个手能数过来。然后就分别面了字节、网易、蚂蚁。其中字节面了两次，一次是国际化电商，另一次就是我下半年所实习的部门懂车帝了。\n\n曲曲折折，这一年最美好的也就是下半年实习北漂的这一段时间了，跟我的实验室同学、室友、一开始不认识的同校同学（哈哈哈，这称呼感觉有点怪怪的）。\n\n### 租房篇\n\n去北京总得租房吧。是的，然后我们就被中介...(懂的都懂)。第一次租房是三个合租的，房租 8000 一月，首付一共 4 万多吧，三个月。当时还是挺震惊的，第一次拿出去这么多钱 😂。\n\n总的来说，北京租房想事少的话还是走一些平台，比如自如什么的，虽然说有那么亿丢丢贵。但是会有一些服务之类的，比如打扫房间。好像就打扫房间有用 🤔。\n\n### 上班篇\n\n**团队聚餐**\n手动补上 俊哥跟东阳哥 👍\n\n![team](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311521.JPG)\n\n- 地点：北京市海淀区中城/中兴大厦\n\n- 交通工具：开水团的自行车啊哈哈哈哈哈\n\n一个职场小白，初入职场，有很多东西需要学习，不论是专业的还是非专业的。从一个月开始的陌生到后来的轻车熟路。收获颇为丰厚，在这里必须要感谢下我的 mentor，真是非常的 nice。\n\n收获满满的 gitlab\n\n![gitlab commit](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311520.JPG)\n\n很高兴能在这里实习，总的来说累并快乐着，遗憾就是未能留下继续前行 😅。\n\n![waka time](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311502.png)\n\n### 娱乐篇\n\n这波啊，虽然北京跟我想象的有点不一样，但还是可以的\n\n![跟朋友们吃的美食](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311522.PNG)\n\n第一次看见了“大裤衩”\n![大裤衩](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311739.JPG)\n\n和朋友们逛了一小会鸟巢\n![鸟巢](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311740.png)\n\n**回想起来真是回忆满满**\n\n## 思想\n\n这方面还是得多思考吧，也要学会 say no，同时要有自己得见解。\n\n## 规划\n\n- 坚持写作，输出质量文章\n- 学习图形学，发展多领域\n- 有机会发几个 b 站视频 🤔\n- positive\n\n## 总结\n\n2022 充满回忆的一年，感谢我身边的每一个人，他们教会了我许多，让我明白了许多。 Respect。\n","source":"_posts/2022-年终总结.md","raw":"---\ntitle: 2022 年终总结\ndate: 2022-12-31 17:53:46\ntags:\ncategories: 年终总结\n---\n\n2022 年就要结束了，回想这一年可谓是五味杂陈啊。也是经历许多第一次的一年吧。\n\n<!-- more -->\n\n## 生活\n\n在这学期开始，也就是大三下，然后开始找实习了。在找实习的过程中还算坎坷吧，经历了人生的第一次面试。其实投的公司一个手能数过来。然后就分别面了字节、网易、蚂蚁。其中字节面了两次，一次是国际化电商，另一次就是我下半年所实习的部门懂车帝了。\n\n曲曲折折，这一年最美好的也就是下半年实习北漂的这一段时间了，跟我的实验室同学、室友、一开始不认识的同校同学（哈哈哈，这称呼感觉有点怪怪的）。\n\n### 租房篇\n\n去北京总得租房吧。是的，然后我们就被中介...(懂的都懂)。第一次租房是三个合租的，房租 8000 一月，首付一共 4 万多吧，三个月。当时还是挺震惊的，第一次拿出去这么多钱 😂。\n\n总的来说，北京租房想事少的话还是走一些平台，比如自如什么的，虽然说有那么亿丢丢贵。但是会有一些服务之类的，比如打扫房间。好像就打扫房间有用 🤔。\n\n### 上班篇\n\n**团队聚餐**\n手动补上 俊哥跟东阳哥 👍\n\n![team](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311521.JPG)\n\n- 地点：北京市海淀区中城/中兴大厦\n\n- 交通工具：开水团的自行车啊哈哈哈哈哈\n\n一个职场小白，初入职场，有很多东西需要学习，不论是专业的还是非专业的。从一个月开始的陌生到后来的轻车熟路。收获颇为丰厚，在这里必须要感谢下我的 mentor，真是非常的 nice。\n\n收获满满的 gitlab\n\n![gitlab commit](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311520.JPG)\n\n很高兴能在这里实习，总的来说累并快乐着，遗憾就是未能留下继续前行 😅。\n\n![waka time](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311502.png)\n\n### 娱乐篇\n\n这波啊，虽然北京跟我想象的有点不一样，但还是可以的\n\n![跟朋友们吃的美食](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311522.PNG)\n\n第一次看见了“大裤衩”\n![大裤衩](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311739.JPG)\n\n和朋友们逛了一小会鸟巢\n![鸟巢](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311740.png)\n\n**回想起来真是回忆满满**\n\n## 思想\n\n这方面还是得多思考吧，也要学会 say no，同时要有自己得见解。\n\n## 规划\n\n- 坚持写作，输出质量文章\n- 学习图形学，发展多领域\n- 有机会发几个 b 站视频 🤔\n- positive\n\n## 总结\n\n2022 充满回忆的一年，感谢我身边的每一个人，他们教会了我许多，让我明白了许多。 Respect。\n","slug":"2022-年终总结","published":1,"updated":"2022-12-31T10:26:33.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzx90003g8v7hr73fg2c","content":"<p>2022 年就要结束了，回想这一年可谓是五味杂陈啊。也是经历许多第一次的一年吧。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>在这学期开始，也就是大三下，然后开始找实习了。在找实习的过程中还算坎坷吧，经历了人生的第一次面试。其实投的公司一个手能数过来。然后就分别面了字节、网易、蚂蚁。其中字节面了两次，一次是国际化电商，另一次就是我下半年所实习的部门懂车帝了。</p>\n<p>曲曲折折，这一年最美好的也就是下半年实习北漂的这一段时间了，跟我的实验室同学、室友、一开始不认识的同校同学（哈哈哈，这称呼感觉有点怪怪的）。</p>\n<h3 id=\"租房篇\"><a href=\"#租房篇\" class=\"headerlink\" title=\"租房篇\"></a>租房篇</h3><p>去北京总得租房吧。是的，然后我们就被中介…(懂的都懂)。第一次租房是三个合租的，房租 8000 一月，首付一共 4 万多吧，三个月。当时还是挺震惊的，第一次拿出去这么多钱 😂。</p>\n<p>总的来说，北京租房想事少的话还是走一些平台，比如自如什么的，虽然说有那么亿丢丢贵。但是会有一些服务之类的，比如打扫房间。好像就打扫房间有用 🤔。</p>\n<h3 id=\"上班篇\"><a href=\"#上班篇\" class=\"headerlink\" title=\"上班篇\"></a>上班篇</h3><p><strong>团队聚餐</strong><br>手动补上 俊哥跟东阳哥 👍</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311521.JPG\" alt=\"team\"></p>\n<ul>\n<li><p>地点：北京市海淀区中城/中兴大厦</p>\n</li>\n<li><p>交通工具：开水团的自行车啊哈哈哈哈哈</p>\n</li>\n</ul>\n<p>一个职场小白，初入职场，有很多东西需要学习，不论是专业的还是非专业的。从一个月开始的陌生到后来的轻车熟路。收获颇为丰厚，在这里必须要感谢下我的 mentor，真是非常的 nice。</p>\n<p>收获满满的 gitlab</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311520.JPG\" alt=\"gitlab commit\"></p>\n<p>很高兴能在这里实习，总的来说累并快乐着，遗憾就是未能留下继续前行 😅。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311502.png\" alt=\"waka time\"></p>\n<h3 id=\"娱乐篇\"><a href=\"#娱乐篇\" class=\"headerlink\" title=\"娱乐篇\"></a>娱乐篇</h3><p>这波啊，虽然北京跟我想象的有点不一样，但还是可以的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311522.PNG\" alt=\"跟朋友们吃的美食\"></p>\n<p>第一次看见了“大裤衩”<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311739.JPG\" alt=\"大裤衩\"></p>\n<p>和朋友们逛了一小会鸟巢<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311740.png\" alt=\"鸟巢\"></p>\n<p><strong>回想起来真是回忆满满</strong></p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>这方面还是得多思考吧，也要学会 say no，同时要有自己得见解。</p>\n<h2 id=\"规划\"><a href=\"#规划\" class=\"headerlink\" title=\"规划\"></a>规划</h2><ul>\n<li>坚持写作，输出质量文章</li>\n<li>学习图形学，发展多领域</li>\n<li>有机会发几个 b 站视频 🤔</li>\n<li>positive</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>2022 充满回忆的一年，感谢我身边的每一个人，他们教会了我许多，让我明白了许多。 Respect。</p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":761,"excerpt":"<p>2022 年就要结束了，回想这一年可谓是五味杂陈啊。也是经历许多第一次的一年吧。</p>","more":"<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>在这学期开始，也就是大三下，然后开始找实习了。在找实习的过程中还算坎坷吧，经历了人生的第一次面试。其实投的公司一个手能数过来。然后就分别面了字节、网易、蚂蚁。其中字节面了两次，一次是国际化电商，另一次就是我下半年所实习的部门懂车帝了。</p>\n<p>曲曲折折，这一年最美好的也就是下半年实习北漂的这一段时间了，跟我的实验室同学、室友、一开始不认识的同校同学（哈哈哈，这称呼感觉有点怪怪的）。</p>\n<h3 id=\"租房篇\"><a href=\"#租房篇\" class=\"headerlink\" title=\"租房篇\"></a>租房篇</h3><p>去北京总得租房吧。是的，然后我们就被中介…(懂的都懂)。第一次租房是三个合租的，房租 8000 一月，首付一共 4 万多吧，三个月。当时还是挺震惊的，第一次拿出去这么多钱 😂。</p>\n<p>总的来说，北京租房想事少的话还是走一些平台，比如自如什么的，虽然说有那么亿丢丢贵。但是会有一些服务之类的，比如打扫房间。好像就打扫房间有用 🤔。</p>\n<h3 id=\"上班篇\"><a href=\"#上班篇\" class=\"headerlink\" title=\"上班篇\"></a>上班篇</h3><p><strong>团队聚餐</strong><br>手动补上 俊哥跟东阳哥 👍</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311521.JPG\" alt=\"team\"></p>\n<ul>\n<li><p>地点：北京市海淀区中城/中兴大厦</p>\n</li>\n<li><p>交通工具：开水团的自行车啊哈哈哈哈哈</p>\n</li>\n</ul>\n<p>一个职场小白，初入职场，有很多东西需要学习，不论是专业的还是非专业的。从一个月开始的陌生到后来的轻车熟路。收获颇为丰厚，在这里必须要感谢下我的 mentor，真是非常的 nice。</p>\n<p>收获满满的 gitlab</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311520.JPG\" alt=\"gitlab commit\"></p>\n<p>很高兴能在这里实习，总的来说累并快乐着，遗憾就是未能留下继续前行 😅。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311502.png\" alt=\"waka time\"></p>\n<h3 id=\"娱乐篇\"><a href=\"#娱乐篇\" class=\"headerlink\" title=\"娱乐篇\"></a>娱乐篇</h3><p>这波啊，虽然北京跟我想象的有点不一样，但还是可以的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311522.PNG\" alt=\"跟朋友们吃的美食\"></p>\n<p>第一次看见了“大裤衩”<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311739.JPG\" alt=\"大裤衩\"></p>\n<p>和朋友们逛了一小会鸟巢<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311740.png\" alt=\"鸟巢\"></p>\n<p><strong>回想起来真是回忆满满</strong></p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>这方面还是得多思考吧，也要学会 say no，同时要有自己得见解。</p>\n<h2 id=\"规划\"><a href=\"#规划\" class=\"headerlink\" title=\"规划\"></a>规划</h2><ul>\n<li>坚持写作，输出质量文章</li>\n<li>学习图形学，发展多领域</li>\n<li>有机会发几个 b 站视频 🤔</li>\n<li>positive</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>2022 充满回忆的一年，感谢我身边的每一个人，他们教会了我许多，让我明白了许多。 Respect。</p>"},{"title":"JavaScript 的隐式转换","date":"2023-03-09T13:28:10.000Z","_content":"\n对于 JavaScript 中的一些运算符（如：==）来说是比较迷惑的。它们产生的结果有时会让我们变得混淆，那这一切的背后就是“隐式转换”在作祟了。\n\n## 前置\n\n### Number 强制转换\n\n|   target   |                       number                       |\n| :--------: | :------------------------------------------------: |\n| undefined  |                        NaN                         |\n|    null    |                         0                          |\n| true/false |                        1/0                         |\n|   string   |                  解析失败返回 NaN                  |\n|   BigInt   |                     TypeError                      |\n|   Symbol   |                     TypeError                      |\n|   Object   | [@@toPrimitive](\"number\") → valueOf() → toString() |\n\n**string 解析失败：**\n\n- 忽略前导与尾随的空格/行终止符\n- 前导 0 不会识别为八进制文本\n- +和-允许在字符串开头，且只能出现一次，后面不能跟空格\n- Infinity 和 -Infinity 当作字面量\n- 空串或全为空格解析成 0\n- 不能含数字分割符\n\n<!-- more -->\n\n### 强制 boolean 转换\n\n|              target               | Boolean |\n| :-------------------------------: | :-----: |\n|              0 / -0               |  false  |\n|               null                |  false  |\n|                NaN                |  false  |\n|             undefined             |  false  |\n|                \"\"                 |  false  |\n| Object / \"anything but not empty\" |  true   |\n\n### 复杂类型转换成原始类型\n\n复杂数据类型转换为原始类型有以下规则：\n\n- 强制原始值转换：[@@toPrimitive](\"default\") → valueOf() → toString()\n- 强制数字类型转换、强制 number 类型转换、强制 BigInt 类型转换：[@@toPrimitive](\"number\") → valueOf() → toString()\n- 强制字符串类型转换：[@@toPrimitive](\"string\") → toString() → valueOf()\n- Date 和 Symbol 对象是唯一重写 [@@toPrimitive] 方法的对象。Date.prototype[@@toPrimitive] 将 \"default\" hint 视为 \"string\"，而 Symbol.prototype[@@toPrimitive] 忽略 hint 并始终返回一个 symbol。\n\n其中 [@@toPrimitive] 为一个内置的 Symbol 属性，其部署方式为：\n\n```typescript\nconst obj = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === \"number\") {\n      return 10;\n    }\n    if (hint === \"string\") {\n      return \"hello\";\n    }\n    // 'default'\n    return true;\n  },\n};\n\n// 那么当遇到原始类型转换时就相当于自定义转化了\nconst num = +obj;\n// hint为 number, 结果： 10\n```\n\n## 操作符\n\n### ==\n\n首当其冲的肯定是 ”==“， 想必其已经臭名昭著了。那么我们先来看看它的一些坑坑吧 😀。\n\n```typescript\n{} == []\nnull == undefined\nnew String(\"str\") == true\n```\n\n首先，我们明确一下 == 的规则，那么就非常容易去判断结果了，其规则为：\n\n1. <span id=\"same primitve\">相同类型</span>：\n\n- Object 类型：比较引用地址\n- Number: 有 NaN 则返回 false, +0 与 -0 相等，操作数相等则返回 true。\n- String：只有当两个操作数具有相同的字符且顺序相同时才返回 true。\n- Boolean：仅当操作数都为 true 或都为 false 时返回 true。\n- BigInt：仅当两个操作数值相同时返回 true。\n- Symbol：仅当两个操作数引用相同的符号时返回 true。\n- null: 另一个数为 undefined 或 null 才返回 true。否则返回 false。\n- undefined: 另一个数为 undefined 或 null 才返回 true。否则返回 false。\n\n2. 其中一个是对象，另一个是基本类型。会按照**<a href=\"#前置\">前置</a>**的规则进行转换成基本类型。\n\n3. 这时都是**基本类型**了，那么有如下规则。\n\n- 都是基本类型，按照<a href=\"#same primitve\">规则 1</a>进行对比。\n- 其中一个是 Symbol, 另一个不是，返回 false。\n- 其中一个是 boolean, 另一个不是，则将 boolean 转换成数字。\n- Number 与 String 对比：使用与 <a href=\"#Number 强制转换\">Number() 构造函数相同的算法</a>将字符串转换为数字。转换失败将导致 NaN，这将保证相等是 false。\n- Number 与 BigInt 对比：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。\n- String 与 BigInt 对比：使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 false。\n\n#### 回到上题\n\n```typescript\n{} == []\n// 相同类型都是 Object, 比较引用地址，因此返回 false\n\nnull == undefined\n// null 与 undefined 返回 true\n\nnew String(\"str\") == true\n// 不同类型\n// 先将 new String(\"str\") 转换成基本类型（强制字符串类型转换）得到：\n// \"str\" == true\n//其中一个是 boolean 类型，转成 number\n// \"str\" == 1\n// 将 string 装换成 number\n// NaN == 1\n// 最后：false\n```\n\n### +\n\n**在求值时，它首先将两个操作数强制转换为基本类型。然后，检查两个操作数的类型**:\n\n- 多个值运算，进行相加操作，如果其中有一个是字符串，那么会将另一个数转换成字符串，进行字符串连接。\n- 多个值运算，都是 BigInt, 执行 BigInt 加法，一方是 BigInt,另一个不是，抛出 TypeError。\n- 多个值运算，没有 String、BigInt, 都转为数字。\n- 单值运算，转换成数字\n\n#### 下面来看一下常见的运算 😏\n\n```typescript\n{} + [] + {} + []\n// 这里有一个坑就是 {} 会识别为一个 block, 然后就成了下面这种情况\n// + [] + {} + []\n// 前部分就相当于单目运算，转换成数字类型 []--valueOf-->[]--toString-->''--toNumber-->0\n// 0 + {} + []\n// 先转换成基本类型\n// 0 + '[object Object]' + []\n// '0[object Object]' + []\n// 转换成基本类型\n// '0[object Object]' + ''\n// 拼接\n//'0[object Object]'\n\ntrue + 1\n// 已经都是基本类型了\n// 没有 String、BigInt，都转换成数字\n// 1 + 1\n// 2\n\nNaN + 1\n// 已经都是基本类型了\n// 没有 String、BigInt，都转换成数字\n// NaN + 1\n// NaN\n\n[] + {}\n// 装换成基本类型\n// '' + '[object Object]'\n// [object Object]\n\n{} + []\n// 同样的坑就是 {} 会识别为一个 block, 然后就成了下面这种情况\n// + []\n// 这里成了单目运算，将后面的转换为数值\n// 0\n\n（{}） + []\n// 这种情况就与 [] + {} 类似了\n// '[object Object]'\n\n// {} + {}\n// 前面识别为 block\n// + {}\n// 单目运算。转换成数字\n// {} --valueOf-->{}--toString-->'[object Object]'--toNumber-->NaN\n// NaN\n\n// [] + []\n// 转换成基本类型\n// '' + ''\n// 拼接\n// ''\n\n\n```\n\n### -\n\n- 两个操作数：将两个操作数转换为数值，并根据两个操作数的类型执行数字减法或 BigInt 减法。如果类型不匹配，则抛出 TypeError。\n- 一个操作数：数字则取反，否则转换成数字类型。\n\n#### 看看例题\n\n```typescript\n[] - {};\n// 转成数字\n// [] --valueOf--》 [] --toString--》 \"\" --toNumber--》 0\n// {}--valueOf--》 {}--toString--》 '[object Object]'--toNumber--》 NaN\n// 0 - NaN\n// NaN\n```\n\n### !\n\n- 运算符将真值或假值转换为对应的相反值\n- 当与非布尔值使用时，如果其操作数可以转化为 true，则返回 false，否则返回 true。\n\n#### !!\n\n双非运算符，将运算值转换成相应的 boolean 类型。\n\n#### 看看例题\n\n```typescript\n![];\n// 将 [] 转成 boolean, 根据强制Boolean转换(Object类型）：[] --> true\n// !true\n// false\n```\n\n### > / <\n\n**所有的比较操作符都是先强制转化左操作数再强制转化右操作数。**\n首先，通过依次调用其 [@@toPrimitive]（以 \"number\" 作为提示）、valueOf() 和 toString() 方法，将对象转换为原始类型。左边的操作数总是在右边的操作数之前被强制转换。\n\n- 如果两个值都是字符串，则根据它们所包含的 Unicode 码位的值，将它们作为字符串进行比较。\n- 否则，尝试将非数值类型转化为数值类型。\n- 如果一个为 NaN, 返回 false。\n\n#### 看看例题\n\n```typescript\n\"a\" < 3;\n// 先将左边转化为数值类型\n// NaN < 3\n// 有一个为NaN, 返回 false\n// false\n\n0 < [];\n// 左边为数字类型，将右边转换为数字类型\n// [] --toString--> '' --toNumber--> 0\n// 0 < 0\n// false\n```\n\n## 总结\n\n隐式转换的规则非常多，但都是向基本类型转换，所以理解<a href=\"#复杂类型转换成原始类型\">复杂类型转换成原始类型</a>比较重要，特别的还需要注意 {} 识别为一个 block 的情况。\n\n## Reference\n\n- <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality>\n- <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2>\n- <https://www.zhihu.com/question/45478070>\n","source":"_posts/JavaScript-的隐式转换.md","raw":"---\ntitle: JavaScript 的隐式转换\ndate: 2023-03-09 21:28:10\ntags: 隐式转换\ncategories: javascript\n---\n\n对于 JavaScript 中的一些运算符（如：==）来说是比较迷惑的。它们产生的结果有时会让我们变得混淆，那这一切的背后就是“隐式转换”在作祟了。\n\n## 前置\n\n### Number 强制转换\n\n|   target   |                       number                       |\n| :--------: | :------------------------------------------------: |\n| undefined  |                        NaN                         |\n|    null    |                         0                          |\n| true/false |                        1/0                         |\n|   string   |                  解析失败返回 NaN                  |\n|   BigInt   |                     TypeError                      |\n|   Symbol   |                     TypeError                      |\n|   Object   | [@@toPrimitive](\"number\") → valueOf() → toString() |\n\n**string 解析失败：**\n\n- 忽略前导与尾随的空格/行终止符\n- 前导 0 不会识别为八进制文本\n- +和-允许在字符串开头，且只能出现一次，后面不能跟空格\n- Infinity 和 -Infinity 当作字面量\n- 空串或全为空格解析成 0\n- 不能含数字分割符\n\n<!-- more -->\n\n### 强制 boolean 转换\n\n|              target               | Boolean |\n| :-------------------------------: | :-----: |\n|              0 / -0               |  false  |\n|               null                |  false  |\n|                NaN                |  false  |\n|             undefined             |  false  |\n|                \"\"                 |  false  |\n| Object / \"anything but not empty\" |  true   |\n\n### 复杂类型转换成原始类型\n\n复杂数据类型转换为原始类型有以下规则：\n\n- 强制原始值转换：[@@toPrimitive](\"default\") → valueOf() → toString()\n- 强制数字类型转换、强制 number 类型转换、强制 BigInt 类型转换：[@@toPrimitive](\"number\") → valueOf() → toString()\n- 强制字符串类型转换：[@@toPrimitive](\"string\") → toString() → valueOf()\n- Date 和 Symbol 对象是唯一重写 [@@toPrimitive] 方法的对象。Date.prototype[@@toPrimitive] 将 \"default\" hint 视为 \"string\"，而 Symbol.prototype[@@toPrimitive] 忽略 hint 并始终返回一个 symbol。\n\n其中 [@@toPrimitive] 为一个内置的 Symbol 属性，其部署方式为：\n\n```typescript\nconst obj = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === \"number\") {\n      return 10;\n    }\n    if (hint === \"string\") {\n      return \"hello\";\n    }\n    // 'default'\n    return true;\n  },\n};\n\n// 那么当遇到原始类型转换时就相当于自定义转化了\nconst num = +obj;\n// hint为 number, 结果： 10\n```\n\n## 操作符\n\n### ==\n\n首当其冲的肯定是 ”==“， 想必其已经臭名昭著了。那么我们先来看看它的一些坑坑吧 😀。\n\n```typescript\n{} == []\nnull == undefined\nnew String(\"str\") == true\n```\n\n首先，我们明确一下 == 的规则，那么就非常容易去判断结果了，其规则为：\n\n1. <span id=\"same primitve\">相同类型</span>：\n\n- Object 类型：比较引用地址\n- Number: 有 NaN 则返回 false, +0 与 -0 相等，操作数相等则返回 true。\n- String：只有当两个操作数具有相同的字符且顺序相同时才返回 true。\n- Boolean：仅当操作数都为 true 或都为 false 时返回 true。\n- BigInt：仅当两个操作数值相同时返回 true。\n- Symbol：仅当两个操作数引用相同的符号时返回 true。\n- null: 另一个数为 undefined 或 null 才返回 true。否则返回 false。\n- undefined: 另一个数为 undefined 或 null 才返回 true。否则返回 false。\n\n2. 其中一个是对象，另一个是基本类型。会按照**<a href=\"#前置\">前置</a>**的规则进行转换成基本类型。\n\n3. 这时都是**基本类型**了，那么有如下规则。\n\n- 都是基本类型，按照<a href=\"#same primitve\">规则 1</a>进行对比。\n- 其中一个是 Symbol, 另一个不是，返回 false。\n- 其中一个是 boolean, 另一个不是，则将 boolean 转换成数字。\n- Number 与 String 对比：使用与 <a href=\"#Number 强制转换\">Number() 构造函数相同的算法</a>将字符串转换为数字。转换失败将导致 NaN，这将保证相等是 false。\n- Number 与 BigInt 对比：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。\n- String 与 BigInt 对比：使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 false。\n\n#### 回到上题\n\n```typescript\n{} == []\n// 相同类型都是 Object, 比较引用地址，因此返回 false\n\nnull == undefined\n// null 与 undefined 返回 true\n\nnew String(\"str\") == true\n// 不同类型\n// 先将 new String(\"str\") 转换成基本类型（强制字符串类型转换）得到：\n// \"str\" == true\n//其中一个是 boolean 类型，转成 number\n// \"str\" == 1\n// 将 string 装换成 number\n// NaN == 1\n// 最后：false\n```\n\n### +\n\n**在求值时，它首先将两个操作数强制转换为基本类型。然后，检查两个操作数的类型**:\n\n- 多个值运算，进行相加操作，如果其中有一个是字符串，那么会将另一个数转换成字符串，进行字符串连接。\n- 多个值运算，都是 BigInt, 执行 BigInt 加法，一方是 BigInt,另一个不是，抛出 TypeError。\n- 多个值运算，没有 String、BigInt, 都转为数字。\n- 单值运算，转换成数字\n\n#### 下面来看一下常见的运算 😏\n\n```typescript\n{} + [] + {} + []\n// 这里有一个坑就是 {} 会识别为一个 block, 然后就成了下面这种情况\n// + [] + {} + []\n// 前部分就相当于单目运算，转换成数字类型 []--valueOf-->[]--toString-->''--toNumber-->0\n// 0 + {} + []\n// 先转换成基本类型\n// 0 + '[object Object]' + []\n// '0[object Object]' + []\n// 转换成基本类型\n// '0[object Object]' + ''\n// 拼接\n//'0[object Object]'\n\ntrue + 1\n// 已经都是基本类型了\n// 没有 String、BigInt，都转换成数字\n// 1 + 1\n// 2\n\nNaN + 1\n// 已经都是基本类型了\n// 没有 String、BigInt，都转换成数字\n// NaN + 1\n// NaN\n\n[] + {}\n// 装换成基本类型\n// '' + '[object Object]'\n// [object Object]\n\n{} + []\n// 同样的坑就是 {} 会识别为一个 block, 然后就成了下面这种情况\n// + []\n// 这里成了单目运算，将后面的转换为数值\n// 0\n\n（{}） + []\n// 这种情况就与 [] + {} 类似了\n// '[object Object]'\n\n// {} + {}\n// 前面识别为 block\n// + {}\n// 单目运算。转换成数字\n// {} --valueOf-->{}--toString-->'[object Object]'--toNumber-->NaN\n// NaN\n\n// [] + []\n// 转换成基本类型\n// '' + ''\n// 拼接\n// ''\n\n\n```\n\n### -\n\n- 两个操作数：将两个操作数转换为数值，并根据两个操作数的类型执行数字减法或 BigInt 减法。如果类型不匹配，则抛出 TypeError。\n- 一个操作数：数字则取反，否则转换成数字类型。\n\n#### 看看例题\n\n```typescript\n[] - {};\n// 转成数字\n// [] --valueOf--》 [] --toString--》 \"\" --toNumber--》 0\n// {}--valueOf--》 {}--toString--》 '[object Object]'--toNumber--》 NaN\n// 0 - NaN\n// NaN\n```\n\n### !\n\n- 运算符将真值或假值转换为对应的相反值\n- 当与非布尔值使用时，如果其操作数可以转化为 true，则返回 false，否则返回 true。\n\n#### !!\n\n双非运算符，将运算值转换成相应的 boolean 类型。\n\n#### 看看例题\n\n```typescript\n![];\n// 将 [] 转成 boolean, 根据强制Boolean转换(Object类型）：[] --> true\n// !true\n// false\n```\n\n### > / <\n\n**所有的比较操作符都是先强制转化左操作数再强制转化右操作数。**\n首先，通过依次调用其 [@@toPrimitive]（以 \"number\" 作为提示）、valueOf() 和 toString() 方法，将对象转换为原始类型。左边的操作数总是在右边的操作数之前被强制转换。\n\n- 如果两个值都是字符串，则根据它们所包含的 Unicode 码位的值，将它们作为字符串进行比较。\n- 否则，尝试将非数值类型转化为数值类型。\n- 如果一个为 NaN, 返回 false。\n\n#### 看看例题\n\n```typescript\n\"a\" < 3;\n// 先将左边转化为数值类型\n// NaN < 3\n// 有一个为NaN, 返回 false\n// false\n\n0 < [];\n// 左边为数字类型，将右边转换为数字类型\n// [] --toString--> '' --toNumber--> 0\n// 0 < 0\n// false\n```\n\n## 总结\n\n隐式转换的规则非常多，但都是向基本类型转换，所以理解<a href=\"#复杂类型转换成原始类型\">复杂类型转换成原始类型</a>比较重要，特别的还需要注意 {} 识别为一个 block 的情况。\n\n## Reference\n\n- <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality>\n- <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2>\n- <https://www.zhihu.com/question/45478070>\n","slug":"JavaScript-的隐式转换","published":1,"updated":"2023-03-09T13:37:57.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzxf0006g8v78v8m9irn","content":"<p>对于 JavaScript 中的一些运算符（如：==）来说是比较迷惑的。它们产生的结果有时会让我们变得混淆，那这一切的背后就是“隐式转换”在作祟了。</p>\n<h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><h3 id=\"Number-强制转换\"><a href=\"#Number-强制转换\" class=\"headerlink\" title=\"Number 强制转换\"></a>Number 强制转换</h3><table>\n<thead>\n<tr>\n<th align=\"center\">target</th>\n<th align=\"center\">number</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">undefined</td>\n<td align=\"center\">NaN</td>\n</tr>\n<tr>\n<td align=\"center\">null</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">true/false</td>\n<td align=\"center\">1/0</td>\n</tr>\n<tr>\n<td align=\"center\">string</td>\n<td align=\"center\">解析失败返回 NaN</td>\n</tr>\n<tr>\n<td align=\"center\">BigInt</td>\n<td align=\"center\">TypeError</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol</td>\n<td align=\"center\">TypeError</td>\n</tr>\n<tr>\n<td align=\"center\">Object</td>\n<td align=\"center\"><a href=\"%22number%22\">@@toPrimitive</a> → valueOf() → toString()</td>\n</tr>\n</tbody></table>\n<p><strong>string 解析失败：</strong></p>\n<ul>\n<li>忽略前导与尾随的空格/行终止符</li>\n<li>前导 0 不会识别为八进制文本</li>\n<li>+和-允许在字符串开头，且只能出现一次，后面不能跟空格</li>\n<li>Infinity 和 -Infinity 当作字面量</li>\n<li>空串或全为空格解析成 0</li>\n<li>不能含数字分割符</li>\n</ul>\n<span id=\"more\"></span>\n\n<h3 id=\"强制-boolean-转换\"><a href=\"#强制-boolean-转换\" class=\"headerlink\" title=\"强制 boolean 转换\"></a>强制 boolean 转换</h3><table>\n<thead>\n<tr>\n<th align=\"center\">target</th>\n<th align=\"center\">Boolean</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0 / -0</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">null</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">NaN</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">undefined</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">“”</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">Object / “anything but not empty”</td>\n<td align=\"center\">true</td>\n</tr>\n</tbody></table>\n<h3 id=\"复杂类型转换成原始类型\"><a href=\"#复杂类型转换成原始类型\" class=\"headerlink\" title=\"复杂类型转换成原始类型\"></a>复杂类型转换成原始类型</h3><p>复杂数据类型转换为原始类型有以下规则：</p>\n<ul>\n<li>强制原始值转换：<a href=\"%22default%22\">@@toPrimitive</a> → valueOf() → toString()</li>\n<li>强制数字类型转换、强制 number 类型转换、强制 BigInt 类型转换：<a href=\"%22number%22\">@@toPrimitive</a> → valueOf() → toString()</li>\n<li>强制字符串类型转换：<a href=\"%22string%22\">@@toPrimitive</a> → toString() → valueOf()</li>\n<li>Date 和 Symbol 对象是唯一重写 [@@toPrimitive] 方法的对象。Date.prototype[@@toPrimitive] 将 “default” hint 视为 “string”，而 Symbol.prototype[@@toPrimitive] 忽略 hint 并始终返回一个 symbol。</li>\n</ul>\n<p>其中 [@@toPrimitive] 为一个内置的 Symbol 属性，其部署方式为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;default&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么当遇到原始类型转换时就相当于自定义转化了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> num = +obj;</span><br><span class=\"line\"><span class=\"comment\">// hint为 number, 结果： 10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h3><p>首当其冲的肯定是 ”==“， 想必其已经臭名昭著了。那么我们先来看看它的一些坑坑吧 😀。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#125; == []</span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;str&quot;</span>) == <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>首先，我们明确一下 == 的规则，那么就非常容易去判断结果了，其规则为：</p>\n<ol>\n<li><span id=\"same primitve\">相同类型</span>：</li>\n</ol>\n<ul>\n<li>Object 类型：比较引用地址</li>\n<li>Number: 有 NaN 则返回 false, +0 与 -0 相等，操作数相等则返回 true。</li>\n<li>String：只有当两个操作数具有相同的字符且顺序相同时才返回 true。</li>\n<li>Boolean：仅当操作数都为 true 或都为 false 时返回 true。</li>\n<li>BigInt：仅当两个操作数值相同时返回 true。</li>\n<li>Symbol：仅当两个操作数引用相同的符号时返回 true。</li>\n<li>null: 另一个数为 undefined 或 null 才返回 true。否则返回 false。</li>\n<li>undefined: 另一个数为 undefined 或 null 才返回 true。否则返回 false。</li>\n</ul>\n<ol start=\"2\">\n<li><p>其中一个是对象，另一个是基本类型。会按照**<a href=\"#前置\">前置</a>**的规则进行转换成基本类型。</p>\n</li>\n<li><p>这时都是<strong>基本类型</strong>了，那么有如下规则。</p>\n</li>\n</ol>\n<ul>\n<li>都是基本类型，按照<a href=\"#same primitve\">规则 1</a>进行对比。</li>\n<li>其中一个是 Symbol, 另一个不是，返回 false。</li>\n<li>其中一个是 boolean, 另一个不是，则将 boolean 转换成数字。</li>\n<li>Number 与 String 对比：使用与 <a href=\"#Number 强制转换\">Number() 构造函数相同的算法</a>将字符串转换为数字。转换失败将导致 NaN，这将保证相等是 false。</li>\n<li>Number 与 BigInt 对比：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。</li>\n<li>String 与 BigInt 对比：使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 false。</li>\n</ul>\n<h4 id=\"回到上题\"><a href=\"#回到上题\" class=\"headerlink\" title=\"回到上题\"></a>回到上题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#125; == []</span><br><span class=\"line\"><span class=\"comment\">// 相同类型都是 Object, 比较引用地址，因此返回 false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"comment\">// null 与 undefined 返回 true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;str&quot;</span>) == <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 不同类型</span></span><br><span class=\"line\"><span class=\"comment\">// 先将 new String(&quot;str&quot;) 转换成基本类型（强制字符串类型转换）得到：</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;str&quot; == true</span></span><br><span class=\"line\"><span class=\"comment\">//其中一个是 boolean 类型，转成 number</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;str&quot; == 1</span></span><br><span class=\"line\"><span class=\"comment\">// 将 string 装换成 number</span></span><br><span class=\"line\"><span class=\"comment\">// NaN == 1</span></span><br><span class=\"line\"><span class=\"comment\">// 最后：false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"+\"></a>+</h3><p><strong>在求值时，它首先将两个操作数强制转换为基本类型。然后，检查两个操作数的类型</strong>:</p>\n<ul>\n<li>多个值运算，进行相加操作，如果其中有一个是字符串，那么会将另一个数转换成字符串，进行字符串连接。</li>\n<li>多个值运算，都是 BigInt, 执行 BigInt 加法，一方是 BigInt,另一个不是，抛出 TypeError。</li>\n<li>多个值运算，没有 String、BigInt, 都转为数字。</li>\n<li>单值运算，转换成数字</li>\n</ul>\n<h4 id=\"下面来看一下常见的运算-😏\"><a href=\"#下面来看一下常见的运算-😏\" class=\"headerlink\" title=\"下面来看一下常见的运算 😏\"></a>下面来看一下常见的运算 😏</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#125; + [] + &#123;&#125; + []</span><br><span class=\"line\"><span class=\"comment\">// 这里有一个坑就是 &#123;&#125; 会识别为一个 block, 然后就成了下面这种情况</span></span><br><span class=\"line\"><span class=\"comment\">// + [] + &#123;&#125; + []</span></span><br><span class=\"line\"><span class=\"comment\">// 前部分就相当于单目运算，转换成数字类型 []--valueOf--&gt;[]--toString--&gt;&#x27;&#x27;--toNumber--&gt;0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 + &#123;&#125; + []</span></span><br><span class=\"line\"><span class=\"comment\">// 先转换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// 0 + &#x27;[object Object]&#x27; + []</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;0[object Object]&#x27; + []</span></span><br><span class=\"line\"><span class=\"comment\">// 转换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;0[object Object]&#x27; + &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 拼接</span></span><br><span class=\"line\"><span class=\"comment\">//&#x27;0[object Object]&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 已经都是基本类型了</span></span><br><span class=\"line\"><span class=\"comment\">// 没有 String、BigInt，都转换成数字</span></span><br><span class=\"line\"><span class=\"comment\">// 1 + 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">NaN</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 已经都是基本类型了</span></span><br><span class=\"line\"><span class=\"comment\">// 没有 String、BigInt，都转换成数字</span></span><br><span class=\"line\"><span class=\"comment\">// NaN + 1</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\">[] + &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 装换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;&#x27; + &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// [object Object]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#125; + []</span><br><span class=\"line\"><span class=\"comment\">// 同样的坑就是 &#123;&#125; 会识别为一个 block, 然后就成了下面这种情况</span></span><br><span class=\"line\"><span class=\"comment\">// + []</span></span><br><span class=\"line\"><span class=\"comment\">// 这里成了单目运算，将后面的转换为数值</span></span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">（&#123;&#125;） + []</span><br><span class=\"line\"><span class=\"comment\">// 这种情况就与 [] + &#123;&#125; 类似了</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125; + &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 前面识别为 block</span></span><br><span class=\"line\"><span class=\"comment\">// + &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 单目运算。转换成数字</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125; --valueOf--&gt;&#123;&#125;--toString--&gt;&#x27;[object Object]&#x27;--toNumber--&gt;NaN</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [] + []</span></span><br><span class=\"line\"><span class=\"comment\">// 转换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;&#x27; + &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 拼接</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"-\"></a>-</h3><ul>\n<li>两个操作数：将两个操作数转换为数值，并根据两个操作数的类型执行数字减法或 BigInt 减法。如果类型不匹配，则抛出 TypeError。</li>\n<li>一个操作数：数字则取反，否则转换成数字类型。</li>\n</ul>\n<h4 id=\"看看例题\"><a href=\"#看看例题\" class=\"headerlink\" title=\"看看例题\"></a>看看例题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] - &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 转成数字</span></span><br><span class=\"line\"><span class=\"comment\">// [] --valueOf--》 [] --toString--》 &quot;&quot; --toNumber--》 0</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125;--valueOf--》 &#123;&#125;--toString--》 &#x27;[object Object]&#x27;--toNumber--》 NaN</span></span><br><span class=\"line\"><span class=\"comment\">// 0 - NaN</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"!\"></a>!</h3><ul>\n<li>运算符将真值或假值转换为对应的相反值</li>\n<li>当与非布尔值使用时，如果其操作数可以转化为 true，则返回 false，否则返回 true。</li>\n</ul>\n<h4 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"!!\"></a>!!</h4><p>双非运算符，将运算值转换成相应的 boolean 类型。</p>\n<h4 id=\"看看例题-1\"><a href=\"#看看例题-1\" class=\"headerlink\" title=\"看看例题\"></a>看看例题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![];</span><br><span class=\"line\"><span class=\"comment\">// 将 [] 转成 boolean, 根据强制Boolean转换(Object类型）：[] --&gt; true</span></span><br><span class=\"line\"><span class=\"comment\">// !true</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"gt-lt\"><a href=\"#gt-lt\" class=\"headerlink\" title=\"&gt; / &lt;\"></a>&gt; / &lt;</h3><p><strong>所有的比较操作符都是先强制转化左操作数再强制转化右操作数。</strong><br>首先，通过依次调用其 [@@toPrimitive]（以 “number” 作为提示）、valueOf() 和 toString() 方法，将对象转换为原始类型。左边的操作数总是在右边的操作数之前被强制转换。</p>\n<ul>\n<li>如果两个值都是字符串，则根据它们所包含的 Unicode 码位的值，将它们作为字符串进行比较。</li>\n<li>否则，尝试将非数值类型转化为数值类型。</li>\n<li>如果一个为 NaN, 返回 false。</li>\n</ul>\n<h4 id=\"看看例题-2\"><a href=\"#看看例题-2\" class=\"headerlink\" title=\"看看例题\"></a>看看例题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a&quot;</span> &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 先将左边转化为数值类型</span></span><br><span class=\"line\"><span class=\"comment\">// NaN &lt; 3</span></span><br><span class=\"line\"><span class=\"comment\">// 有一个为NaN, 返回 false</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> &lt; [];</span><br><span class=\"line\"><span class=\"comment\">// 左边为数字类型，将右边转换为数字类型</span></span><br><span class=\"line\"><span class=\"comment\">// [] --toString--&gt; &#x27;&#x27; --toNumber--&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 &lt; 0</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>隐式转换的规则非常多，但都是向基本类型转换，所以理解<a href=\"#复杂类型转换成原始类型\">复杂类型转换成原始类型</a>比较重要，特别的还需要注意 {} 识别为一个 block 的情况。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2</a></li>\n<li><a href=\"https://www.zhihu.com/question/45478070\">https://www.zhihu.com/question/45478070</a></li>\n</ul>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":4518,"excerpt":"<p>对于 JavaScript 中的一些运算符（如：==）来说是比较迷惑的。它们产生的结果有时会让我们变得混淆，那这一切的背后就是“隐式转换”在作祟了。</p>\n<h2 id=\"前置\"><a href=\"#前置\" class=\"headerlink\" title=\"前置\"></a>前置</h2><h3 id=\"Number-强制转换\"><a href=\"#Number-强制转换\" class=\"headerlink\" title=\"Number 强制转换\"></a>Number 强制转换</h3><table>\n<thead>\n<tr>\n<th align=\"center\">target</th>\n<th align=\"center\">number</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">undefined</td>\n<td align=\"center\">NaN</td>\n</tr>\n<tr>\n<td align=\"center\">null</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">true/false</td>\n<td align=\"center\">1/0</td>\n</tr>\n<tr>\n<td align=\"center\">string</td>\n<td align=\"center\">解析失败返回 NaN</td>\n</tr>\n<tr>\n<td align=\"center\">BigInt</td>\n<td align=\"center\">TypeError</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol</td>\n<td align=\"center\">TypeError</td>\n</tr>\n<tr>\n<td align=\"center\">Object</td>\n<td align=\"center\"><a href=\"%22number%22\">@@toPrimitive</a> → valueOf() → toString()</td>\n</tr>\n</tbody></table>\n<p><strong>string 解析失败：</strong></p>\n<ul>\n<li>忽略前导与尾随的空格/行终止符</li>\n<li>前导 0 不会识别为八进制文本</li>\n<li>+和-允许在字符串开头，且只能出现一次，后面不能跟空格</li>\n<li>Infinity 和 -Infinity 当作字面量</li>\n<li>空串或全为空格解析成 0</li>\n<li>不能含数字分割符</li>\n</ul>","more":"<h3 id=\"强制-boolean-转换\"><a href=\"#强制-boolean-转换\" class=\"headerlink\" title=\"强制 boolean 转换\"></a>强制 boolean 转换</h3><table>\n<thead>\n<tr>\n<th align=\"center\">target</th>\n<th align=\"center\">Boolean</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0 / -0</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">null</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">NaN</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">undefined</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">“”</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"center\">Object / “anything but not empty”</td>\n<td align=\"center\">true</td>\n</tr>\n</tbody></table>\n<h3 id=\"复杂类型转换成原始类型\"><a href=\"#复杂类型转换成原始类型\" class=\"headerlink\" title=\"复杂类型转换成原始类型\"></a>复杂类型转换成原始类型</h3><p>复杂数据类型转换为原始类型有以下规则：</p>\n<ul>\n<li>强制原始值转换：<a href=\"%22default%22\">@@toPrimitive</a> → valueOf() → toString()</li>\n<li>强制数字类型转换、强制 number 类型转换、强制 BigInt 类型转换：<a href=\"%22number%22\">@@toPrimitive</a> → valueOf() → toString()</li>\n<li>强制字符串类型转换：<a href=\"%22string%22\">@@toPrimitive</a> → toString() → valueOf()</li>\n<li>Date 和 Symbol 对象是唯一重写 [@@toPrimitive] 方法的对象。Date.prototype[@@toPrimitive] 将 “default” hint 视为 “string”，而 Symbol.prototype[@@toPrimitive] 忽略 hint 并始终返回一个 symbol。</li>\n</ul>\n<p>其中 [@@toPrimitive] 为一个内置的 Symbol 属性，其部署方式为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;default&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么当遇到原始类型转换时就相当于自定义转化了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> num = +obj;</span><br><span class=\"line\"><span class=\"comment\">// hint为 number, 结果： 10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h3><p>首当其冲的肯定是 ”==“， 想必其已经臭名昭著了。那么我们先来看看它的一些坑坑吧 😀。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#125; == []</span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;str&quot;</span>) == <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>首先，我们明确一下 == 的规则，那么就非常容易去判断结果了，其规则为：</p>\n<ol>\n<li><span id=\"same primitve\">相同类型</span>：</li>\n</ol>\n<ul>\n<li>Object 类型：比较引用地址</li>\n<li>Number: 有 NaN 则返回 false, +0 与 -0 相等，操作数相等则返回 true。</li>\n<li>String：只有当两个操作数具有相同的字符且顺序相同时才返回 true。</li>\n<li>Boolean：仅当操作数都为 true 或都为 false 时返回 true。</li>\n<li>BigInt：仅当两个操作数值相同时返回 true。</li>\n<li>Symbol：仅当两个操作数引用相同的符号时返回 true。</li>\n<li>null: 另一个数为 undefined 或 null 才返回 true。否则返回 false。</li>\n<li>undefined: 另一个数为 undefined 或 null 才返回 true。否则返回 false。</li>\n</ul>\n<ol start=\"2\">\n<li><p>其中一个是对象，另一个是基本类型。会按照**<a href=\"#前置\">前置</a>**的规则进行转换成基本类型。</p>\n</li>\n<li><p>这时都是<strong>基本类型</strong>了，那么有如下规则。</p>\n</li>\n</ol>\n<ul>\n<li>都是基本类型，按照<a href=\"#same primitve\">规则 1</a>进行对比。</li>\n<li>其中一个是 Symbol, 另一个不是，返回 false。</li>\n<li>其中一个是 boolean, 另一个不是，则将 boolean 转换成数字。</li>\n<li>Number 与 String 对比：使用与 <a href=\"#Number 强制转换\">Number() 构造函数相同的算法</a>将字符串转换为数字。转换失败将导致 NaN，这将保证相等是 false。</li>\n<li>Number 与 BigInt 对比：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。</li>\n<li>String 与 BigInt 对比：使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 false。</li>\n</ul>\n<h4 id=\"回到上题\"><a href=\"#回到上题\" class=\"headerlink\" title=\"回到上题\"></a>回到上题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#125; == []</span><br><span class=\"line\"><span class=\"comment\">// 相同类型都是 Object, 比较引用地址，因此返回 false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"comment\">// null 与 undefined 返回 true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;str&quot;</span>) == <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 不同类型</span></span><br><span class=\"line\"><span class=\"comment\">// 先将 new String(&quot;str&quot;) 转换成基本类型（强制字符串类型转换）得到：</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;str&quot; == true</span></span><br><span class=\"line\"><span class=\"comment\">//其中一个是 boolean 类型，转成 number</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;str&quot; == 1</span></span><br><span class=\"line\"><span class=\"comment\">// 将 string 装换成 number</span></span><br><span class=\"line\"><span class=\"comment\">// NaN == 1</span></span><br><span class=\"line\"><span class=\"comment\">// 最后：false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"+\"></a>+</h3><p><strong>在求值时，它首先将两个操作数强制转换为基本类型。然后，检查两个操作数的类型</strong>:</p>\n<ul>\n<li>多个值运算，进行相加操作，如果其中有一个是字符串，那么会将另一个数转换成字符串，进行字符串连接。</li>\n<li>多个值运算，都是 BigInt, 执行 BigInt 加法，一方是 BigInt,另一个不是，抛出 TypeError。</li>\n<li>多个值运算，没有 String、BigInt, 都转为数字。</li>\n<li>单值运算，转换成数字</li>\n</ul>\n<h4 id=\"下面来看一下常见的运算-😏\"><a href=\"#下面来看一下常见的运算-😏\" class=\"headerlink\" title=\"下面来看一下常见的运算 😏\"></a>下面来看一下常见的运算 😏</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#125; + [] + &#123;&#125; + []</span><br><span class=\"line\"><span class=\"comment\">// 这里有一个坑就是 &#123;&#125; 会识别为一个 block, 然后就成了下面这种情况</span></span><br><span class=\"line\"><span class=\"comment\">// + [] + &#123;&#125; + []</span></span><br><span class=\"line\"><span class=\"comment\">// 前部分就相当于单目运算，转换成数字类型 []--valueOf--&gt;[]--toString--&gt;&#x27;&#x27;--toNumber--&gt;0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 + &#123;&#125; + []</span></span><br><span class=\"line\"><span class=\"comment\">// 先转换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// 0 + &#x27;[object Object]&#x27; + []</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;0[object Object]&#x27; + []</span></span><br><span class=\"line\"><span class=\"comment\">// 转换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;0[object Object]&#x27; + &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 拼接</span></span><br><span class=\"line\"><span class=\"comment\">//&#x27;0[object Object]&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 已经都是基本类型了</span></span><br><span class=\"line\"><span class=\"comment\">// 没有 String、BigInt，都转换成数字</span></span><br><span class=\"line\"><span class=\"comment\">// 1 + 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">NaN</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 已经都是基本类型了</span></span><br><span class=\"line\"><span class=\"comment\">// 没有 String、BigInt，都转换成数字</span></span><br><span class=\"line\"><span class=\"comment\">// NaN + 1</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\">[] + &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 装换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;&#x27; + &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// [object Object]</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#125; + []</span><br><span class=\"line\"><span class=\"comment\">// 同样的坑就是 &#123;&#125; 会识别为一个 block, 然后就成了下面这种情况</span></span><br><span class=\"line\"><span class=\"comment\">// + []</span></span><br><span class=\"line\"><span class=\"comment\">// 这里成了单目运算，将后面的转换为数值</span></span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">（&#123;&#125;） + []</span><br><span class=\"line\"><span class=\"comment\">// 这种情况就与 [] + &#123;&#125; 类似了</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125; + &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 前面识别为 block</span></span><br><span class=\"line\"><span class=\"comment\">// + &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 单目运算。转换成数字</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125; --valueOf--&gt;&#123;&#125;--toString--&gt;&#x27;[object Object]&#x27;--toNumber--&gt;NaN</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [] + []</span></span><br><span class=\"line\"><span class=\"comment\">// 转换成基本类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;&#x27; + &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 拼接</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"-\"></a>-</h3><ul>\n<li>两个操作数：将两个操作数转换为数值，并根据两个操作数的类型执行数字减法或 BigInt 减法。如果类型不匹配，则抛出 TypeError。</li>\n<li>一个操作数：数字则取反，否则转换成数字类型。</li>\n</ul>\n<h4 id=\"看看例题\"><a href=\"#看看例题\" class=\"headerlink\" title=\"看看例题\"></a>看看例题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] - &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 转成数字</span></span><br><span class=\"line\"><span class=\"comment\">// [] --valueOf--》 [] --toString--》 &quot;&quot; --toNumber--》 0</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125;--valueOf--》 &#123;&#125;--toString--》 &#x27;[object Object]&#x27;--toNumber--》 NaN</span></span><br><span class=\"line\"><span class=\"comment\">// 0 - NaN</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"!\"></a>!</h3><ul>\n<li>运算符将真值或假值转换为对应的相反值</li>\n<li>当与非布尔值使用时，如果其操作数可以转化为 true，则返回 false，否则返回 true。</li>\n</ul>\n<h4 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"!!\"></a>!!</h4><p>双非运算符，将运算值转换成相应的 boolean 类型。</p>\n<h4 id=\"看看例题-1\"><a href=\"#看看例题-1\" class=\"headerlink\" title=\"看看例题\"></a>看看例题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![];</span><br><span class=\"line\"><span class=\"comment\">// 将 [] 转成 boolean, 根据强制Boolean转换(Object类型）：[] --&gt; true</span></span><br><span class=\"line\"><span class=\"comment\">// !true</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"gt-lt\"><a href=\"#gt-lt\" class=\"headerlink\" title=\"&gt; / &lt;\"></a>&gt; / &lt;</h3><p><strong>所有的比较操作符都是先强制转化左操作数再强制转化右操作数。</strong><br>首先，通过依次调用其 [@@toPrimitive]（以 “number” 作为提示）、valueOf() 和 toString() 方法，将对象转换为原始类型。左边的操作数总是在右边的操作数之前被强制转换。</p>\n<ul>\n<li>如果两个值都是字符串，则根据它们所包含的 Unicode 码位的值，将它们作为字符串进行比较。</li>\n<li>否则，尝试将非数值类型转化为数值类型。</li>\n<li>如果一个为 NaN, 返回 false。</li>\n</ul>\n<h4 id=\"看看例题-2\"><a href=\"#看看例题-2\" class=\"headerlink\" title=\"看看例题\"></a>看看例题</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a&quot;</span> &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 先将左边转化为数值类型</span></span><br><span class=\"line\"><span class=\"comment\">// NaN &lt; 3</span></span><br><span class=\"line\"><span class=\"comment\">// 有一个为NaN, 返回 false</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> &lt; [];</span><br><span class=\"line\"><span class=\"comment\">// 左边为数字类型，将右边转换为数字类型</span></span><br><span class=\"line\"><span class=\"comment\">// [] --toString--&gt; &#x27;&#x27; --toNumber--&gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">// 0 &lt; 0</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>隐式转换的规则非常多，但都是向基本类型转换，所以理解<a href=\"#复杂类型转换成原始类型\">复杂类型转换成原始类型</a>比较重要，特别的还需要注意 {} 识别为一个 block 的情况。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2</a></li>\n<li><a href=\"https://www.zhihu.com/question/45478070\">https://www.zhihu.com/question/45478070</a></li>\n</ul>"},{"title":"Scroll 开发小记","date":"2022-09-11T14:32:31.000Z","_content":"\n> 背景：一次左滑加载更多的的交互开发\n\n## 填坑开始\n\n在最开始时，我得到了一个提示，左滑加载更多类似下拉刷新。想了想，好家伙，不就是把下拉刷新横过来嘛，碰巧下拉刷新还是前几天新增的一个组件，这回可以借鉴借鉴了 😍。OK 开干！\n\n<!-- more -->\n\n## 下拉刷新组件的设计\n\n在查看组件的源码后，发现下拉刷新组件的设计其实比较简单。这里使用了 @use-gesture/react 用在手势上的绑定，react-spring 用作动画的实现。下面就简单介绍下其设计思路。\n\n首先抛出几个问题\n\n- 什么时候触发刷新 或者什么时候调用手势？\n- scroll 容器滚动时与手势冲突。\n- 下拉的阈值、回弹动画\n1. 下拉刷新组件在设计时，采用的是浏览器原生滚动加上自定义用户手势事件。这样我们很容易判断什么时候触发手势事件了。其答案是：判断 dom 节点的 scrollTop，当 scrollTop 为 0 时，说明已经到顶了，然后在往下拉时，就开始触发手势，当手势下拉的距离超过某个阈值时，即变为了可刷新的状态，松手后，直接触发下拉回调。\n\n2. 从问题 1 的答案我们就可以很合理地规避原生滚动与手势下拉的冲突，及 scrollTop 不为 0 时，不会触发手势事件。\n\n3. 通过 use-gesture/react 中的 rubberbandIfOutOfBounds 函数创建一个弹簧效果，回弹动画呢，这个组件采用的是设置 loading 的 height 来实现，虽然可以，但我理解这种动态高度不是太适合这种滚动场景。因此后面经过各种实验（踩坑）后，丢弃了这种改变高度（宽度）的方式展示 loading。\n\n> 大概的一个框架图\n\n![img_1](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-01%2018.42.03.png)\n\n## 横滑实践\n横滑多简单呢，把竖着的横过来就是了 😊。哈哈，确实是这样的。\n\n### Version 1\n\n基本套路：\n- overflow：hidden\n- transform：translate3d\n基于以上套路，第一版没有采用浏览器的原生滚动，然后全程触发手势事件，通过手势事件控制 react-spring 的动画参数，实现模拟滚动。显然，模拟滚动的效果不是太好，其原因在于滚动速率变化、滚动惯性等比较难控制（实际原因：🥬 🐶）。\n下面来看一下初版效果:\n\n![img_2](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-01-2022%2019-11-16.gif)\n\n目测效果还行，但是在真机调试上就比较拉胯了，在真机上，实际移动的距离是手指一动的距离，所以是非常的慢并且每一次滚动的距离、速度这些比较受限。\n\n### Version 2\n\n参考 picker 组件，做一个滚动惯性。这种滚动对应的是每一次移动，终点位置都是一个整数位置（最终移动坐标是： index * itemWidth 或者 itemHeight）。\n\n### Version 3\n思路：原生滚动结合手势，这款设计比较合理，原生滚动改善了速度问题，横向长列表在滚动时，只有到滚动到最右边时才触发整体容器的移动，然后露出 load。\n注意：原生滚动采用 overflow：auto。在滚动到最右边时，触发手势，需要设置 overflow：hidden，不然就会发生滚动重叠（原生的在滚动、手势也在移动）。\n\n![img_3](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-02%2020.17.02.png)\n\n看似可用了，然而 ios 有个坑点，原生滚动具有惯性回弹，所以，当你拇指快速左滑时，会出现一个滚动回弹。这个回弹不会将 load 露出来，反而露出的是一个白底。\n\n## 能用待改善\n\n如标题所说，最终版只是一个能用的版本。各种原因，选择将 load 放在了原生 scroll 里面了（里外差别不大 😅）。\n\n![img_3](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-02-2022%2021-05-15.gif)\n\n待优化的点\n\n- 原生滚动不能有回弹效果，如果需要增加回弹效果，需要手动模拟滚动，然后再添加回弹。(ios特定的边界弹簧效果不能禁止)\n- 边界 drag 不流畅，有待改进。","source":"_posts/Scroll-开发小记.md","raw":"---\ntitle: Scroll 开发小记\ndate: 2022-09-11 22:32:31\ntags:\n---\n\n> 背景：一次左滑加载更多的的交互开发\n\n## 填坑开始\n\n在最开始时，我得到了一个提示，左滑加载更多类似下拉刷新。想了想，好家伙，不就是把下拉刷新横过来嘛，碰巧下拉刷新还是前几天新增的一个组件，这回可以借鉴借鉴了 😍。OK 开干！\n\n<!-- more -->\n\n## 下拉刷新组件的设计\n\n在查看组件的源码后，发现下拉刷新组件的设计其实比较简单。这里使用了 @use-gesture/react 用在手势上的绑定，react-spring 用作动画的实现。下面就简单介绍下其设计思路。\n\n首先抛出几个问题\n\n- 什么时候触发刷新 或者什么时候调用手势？\n- scroll 容器滚动时与手势冲突。\n- 下拉的阈值、回弹动画\n1. 下拉刷新组件在设计时，采用的是浏览器原生滚动加上自定义用户手势事件。这样我们很容易判断什么时候触发手势事件了。其答案是：判断 dom 节点的 scrollTop，当 scrollTop 为 0 时，说明已经到顶了，然后在往下拉时，就开始触发手势，当手势下拉的距离超过某个阈值时，即变为了可刷新的状态，松手后，直接触发下拉回调。\n\n2. 从问题 1 的答案我们就可以很合理地规避原生滚动与手势下拉的冲突，及 scrollTop 不为 0 时，不会触发手势事件。\n\n3. 通过 use-gesture/react 中的 rubberbandIfOutOfBounds 函数创建一个弹簧效果，回弹动画呢，这个组件采用的是设置 loading 的 height 来实现，虽然可以，但我理解这种动态高度不是太适合这种滚动场景。因此后面经过各种实验（踩坑）后，丢弃了这种改变高度（宽度）的方式展示 loading。\n\n> 大概的一个框架图\n\n![img_1](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-01%2018.42.03.png)\n\n## 横滑实践\n横滑多简单呢，把竖着的横过来就是了 😊。哈哈，确实是这样的。\n\n### Version 1\n\n基本套路：\n- overflow：hidden\n- transform：translate3d\n基于以上套路，第一版没有采用浏览器的原生滚动，然后全程触发手势事件，通过手势事件控制 react-spring 的动画参数，实现模拟滚动。显然，模拟滚动的效果不是太好，其原因在于滚动速率变化、滚动惯性等比较难控制（实际原因：🥬 🐶）。\n下面来看一下初版效果:\n\n![img_2](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-01-2022%2019-11-16.gif)\n\n目测效果还行，但是在真机调试上就比较拉胯了，在真机上，实际移动的距离是手指一动的距离，所以是非常的慢并且每一次滚动的距离、速度这些比较受限。\n\n### Version 2\n\n参考 picker 组件，做一个滚动惯性。这种滚动对应的是每一次移动，终点位置都是一个整数位置（最终移动坐标是： index * itemWidth 或者 itemHeight）。\n\n### Version 3\n思路：原生滚动结合手势，这款设计比较合理，原生滚动改善了速度问题，横向长列表在滚动时，只有到滚动到最右边时才触发整体容器的移动，然后露出 load。\n注意：原生滚动采用 overflow：auto。在滚动到最右边时，触发手势，需要设置 overflow：hidden，不然就会发生滚动重叠（原生的在滚动、手势也在移动）。\n\n![img_3](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-02%2020.17.02.png)\n\n看似可用了，然而 ios 有个坑点，原生滚动具有惯性回弹，所以，当你拇指快速左滑时，会出现一个滚动回弹。这个回弹不会将 load 露出来，反而露出的是一个白底。\n\n## 能用待改善\n\n如标题所说，最终版只是一个能用的版本。各种原因，选择将 load 放在了原生 scroll 里面了（里外差别不大 😅）。\n\n![img_3](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-02-2022%2021-05-15.gif)\n\n待优化的点\n\n- 原生滚动不能有回弹效果，如果需要增加回弹效果，需要手动模拟滚动，然后再添加回弹。(ios特定的边界弹簧效果不能禁止)\n- 边界 drag 不流畅，有待改进。","slug":"Scroll-开发小记","published":1,"updated":"2022-12-31T10:26:33.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzxi0008g8v76g9q2pq9","content":"<blockquote>\n<p>背景：一次左滑加载更多的的交互开发</p>\n</blockquote>\n<h2 id=\"填坑开始\"><a href=\"#填坑开始\" class=\"headerlink\" title=\"填坑开始\"></a>填坑开始</h2><p>在最开始时，我得到了一个提示，左滑加载更多类似下拉刷新。想了想，好家伙，不就是把下拉刷新横过来嘛，碰巧下拉刷新还是前几天新增的一个组件，这回可以借鉴借鉴了 😍。OK 开干！</p>\n<span id=\"more\"></span>\n\n<h2 id=\"下拉刷新组件的设计\"><a href=\"#下拉刷新组件的设计\" class=\"headerlink\" title=\"下拉刷新组件的设计\"></a>下拉刷新组件的设计</h2><p>在查看组件的源码后，发现下拉刷新组件的设计其实比较简单。这里使用了 @use-gesture/react 用在手势上的绑定，react-spring 用作动画的实现。下面就简单介绍下其设计思路。</p>\n<p>首先抛出几个问题</p>\n<ul>\n<li>什么时候触发刷新 或者什么时候调用手势？</li>\n<li>scroll 容器滚动时与手势冲突。</li>\n<li>下拉的阈值、回弹动画</li>\n</ul>\n<ol>\n<li><p>下拉刷新组件在设计时，采用的是浏览器原生滚动加上自定义用户手势事件。这样我们很容易判断什么时候触发手势事件了。其答案是：判断 dom 节点的 scrollTop，当 scrollTop 为 0 时，说明已经到顶了，然后在往下拉时，就开始触发手势，当手势下拉的距离超过某个阈值时，即变为了可刷新的状态，松手后，直接触发下拉回调。</p>\n</li>\n<li><p>从问题 1 的答案我们就可以很合理地规避原生滚动与手势下拉的冲突，及 scrollTop 不为 0 时，不会触发手势事件。</p>\n</li>\n<li><p>通过 use-gesture/react 中的 rubberbandIfOutOfBounds 函数创建一个弹簧效果，回弹动画呢，这个组件采用的是设置 loading 的 height 来实现，虽然可以，但我理解这种动态高度不是太适合这种滚动场景。因此后面经过各种实验（踩坑）后，丢弃了这种改变高度（宽度）的方式展示 loading。</p>\n</li>\n</ol>\n<blockquote>\n<p>大概的一个框架图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-01%2018.42.03.png\" alt=\"img_1\"></p>\n<h2 id=\"横滑实践\"><a href=\"#横滑实践\" class=\"headerlink\" title=\"横滑实践\"></a>横滑实践</h2><p>横滑多简单呢，把竖着的横过来就是了 😊。哈哈，确实是这样的。</p>\n<h3 id=\"Version-1\"><a href=\"#Version-1\" class=\"headerlink\" title=\"Version 1\"></a>Version 1</h3><p>基本套路：</p>\n<ul>\n<li>overflow：hidden</li>\n<li>transform：translate3d<br>基于以上套路，第一版没有采用浏览器的原生滚动，然后全程触发手势事件，通过手势事件控制 react-spring 的动画参数，实现模拟滚动。显然，模拟滚动的效果不是太好，其原因在于滚动速率变化、滚动惯性等比较难控制（实际原因：🥬 🐶）。<br>下面来看一下初版效果:</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-01-2022%2019-11-16.gif\" alt=\"img_2\"></p>\n<p>目测效果还行，但是在真机调试上就比较拉胯了，在真机上，实际移动的距离是手指一动的距离，所以是非常的慢并且每一次滚动的距离、速度这些比较受限。</p>\n<h3 id=\"Version-2\"><a href=\"#Version-2\" class=\"headerlink\" title=\"Version 2\"></a>Version 2</h3><p>参考 picker 组件，做一个滚动惯性。这种滚动对应的是每一次移动，终点位置都是一个整数位置（最终移动坐标是： index * itemWidth 或者 itemHeight）。</p>\n<h3 id=\"Version-3\"><a href=\"#Version-3\" class=\"headerlink\" title=\"Version 3\"></a>Version 3</h3><p>思路：原生滚动结合手势，这款设计比较合理，原生滚动改善了速度问题，横向长列表在滚动时，只有到滚动到最右边时才触发整体容器的移动，然后露出 load。<br>注意：原生滚动采用 overflow：auto。在滚动到最右边时，触发手势，需要设置 overflow：hidden，不然就会发生滚动重叠（原生的在滚动、手势也在移动）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-02%2020.17.02.png\" alt=\"img_3\"></p>\n<p>看似可用了，然而 ios 有个坑点，原生滚动具有惯性回弹，所以，当你拇指快速左滑时，会出现一个滚动回弹。这个回弹不会将 load 露出来，反而露出的是一个白底。</p>\n<h2 id=\"能用待改善\"><a href=\"#能用待改善\" class=\"headerlink\" title=\"能用待改善\"></a>能用待改善</h2><p>如标题所说，最终版只是一个能用的版本。各种原因，选择将 load 放在了原生 scroll 里面了（里外差别不大 😅）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-02-2022%2021-05-15.gif\" alt=\"img_3\"></p>\n<p>待优化的点</p>\n<ul>\n<li>原生滚动不能有回弹效果，如果需要增加回弹效果，需要手动模拟滚动，然后再添加回弹。(ios特定的边界弹簧效果不能禁止)</li>\n<li>边界 drag 不流畅，有待改进。</li>\n</ul>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":1390,"excerpt":"<blockquote>\n<p>背景：一次左滑加载更多的的交互开发</p>\n</blockquote>\n<h2 id=\"填坑开始\"><a href=\"#填坑开始\" class=\"headerlink\" title=\"填坑开始\"></a>填坑开始</h2><p>在最开始时，我得到了一个提示，左滑加载更多类似下拉刷新。想了想，好家伙，不就是把下拉刷新横过来嘛，碰巧下拉刷新还是前几天新增的一个组件，这回可以借鉴借鉴了 😍。OK 开干！</p>","more":"<h2 id=\"下拉刷新组件的设计\"><a href=\"#下拉刷新组件的设计\" class=\"headerlink\" title=\"下拉刷新组件的设计\"></a>下拉刷新组件的设计</h2><p>在查看组件的源码后，发现下拉刷新组件的设计其实比较简单。这里使用了 @use-gesture/react 用在手势上的绑定，react-spring 用作动画的实现。下面就简单介绍下其设计思路。</p>\n<p>首先抛出几个问题</p>\n<ul>\n<li>什么时候触发刷新 或者什么时候调用手势？</li>\n<li>scroll 容器滚动时与手势冲突。</li>\n<li>下拉的阈值、回弹动画</li>\n</ul>\n<ol>\n<li><p>下拉刷新组件在设计时，采用的是浏览器原生滚动加上自定义用户手势事件。这样我们很容易判断什么时候触发手势事件了。其答案是：判断 dom 节点的 scrollTop，当 scrollTop 为 0 时，说明已经到顶了，然后在往下拉时，就开始触发手势，当手势下拉的距离超过某个阈值时，即变为了可刷新的状态，松手后，直接触发下拉回调。</p>\n</li>\n<li><p>从问题 1 的答案我们就可以很合理地规避原生滚动与手势下拉的冲突，及 scrollTop 不为 0 时，不会触发手势事件。</p>\n</li>\n<li><p>通过 use-gesture/react 中的 rubberbandIfOutOfBounds 函数创建一个弹簧效果，回弹动画呢，这个组件采用的是设置 loading 的 height 来实现，虽然可以，但我理解这种动态高度不是太适合这种滚动场景。因此后面经过各种实验（踩坑）后，丢弃了这种改变高度（宽度）的方式展示 loading。</p>\n</li>\n</ol>\n<blockquote>\n<p>大概的一个框架图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-01%2018.42.03.png\" alt=\"img_1\"></p>\n<h2 id=\"横滑实践\"><a href=\"#横滑实践\" class=\"headerlink\" title=\"横滑实践\"></a>横滑实践</h2><p>横滑多简单呢，把竖着的横过来就是了 😊。哈哈，确实是这样的。</p>\n<h3 id=\"Version-1\"><a href=\"#Version-1\" class=\"headerlink\" title=\"Version 1\"></a>Version 1</h3><p>基本套路：</p>\n<ul>\n<li>overflow：hidden</li>\n<li>transform：translate3d<br>基于以上套路，第一版没有采用浏览器的原生滚动，然后全程触发手势事件，通过手势事件控制 react-spring 的动画参数，实现模拟滚动。显然，模拟滚动的效果不是太好，其原因在于滚动速率变化、滚动惯性等比较难控制（实际原因：🥬 🐶）。<br>下面来看一下初版效果:</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-01-2022%2019-11-16.gif\" alt=\"img_2\"></p>\n<p>目测效果还行，但是在真机调试上就比较拉胯了，在真机上，实际移动的距离是手指一动的距离，所以是非常的慢并且每一次滚动的距离、速度这些比较受限。</p>\n<h3 id=\"Version-2\"><a href=\"#Version-2\" class=\"headerlink\" title=\"Version 2\"></a>Version 2</h3><p>参考 picker 组件，做一个滚动惯性。这种滚动对应的是每一次移动，终点位置都是一个整数位置（最终移动坐标是： index * itemWidth 或者 itemHeight）。</p>\n<h3 id=\"Version-3\"><a href=\"#Version-3\" class=\"headerlink\" title=\"Version 3\"></a>Version 3</h3><p>思路：原生滚动结合手势，这款设计比较合理，原生滚动改善了速度问题，横向长列表在滚动时，只有到滚动到最右边时才触发整体容器的移动，然后露出 load。<br>注意：原生滚动采用 overflow：auto。在滚动到最右边时，触发手势，需要设置 overflow：hidden，不然就会发生滚动重叠（原生的在滚动、手势也在移动）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-02%2020.17.02.png\" alt=\"img_3\"></p>\n<p>看似可用了，然而 ios 有个坑点，原生滚动具有惯性回弹，所以，当你拇指快速左滑时，会出现一个滚动回弹。这个回弹不会将 load 露出来，反而露出的是一个白底。</p>\n<h2 id=\"能用待改善\"><a href=\"#能用待改善\" class=\"headerlink\" title=\"能用待改善\"></a>能用待改善</h2><p>如标题所说，最终版只是一个能用的版本。各种原因，选择将 load 放在了原生 scroll 里面了（里外差别不大 😅）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-02-2022%2021-05-15.gif\" alt=\"img_3\"></p>\n<p>待优化的点</p>\n<ul>\n<li>原生滚动不能有回弹效果，如果需要增加回弹效果，需要手动模拟滚动，然后再添加回弹。(ios特定的边界弹簧效果不能禁止)</li>\n<li>边界 drag 不流畅，有待改进。</li>\n</ul>"},{"title":"使用github actions进行轻服务的页面部署","date":"2021-10-22T02:22:14.000Z","_content":"\n# 使用 github actions 进行[轻服务](https://qingfuwu.cn/)的页面托管\n\n### 首先，轻服务官方文档给出了手动部署页面的教程[页面托管](https://qingfuwu.cn/docs/openapi/sdk/hosting.html#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1%E4%BF%A1%E6%81%AF)。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。\n\n[看看效果](https://qcjtoy.web.cloudendpoint.cn/)\n\n### 1.github 创建仓库，配置.github/workflow/\\*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.\n\n- #### 配置 workflow 的 yml 文件。\n  直接复制里面的 Usage,[Deploy to ByteInspire Hosting](https://github.com/marketplace/actions/deploy-to-byteinspire-hosting)\n\n```yaml\nname: Deploy Hosting\n\non: push\n\njobs:\n  build_and_deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      # Add any build steps here. For example:\n      # - run: npm ci && npm run build\n      - uses: byteinspire/hosting-deployer-action@v1\n        with:\n          service-id: \"${{ secrets.SERVICE_ID }}\"\n          token: \"${{ secrets.ACCESS_TOKEN }}\"\n          # Or you can use file param to directly specify the ziped file path\n          directory: ./\n```\n\n<!-- more -->\n\n- #### 配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID\n\n1. ACCESS_TOKEN\n   官方已经写得很详细了[创建和管理访问凭证](https://qingfuwu.cn/docs/openapi/personaltoken.html#%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E5%87%AD%E8%AF%81)\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221004.png)\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221006.png)\n2. SERVICE_ID\n   登录轻服务后[https://qingfuwu.cn/dashboard](https://qingfuwu.cn/dashboard)，在首页就能看见你创建的所有服务。\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220950.png)\n   这里就选择 hello world 这个服务，点击进去，再进入到设置里面就可以看见 SERVICE_ID.当然这里你也可以直接点击页面托管，上传压缩文件手动部署。![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220952.png)\n3. 添加变量到 secrets 里面，这里我已经添加上了。这里要注意的是设置 respository secret，因为最开始设置成 environment secret 而失败几次 😭\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220955.png)\n\n### 2. 经过上面的步骤，大致就可以完成了。\n\n#####看看 actions 吧，忽略前几次 environment secret 的锅 😂\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221013.png)\n进入页面托管，点击网站域名，就可以看见部署后的页面了。\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221016.png)\n最终效果：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221025.png)\n","source":"_posts/actions进行轻服务的页面部署.md","raw":"---\ntitle: 使用github actions进行轻服务的页面部署\ndate: 2021-10-22 10:22:14\ntags: deploy qingfuwu\n---\n\n# 使用 github actions 进行[轻服务](https://qingfuwu.cn/)的页面托管\n\n### 首先，轻服务官方文档给出了手动部署页面的教程[页面托管](https://qingfuwu.cn/docs/openapi/sdk/hosting.html#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1%E4%BF%A1%E6%81%AF)。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。\n\n[看看效果](https://qcjtoy.web.cloudendpoint.cn/)\n\n### 1.github 创建仓库，配置.github/workflow/\\*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.\n\n- #### 配置 workflow 的 yml 文件。\n  直接复制里面的 Usage,[Deploy to ByteInspire Hosting](https://github.com/marketplace/actions/deploy-to-byteinspire-hosting)\n\n```yaml\nname: Deploy Hosting\n\non: push\n\njobs:\n  build_and_deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      # Add any build steps here. For example:\n      # - run: npm ci && npm run build\n      - uses: byteinspire/hosting-deployer-action@v1\n        with:\n          service-id: \"${{ secrets.SERVICE_ID }}\"\n          token: \"${{ secrets.ACCESS_TOKEN }}\"\n          # Or you can use file param to directly specify the ziped file path\n          directory: ./\n```\n\n<!-- more -->\n\n- #### 配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID\n\n1. ACCESS_TOKEN\n   官方已经写得很详细了[创建和管理访问凭证](https://qingfuwu.cn/docs/openapi/personaltoken.html#%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E5%87%AD%E8%AF%81)\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221004.png)\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221006.png)\n2. SERVICE_ID\n   登录轻服务后[https://qingfuwu.cn/dashboard](https://qingfuwu.cn/dashboard)，在首页就能看见你创建的所有服务。\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220950.png)\n   这里就选择 hello world 这个服务，点击进去，再进入到设置里面就可以看见 SERVICE_ID.当然这里你也可以直接点击页面托管，上传压缩文件手动部署。![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220952.png)\n3. 添加变量到 secrets 里面，这里我已经添加上了。这里要注意的是设置 respository secret，因为最开始设置成 environment secret 而失败几次 😭\n   ![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220955.png)\n\n### 2. 经过上面的步骤，大致就可以完成了。\n\n#####看看 actions 吧，忽略前几次 environment secret 的锅 😂\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221013.png)\n进入页面托管，点击网站域名，就可以看见部署后的页面了。\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221016.png)\n最终效果：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221025.png)\n","slug":"actions进行轻服务的页面部署","published":1,"updated":"2022-12-31T10:26:33.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzxl000ag8v78ltt6vb2","content":"<h1 id=\"使用-github-actions-进行轻服务的页面托管\"><a href=\"#使用-github-actions-进行轻服务的页面托管\" class=\"headerlink\" title=\"使用 github actions 进行轻服务的页面托管\"></a>使用 github actions 进行<a href=\"https://qingfuwu.cn/\">轻服务</a>的页面托管</h1><h3 id=\"首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用-github-actions-的自动部署。只要会一点-github-actions-实现起来也比较简单。\"><a href=\"#首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用-github-actions-的自动部署。只要会一点-github-actions-实现起来也比较简单。\" class=\"headerlink\" title=\"首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。\"></a>首先，轻服务官方文档给出了手动部署页面的教程<a href=\"https://qingfuwu.cn/docs/openapi/sdk/hosting.html#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1%E4%BF%A1%E6%81%AF\">页面托管</a>。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。</h3><p><a href=\"https://qcjtoy.web.cloudendpoint.cn/\">看看效果</a></p>\n<h3 id=\"1-github-创建仓库，配置-github-workflow-yml-同时设置-secrets-变量-ACCESS-TOKEN-与-SERVICE-ID\"><a href=\"#1-github-创建仓库，配置-github-workflow-yml-同时设置-secrets-变量-ACCESS-TOKEN-与-SERVICE-ID\" class=\"headerlink\" title=\"1.github 创建仓库，配置.github/workflow/*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.\"></a>1.github 创建仓库，配置.github/workflow/*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.</h3><ul>\n<li><h4 id=\"配置-workflow-的-yml-文件。\"><a href=\"#配置-workflow-的-yml-文件。\" class=\"headerlink\" title=\"配置 workflow 的 yml 文件。\"></a>配置 workflow 的 yml 文件。</h4>直接复制里面的 Usage,<a href=\"https://github.com/marketplace/actions/deploy-to-byteinspire-hosting\">Deploy to ByteInspire Hosting</a></li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">Hosting</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span> <span class=\"string\">push</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build_and_deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2</span></span><br><span class=\"line\">      <span class=\"comment\"># Add any build steps here. For example:</span></span><br><span class=\"line\">      <span class=\"comment\"># - run: npm ci &amp;&amp; npm run build</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">byteinspire/hosting-deployer-action@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">service-id:</span> <span class=\"string\">&quot;$<span class=\"template-variable\">&#123;&#123; secrets.SERVICE_ID &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">token:</span> <span class=\"string\">&quot;$<span class=\"template-variable\">&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">          <span class=\"comment\"># Or you can use file param to directly specify the ziped file path</span></span><br><span class=\"line\">          <span class=\"attr\">directory:</span> <span class=\"string\">./</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<ul>\n<li><h4 id=\"配置-secrets-的变量-ACCESS-TOKEN-与-SERVICE-ID\"><a href=\"#配置-secrets-的变量-ACCESS-TOKEN-与-SERVICE-ID\" class=\"headerlink\" title=\"配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID\"></a>配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID</h4></li>\n</ul>\n<ol>\n<li>ACCESS_TOKEN<br>官方已经写得很详细了<a href=\"https://qingfuwu.cn/docs/openapi/personaltoken.html#%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E5%87%AD%E8%AF%81\">创建和管理访问凭证</a><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221004.png\"><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221006.png\"></li>\n<li>SERVICE_ID<br>登录轻服务后<a href=\"https://qingfuwu.cn/dashboard\">https://qingfuwu.cn/dashboard</a>，在首页就能看见你创建的所有服务。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220950.png\"><br>这里就选择 hello world 这个服务，点击进去，再进入到设置里面就可以看见 SERVICE_ID.当然这里你也可以直接点击页面托管，上传压缩文件手动部署。<img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220952.png\"></li>\n<li>添加变量到 secrets 里面，这里我已经添加上了。这里要注意的是设置 respository secret，因为最开始设置成 environment secret 而失败几次 😭<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220955.png\"></li>\n</ol>\n<h3 id=\"2-经过上面的步骤，大致就可以完成了。\"><a href=\"#2-经过上面的步骤，大致就可以完成了。\" class=\"headerlink\" title=\"2. 经过上面的步骤，大致就可以完成了。\"></a>2. 经过上面的步骤，大致就可以完成了。</h3><p>#####看看 actions 吧，忽略前几次 environment secret 的锅 😂<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221013.png\"><br>进入页面托管，点击网站域名，就可以看见部署后的页面了。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221016.png\"><br>最终效果：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221025.png\"></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":1064,"excerpt":"<h1 id=\"使用-github-actions-进行轻服务的页面托管\"><a href=\"#使用-github-actions-进行轻服务的页面托管\" class=\"headerlink\" title=\"使用 github actions 进行轻服务的页面托管\"></a>使用 github actions 进行<a href=\"https://qingfuwu.cn/\">轻服务</a>的页面托管</h1><h3 id=\"首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用-github-actions-的自动部署。只要会一点-github-actions-实现起来也比较简单。\"><a href=\"#首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用-github-actions-的自动部署。只要会一点-github-actions-实现起来也比较简单。\" class=\"headerlink\" title=\"首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。\"></a>首先，轻服务官方文档给出了手动部署页面的教程<a href=\"https://qingfuwu.cn/docs/openapi/sdk/hosting.html#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1%E4%BF%A1%E6%81%AF\">页面托管</a>。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。</h3><p><a href=\"https://qcjtoy.web.cloudendpoint.cn/\">看看效果</a></p>\n<h3 id=\"1-github-创建仓库，配置-github-workflow-yml-同时设置-secrets-变量-ACCESS-TOKEN-与-SERVICE-ID\"><a href=\"#1-github-创建仓库，配置-github-workflow-yml-同时设置-secrets-变量-ACCESS-TOKEN-与-SERVICE-ID\" class=\"headerlink\" title=\"1.github 创建仓库，配置.github/workflow/*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.\"></a>1.github 创建仓库，配置.github/workflow/*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.</h3><ul>\n<li><h4 id=\"配置-workflow-的-yml-文件。\"><a href=\"#配置-workflow-的-yml-文件。\" class=\"headerlink\" title=\"配置 workflow 的 yml 文件。\"></a>配置 workflow 的 yml 文件。</h4>直接复制里面的 Usage,<a href=\"https://github.com/marketplace/actions/deploy-to-byteinspire-hosting\">Deploy to ByteInspire Hosting</a></li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">Hosting</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span> <span class=\"string\">push</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build_and_deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2</span></span><br><span class=\"line\">      <span class=\"comment\"># Add any build steps here. For example:</span></span><br><span class=\"line\">      <span class=\"comment\"># - run: npm ci &amp;&amp; npm run build</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">byteinspire/hosting-deployer-action@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">service-id:</span> <span class=\"string\">&quot;$<span class=\"template-variable\">&#123;&#123; secrets.SERVICE_ID &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">token:</span> <span class=\"string\">&quot;$<span class=\"template-variable\">&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">          <span class=\"comment\"># Or you can use file param to directly specify the ziped file path</span></span><br><span class=\"line\">          <span class=\"attr\">directory:</span> <span class=\"string\">./</span></span><br></pre></td></tr></table></figure>","more":"<ul>\n<li><h4 id=\"配置-secrets-的变量-ACCESS-TOKEN-与-SERVICE-ID\"><a href=\"#配置-secrets-的变量-ACCESS-TOKEN-与-SERVICE-ID\" class=\"headerlink\" title=\"配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID\"></a>配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID</h4></li>\n</ul>\n<ol>\n<li>ACCESS_TOKEN<br>官方已经写得很详细了<a href=\"https://qingfuwu.cn/docs/openapi/personaltoken.html#%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E5%87%AD%E8%AF%81\">创建和管理访问凭证</a><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221004.png\"><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221006.png\"></li>\n<li>SERVICE_ID<br>登录轻服务后<a href=\"https://qingfuwu.cn/dashboard\">https://qingfuwu.cn/dashboard</a>，在首页就能看见你创建的所有服务。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220950.png\"><br>这里就选择 hello world 这个服务，点击进去，再进入到设置里面就可以看见 SERVICE_ID.当然这里你也可以直接点击页面托管，上传压缩文件手动部署。<img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220952.png\"></li>\n<li>添加变量到 secrets 里面，这里我已经添加上了。这里要注意的是设置 respository secret，因为最开始设置成 environment secret 而失败几次 😭<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220955.png\"></li>\n</ol>\n<h3 id=\"2-经过上面的步骤，大致就可以完成了。\"><a href=\"#2-经过上面的步骤，大致就可以完成了。\" class=\"headerlink\" title=\"2. 经过上面的步骤，大致就可以完成了。\"></a>2. 经过上面的步骤，大致就可以完成了。</h3><p>#####看看 actions 吧，忽略前几次 environment secret 的锅 😂<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221013.png\"><br>进入页面托管，点击网站域名，就可以看见部署后的页面了。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221016.png\"><br>最终效果：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221025.png\"></p>"},{"title":"Hello World","date":"2021-07-20T16:00:00.000Z","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2021-07-21\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2022-12-31T10:26:33.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyg000jg8v78f4617d8","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":367,"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"numpy条件选择","date":"2021-10-12T16:38:35.000Z","_content":"\n## numpy 的条件筛选\n\n### 筛选基础\n\n#### 数组切片\n\n我们一般都知道 python 的 [ ] 操作符可以进行切片操作,举例如下:\n\n```python\narr = [1,2,3]\n#切片操作参数介绍：[起始位置下标（默认最开始）:结束位置下标(默认最后):步长(默认为一)]\narr[0:2]\n# [1,2]\n\narr[0:2:2]\n# [1,3]\n\n# 当步长为-1时，能够逆置数组\narr[::-1]\n# [3,2,1]\n```\n\n<!--more-->\n\n#### 下面是 ndarray 二维数组的例子\n\n##### 单列/行筛选\n\n```python\narr = [\n[1,2,3,4],\n[4,5,6,7]\n]\narr = np.array(arr)\n# 单列筛选\n# 列筛选，第一个冒号不能省略\narr[:,0] # 选择下标为0的列\n# [1,4]\n\n# 单行筛选\narr[0] # 选择下标为0的行，就像普通的二维数组访问第一个一维数组一样\n# [1,2,3,4]\n```\n\n##### 多行/列筛选\n\n```python\narr = [\n[1,2,3,4],\n[4,5,6,7]\n]\narr = np.array(arr)\n# 多列筛选\n\t# 选择某个下标区间的列\narr[:,0:2]\n# [\n# [1,2],\n# [4,5]\n# ]\n\t# 选择某些列\narr[:,[0,3]] # 选择下标为 0，3的列\n# [\n# [1,4],\n# [4,7]\n# ]\n\t# bool选择\n\t# bool数组的  长度  必须要与列的  维数相同\narr[:,[True,False,False,False]]\n# [\n# [1],\n# [4]\n# ]\n\n# 多行筛选\n# 与多列筛选类似\narr = np.array([\n[1,2,3,4],\n[4,5,6,7],\n[8,9,10,11]\n])\n\t# 选择某些行\narr[[0,1]]\n# [[\n# [1,2,3,4],\n# [4,5,6,7]\n# ]]\n\t# 其余就不在赘述，可以字行测试\n```\n\n### 条件筛选\n\n通过上面的一些基本的筛选规则，可以大致了解了 numpy 的筛选原则了，那么下面就看一 numpy 比较强大的条件筛选吧。而条件筛选就是依赖 bool 筛选实现的。\n\n#### 条件筛选行\n\n```python\narr = np.array([\n[1,2,3,4],\n[4,5,6,7],\n[8,9,10,11]\n])\n\n# 例如：选择第一个元素为偶数的行\narr[arr[:,0]%2==0]\n# [[ 4,  5,  6,  7],\n#  [ 8,  9, 10, 11]]\n```\n\n我们可以看一下上面发生了什么。\n首先: arr[:,0]x 选择除了二维数组的第一列-----[1,4,8]\n然后: arr[:,0]%2==0 得到了一个 bool 数组-----[False,True,True]\n最后 arr[[False,True,True]],这个样子是不是有点熟悉了，也就是上面的 bool 筛选。\n\n#### 条件筛选列\n\n```python\n# 与行筛选类似\narr[:,arr[1]>5] # 选择第二行中大于5的列\n# [[ 3,  4],\n#  [ 6,  7],\n#  [10, 11]]\n```\n\n#### 行列一起选择\n\n```python\narr[arr>5] # 选择arr中，大于5的元素\n# 其中arr>5得到一个二维的bool数组\n# [[False, False, False, False],\n#  [False, False,  True,  True],\n#  [ True,  True,  True,  True]]\n# 最终结果是一个一维数组\n# [ 6,  7,  8,  9, 10, 11]\n```\n\n##### 注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr>5 就会出现错误。\n\n#### 多条件选择\n\n```python\narr[(arr>5) & (arr%2==0)] # 选择大于5且为偶数的元素\n# [ 6,  8, 10]\n```\n\n##### 注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &，不能用 and,or 这样。\n","source":"_posts/numpy条件选择.md","raw":"---\ntitle: numpy条件选择\ndate: 2021-10-13 00:38:35\ntags: numpy\ncategories: python\n---\n\n## numpy 的条件筛选\n\n### 筛选基础\n\n#### 数组切片\n\n我们一般都知道 python 的 [ ] 操作符可以进行切片操作,举例如下:\n\n```python\narr = [1,2,3]\n#切片操作参数介绍：[起始位置下标（默认最开始）:结束位置下标(默认最后):步长(默认为一)]\narr[0:2]\n# [1,2]\n\narr[0:2:2]\n# [1,3]\n\n# 当步长为-1时，能够逆置数组\narr[::-1]\n# [3,2,1]\n```\n\n<!--more-->\n\n#### 下面是 ndarray 二维数组的例子\n\n##### 单列/行筛选\n\n```python\narr = [\n[1,2,3,4],\n[4,5,6,7]\n]\narr = np.array(arr)\n# 单列筛选\n# 列筛选，第一个冒号不能省略\narr[:,0] # 选择下标为0的列\n# [1,4]\n\n# 单行筛选\narr[0] # 选择下标为0的行，就像普通的二维数组访问第一个一维数组一样\n# [1,2,3,4]\n```\n\n##### 多行/列筛选\n\n```python\narr = [\n[1,2,3,4],\n[4,5,6,7]\n]\narr = np.array(arr)\n# 多列筛选\n\t# 选择某个下标区间的列\narr[:,0:2]\n# [\n# [1,2],\n# [4,5]\n# ]\n\t# 选择某些列\narr[:,[0,3]] # 选择下标为 0，3的列\n# [\n# [1,4],\n# [4,7]\n# ]\n\t# bool选择\n\t# bool数组的  长度  必须要与列的  维数相同\narr[:,[True,False,False,False]]\n# [\n# [1],\n# [4]\n# ]\n\n# 多行筛选\n# 与多列筛选类似\narr = np.array([\n[1,2,3,4],\n[4,5,6,7],\n[8,9,10,11]\n])\n\t# 选择某些行\narr[[0,1]]\n# [[\n# [1,2,3,4],\n# [4,5,6,7]\n# ]]\n\t# 其余就不在赘述，可以字行测试\n```\n\n### 条件筛选\n\n通过上面的一些基本的筛选规则，可以大致了解了 numpy 的筛选原则了，那么下面就看一 numpy 比较强大的条件筛选吧。而条件筛选就是依赖 bool 筛选实现的。\n\n#### 条件筛选行\n\n```python\narr = np.array([\n[1,2,3,4],\n[4,5,6,7],\n[8,9,10,11]\n])\n\n# 例如：选择第一个元素为偶数的行\narr[arr[:,0]%2==0]\n# [[ 4,  5,  6,  7],\n#  [ 8,  9, 10, 11]]\n```\n\n我们可以看一下上面发生了什么。\n首先: arr[:,0]x 选择除了二维数组的第一列-----[1,4,8]\n然后: arr[:,0]%2==0 得到了一个 bool 数组-----[False,True,True]\n最后 arr[[False,True,True]],这个样子是不是有点熟悉了，也就是上面的 bool 筛选。\n\n#### 条件筛选列\n\n```python\n# 与行筛选类似\narr[:,arr[1]>5] # 选择第二行中大于5的列\n# [[ 3,  4],\n#  [ 6,  7],\n#  [10, 11]]\n```\n\n#### 行列一起选择\n\n```python\narr[arr>5] # 选择arr中，大于5的元素\n# 其中arr>5得到一个二维的bool数组\n# [[False, False, False, False],\n#  [False, False,  True,  True],\n#  [ True,  True,  True,  True]]\n# 最终结果是一个一维数组\n# [ 6,  7,  8,  9, 10, 11]\n```\n\n##### 注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr>5 就会出现错误。\n\n#### 多条件选择\n\n```python\narr[(arr>5) & (arr%2==0)] # 选择大于5且为偶数的元素\n# [ 6,  8, 10]\n```\n\n##### 注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &，不能用 and,or 这样。\n","slug":"numpy条件选择","published":1,"updated":"2022-12-31T10:26:33.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyh000kg8v736633x2q","content":"<h2 id=\"numpy-的条件筛选\"><a href=\"#numpy-的条件筛选\" class=\"headerlink\" title=\"numpy 的条件筛选\"></a>numpy 的条件筛选</h2><h3 id=\"筛选基础\"><a href=\"#筛选基础\" class=\"headerlink\" title=\"筛选基础\"></a>筛选基础</h3><h4 id=\"数组切片\"><a href=\"#数组切片\" class=\"headerlink\" title=\"数组切片\"></a>数组切片</h4><p>我们一般都知道 python 的 [ ] 操作符可以进行切片操作,举例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"comment\">#切片操作参数介绍：[起始位置下标（默认最开始）:结束位置下标(默认最后):步长(默认为一)]</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># [1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>:<span class=\"number\">2</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># [1,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当步长为-1时，能够逆置数组</span></span><br><span class=\"line\">arr[::-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\"># [3,2,1]</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h4 id=\"下面是-ndarray-二维数组的例子\"><a href=\"#下面是-ndarray-二维数组的例子\" class=\"headerlink\" title=\"下面是 ndarray 二维数组的例子\"></a>下面是 ndarray 二维数组的例子</h4><h5 id=\"单列-行筛选\"><a href=\"#单列-行筛选\" class=\"headerlink\" title=\"单列/行筛选\"></a>单列/行筛选</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">arr = np.array(arr)</span><br><span class=\"line\"><span class=\"comment\"># 单列筛选</span></span><br><span class=\"line\"><span class=\"comment\"># 列筛选，第一个冒号不能省略</span></span><br><span class=\"line\">arr[:,<span class=\"number\">0</span>] <span class=\"comment\"># 选择下标为0的列</span></span><br><span class=\"line\"><span class=\"comment\"># [1,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单行筛选</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] <span class=\"comment\"># 选择下标为0的行，就像普通的二维数组访问第一个一维数组一样</span></span><br><span class=\"line\"><span class=\"comment\"># [1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"多行-列筛选\"><a href=\"#多行-列筛选\" class=\"headerlink\" title=\"多行/列筛选\"></a>多行/列筛选</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">arr = np.array(arr)</span><br><span class=\"line\"><span class=\"comment\"># 多列筛选</span></span><br><span class=\"line\">\t<span class=\"comment\"># 选择某个下标区间的列</span></span><br><span class=\"line\">arr[:,<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\"># [1,2],</span></span><br><span class=\"line\"><span class=\"comment\"># [4,5]</span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\">\t<span class=\"comment\"># 选择某些列</span></span><br><span class=\"line\">arr[:,[<span class=\"number\">0</span>,<span class=\"number\">3</span>]] <span class=\"comment\"># 选择下标为 0，3的列</span></span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\"># [1,4],</span></span><br><span class=\"line\"><span class=\"comment\"># [4,7]</span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\">\t<span class=\"comment\"># bool选择</span></span><br><span class=\"line\">\t<span class=\"comment\"># bool数组的  长度  必须要与列的  维数相同</span></span><br><span class=\"line\">arr[:,[<span class=\"literal\">True</span>,<span class=\"literal\">False</span>,<span class=\"literal\">False</span>,<span class=\"literal\">False</span>]]</span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\"># [1],</span></span><br><span class=\"line\"><span class=\"comment\"># [4]</span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多行筛选</span></span><br><span class=\"line\"><span class=\"comment\"># 与多列筛选类似</span></span><br><span class=\"line\">arr = np.array([</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">[<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\">\t<span class=\"comment\"># 选择某些行</span></span><br><span class=\"line\">arr[[<span class=\"number\">0</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"comment\"># [[</span></span><br><span class=\"line\"><span class=\"comment\"># [1,2,3,4],</span></span><br><span class=\"line\"><span class=\"comment\"># [4,5,6,7]</span></span><br><span class=\"line\"><span class=\"comment\"># ]]</span></span><br><span class=\"line\">\t<span class=\"comment\"># 其余就不在赘述，可以字行测试</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件筛选\"><a href=\"#条件筛选\" class=\"headerlink\" title=\"条件筛选\"></a>条件筛选</h3><p>通过上面的一些基本的筛选规则，可以大致了解了 numpy 的筛选原则了，那么下面就看一 numpy 比较强大的条件筛选吧。而条件筛选就是依赖 bool 筛选实现的。</p>\n<h4 id=\"条件筛选行\"><a href=\"#条件筛选行\" class=\"headerlink\" title=\"条件筛选行\"></a>条件筛选行</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = np.array([</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">[<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如：选择第一个元素为偶数的行</span></span><br><span class=\"line\">arr[arr[:,<span class=\"number\">0</span>]%<span class=\"number\">2</span>==<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># [[ 4,  5,  6,  7],</span></span><br><span class=\"line\"><span class=\"comment\">#  [ 8,  9, 10, 11]]</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看一下上面发生了什么。<br>首先: arr[:,0]x 选择除了二维数组的第一列—–[1,4,8]<br>然后: arr[:,0]%2==0 得到了一个 bool 数组—–[False,True,True]<br>最后 arr[[False,True,True]],这个样子是不是有点熟悉了，也就是上面的 bool 筛选。</p>\n<h4 id=\"条件筛选列\"><a href=\"#条件筛选列\" class=\"headerlink\" title=\"条件筛选列\"></a>条件筛选列</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与行筛选类似</span></span><br><span class=\"line\">arr[:,arr[<span class=\"number\">1</span>]&gt;<span class=\"number\">5</span>] <span class=\"comment\"># 选择第二行中大于5的列</span></span><br><span class=\"line\"><span class=\"comment\"># [[ 3,  4],</span></span><br><span class=\"line\"><span class=\"comment\">#  [ 6,  7],</span></span><br><span class=\"line\"><span class=\"comment\">#  [10, 11]]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"行列一起选择\"><a href=\"#行列一起选择\" class=\"headerlink\" title=\"行列一起选择\"></a>行列一起选择</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[arr&gt;<span class=\"number\">5</span>] <span class=\"comment\"># 选择arr中，大于5的元素</span></span><br><span class=\"line\"><span class=\"comment\"># 其中arr&gt;5得到一个二维的bool数组</span></span><br><span class=\"line\"><span class=\"comment\"># [[False, False, False, False],</span></span><br><span class=\"line\"><span class=\"comment\">#  [False, False,  True,  True],</span></span><br><span class=\"line\"><span class=\"comment\">#  [ True,  True,  True,  True]]</span></span><br><span class=\"line\"><span class=\"comment\"># 最终结果是一个一维数组</span></span><br><span class=\"line\"><span class=\"comment\"># [ 6,  7,  8,  9, 10, 11]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列-int，第二列是-str，这样再用-arr-gt-5-就会出现错误。\"><a href=\"#注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列-int，第二列是-str，这样再用-arr-gt-5-就会出现错误。\" class=\"headerlink\" title=\"注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr&gt;5 就会出现错误。\"></a>注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr&gt;5 就会出现错误。</h5><h4 id=\"多条件选择\"><a href=\"#多条件选择\" class=\"headerlink\" title=\"多条件选择\"></a>多条件选择</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[(arr&gt;<span class=\"number\">5</span>) &amp; (arr%<span class=\"number\">2</span>==<span class=\"number\">0</span>)] <span class=\"comment\"># 选择大于5且为偶数的元素</span></span><br><span class=\"line\"><span class=\"comment\"># [ 6,  8, 10]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意：多条件要用（）括起每一个条件，逻辑关系用-或者-amp-，不能用-and-or-这样。\"><a href=\"#注意：多条件要用（）括起每一个条件，逻辑关系用-或者-amp-，不能用-and-or-这样。\" class=\"headerlink\" title=\"注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &amp;，不能用 and,or 这样。\"></a>注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &amp;，不能用 and,or 这样。</h5>","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":1509,"excerpt":"<h2 id=\"numpy-的条件筛选\"><a href=\"#numpy-的条件筛选\" class=\"headerlink\" title=\"numpy 的条件筛选\"></a>numpy 的条件筛选</h2><h3 id=\"筛选基础\"><a href=\"#筛选基础\" class=\"headerlink\" title=\"筛选基础\"></a>筛选基础</h3><h4 id=\"数组切片\"><a href=\"#数组切片\" class=\"headerlink\" title=\"数组切片\"></a>数组切片</h4><p>我们一般都知道 python 的 [ ] 操作符可以进行切片操作,举例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"comment\">#切片操作参数介绍：[起始位置下标（默认最开始）:结束位置下标(默认最后):步长(默认为一)]</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># [1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>:<span class=\"number\">2</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># [1,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当步长为-1时，能够逆置数组</span></span><br><span class=\"line\">arr[::-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\"># [3,2,1]</span></span><br></pre></td></tr></table></figure>","more":"<h4 id=\"下面是-ndarray-二维数组的例子\"><a href=\"#下面是-ndarray-二维数组的例子\" class=\"headerlink\" title=\"下面是 ndarray 二维数组的例子\"></a>下面是 ndarray 二维数组的例子</h4><h5 id=\"单列-行筛选\"><a href=\"#单列-行筛选\" class=\"headerlink\" title=\"单列/行筛选\"></a>单列/行筛选</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">arr = np.array(arr)</span><br><span class=\"line\"><span class=\"comment\"># 单列筛选</span></span><br><span class=\"line\"><span class=\"comment\"># 列筛选，第一个冒号不能省略</span></span><br><span class=\"line\">arr[:,<span class=\"number\">0</span>] <span class=\"comment\"># 选择下标为0的列</span></span><br><span class=\"line\"><span class=\"comment\"># [1,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单行筛选</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] <span class=\"comment\"># 选择下标为0的行，就像普通的二维数组访问第一个一维数组一样</span></span><br><span class=\"line\"><span class=\"comment\"># [1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"多行-列筛选\"><a href=\"#多行-列筛选\" class=\"headerlink\" title=\"多行/列筛选\"></a>多行/列筛选</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">arr = np.array(arr)</span><br><span class=\"line\"><span class=\"comment\"># 多列筛选</span></span><br><span class=\"line\">\t<span class=\"comment\"># 选择某个下标区间的列</span></span><br><span class=\"line\">arr[:,<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\"># [1,2],</span></span><br><span class=\"line\"><span class=\"comment\"># [4,5]</span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\">\t<span class=\"comment\"># 选择某些列</span></span><br><span class=\"line\">arr[:,[<span class=\"number\">0</span>,<span class=\"number\">3</span>]] <span class=\"comment\"># 选择下标为 0，3的列</span></span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\"># [1,4],</span></span><br><span class=\"line\"><span class=\"comment\"># [4,7]</span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\">\t<span class=\"comment\"># bool选择</span></span><br><span class=\"line\">\t<span class=\"comment\"># bool数组的  长度  必须要与列的  维数相同</span></span><br><span class=\"line\">arr[:,[<span class=\"literal\">True</span>,<span class=\"literal\">False</span>,<span class=\"literal\">False</span>,<span class=\"literal\">False</span>]]</span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\"># [1],</span></span><br><span class=\"line\"><span class=\"comment\"># [4]</span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多行筛选</span></span><br><span class=\"line\"><span class=\"comment\"># 与多列筛选类似</span></span><br><span class=\"line\">arr = np.array([</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">[<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\">\t<span class=\"comment\"># 选择某些行</span></span><br><span class=\"line\">arr[[<span class=\"number\">0</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"comment\"># [[</span></span><br><span class=\"line\"><span class=\"comment\"># [1,2,3,4],</span></span><br><span class=\"line\"><span class=\"comment\"># [4,5,6,7]</span></span><br><span class=\"line\"><span class=\"comment\"># ]]</span></span><br><span class=\"line\">\t<span class=\"comment\"># 其余就不在赘述，可以字行测试</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件筛选\"><a href=\"#条件筛选\" class=\"headerlink\" title=\"条件筛选\"></a>条件筛选</h3><p>通过上面的一些基本的筛选规则，可以大致了解了 numpy 的筛选原则了，那么下面就看一 numpy 比较强大的条件筛选吧。而条件筛选就是依赖 bool 筛选实现的。</p>\n<h4 id=\"条件筛选行\"><a href=\"#条件筛选行\" class=\"headerlink\" title=\"条件筛选行\"></a>条件筛选行</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = np.array([</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">[<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如：选择第一个元素为偶数的行</span></span><br><span class=\"line\">arr[arr[:,<span class=\"number\">0</span>]%<span class=\"number\">2</span>==<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># [[ 4,  5,  6,  7],</span></span><br><span class=\"line\"><span class=\"comment\">#  [ 8,  9, 10, 11]]</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看一下上面发生了什么。<br>首先: arr[:,0]x 选择除了二维数组的第一列—–[1,4,8]<br>然后: arr[:,0]%2==0 得到了一个 bool 数组—–[False,True,True]<br>最后 arr[[False,True,True]],这个样子是不是有点熟悉了，也就是上面的 bool 筛选。</p>\n<h4 id=\"条件筛选列\"><a href=\"#条件筛选列\" class=\"headerlink\" title=\"条件筛选列\"></a>条件筛选列</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 与行筛选类似</span></span><br><span class=\"line\">arr[:,arr[<span class=\"number\">1</span>]&gt;<span class=\"number\">5</span>] <span class=\"comment\"># 选择第二行中大于5的列</span></span><br><span class=\"line\"><span class=\"comment\"># [[ 3,  4],</span></span><br><span class=\"line\"><span class=\"comment\">#  [ 6,  7],</span></span><br><span class=\"line\"><span class=\"comment\">#  [10, 11]]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"行列一起选择\"><a href=\"#行列一起选择\" class=\"headerlink\" title=\"行列一起选择\"></a>行列一起选择</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[arr&gt;<span class=\"number\">5</span>] <span class=\"comment\"># 选择arr中，大于5的元素</span></span><br><span class=\"line\"><span class=\"comment\"># 其中arr&gt;5得到一个二维的bool数组</span></span><br><span class=\"line\"><span class=\"comment\"># [[False, False, False, False],</span></span><br><span class=\"line\"><span class=\"comment\">#  [False, False,  True,  True],</span></span><br><span class=\"line\"><span class=\"comment\">#  [ True,  True,  True,  True]]</span></span><br><span class=\"line\"><span class=\"comment\"># 最终结果是一个一维数组</span></span><br><span class=\"line\"><span class=\"comment\"># [ 6,  7,  8,  9, 10, 11]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列-int，第二列是-str，这样再用-arr-gt-5-就会出现错误。\"><a href=\"#注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列-int，第二列是-str，这样再用-arr-gt-5-就会出现错误。\" class=\"headerlink\" title=\"注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr&gt;5 就会出现错误。\"></a>注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr&gt;5 就会出现错误。</h5><h4 id=\"多条件选择\"><a href=\"#多条件选择\" class=\"headerlink\" title=\"多条件选择\"></a>多条件选择</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[(arr&gt;<span class=\"number\">5</span>) &amp; (arr%<span class=\"number\">2</span>==<span class=\"number\">0</span>)] <span class=\"comment\"># 选择大于5且为偶数的元素</span></span><br><span class=\"line\"><span class=\"comment\"># [ 6,  8, 10]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意：多条件要用（）括起每一个条件，逻辑关系用-或者-amp-，不能用-and-or-这样。\"><a href=\"#注意：多条件要用（）括起每一个条件，逻辑关系用-或者-amp-，不能用-and-or-这样。\" class=\"headerlink\" title=\"注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &amp;，不能用 and,or 这样。\"></a>注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &amp;，不能用 and,or 这样。</h5>"},{"title":"react事件系统","date":"2022-05-01T15:06:13.000Z","_content":"\n## 开始注册事件\n\n- 这里只是简单的设置一些变量值，见下面代码\n\n```typescript\n// 注册事件\n// DOMPluginEventSystem.ts\nSimpleEventPlugin.registerEvents();\nEnterLeaveEventPlugin.registerEvents();\nChangeEventPlugin.registerEvents();\nSelectEventPlugin.registerEvents();\nBeforeInputEventPlugin.registerEvents();\n```\n\n```typescript\n\nallNativeEvent:Set<DOMEventName> = {'click','keyup','keydown',...};\n\nregistrationNameDependencies[\"onClick\"] = [\"click\"];\nregistrationNameDependencies['onMouseEnter'] = ['mouseout', 'mouseover']; //...\n\ntopLevelEventsToReactNames:Map<DOMEventName,string|null> = {\"click\":\"onClick\"};\n```\n\n<!-- more -->\n\n## 大致流程\n\n![flowchart](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202205062357.png)\n\n## listenToAllSupportedEvent\n\n- 接下来是让root容器监听所有支持的事件\n\n非委托事件只有捕获阶段。\n而委托事件捕获冒泡都会绑定。\n\n```typescript\nallNativeEvents.forEach(domEventName => {\n  // 我们单独处理selectionchange更改，因为它不会冒泡，需要出现在document上\n  if (domEventName !== 'selectionchange') {\n    if (!nonDelegatedEvents.has(domEventName)) {\n      // 不捕获\n      listenToNativeEvent(domEventName, false, rootContainerElement);\n    }\n    // nonDelegatedEvents事件是是捕获阶段监听器\n    // delegatedEvents是冒泡捕获都有\n    listenToNativeEvent(domEventName, true, rootContainerElement);\n  }\n});\n```\n\n**_注意：_**selectionChange事件是监听在document上的，因为它不会冒泡。\n\n## 绑定react的listener到root || document上\n\nlistenToNativeEvent **-->** addTrappedEventListener **-->** listener = createEventListenerWrapperWithPriority\n\n## createEventListenerWrapperWithPriority\n\n这里进行创建listener,listener有如下几种：\n\n```typescript\nfunction createEventListenerWrapperWithPriority(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n): Function {\n  const eventPriority = getEventPriority(domEventName);\n  let listenerWrapper;\n  switch (eventPriority) {\n    // 一般事件都是DiscreteEventPriority\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  }\n  return listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n  );\n}\n```\n\n这三种listener存在一个优先级的差别。\n最终都会调用dispatchEvent.\n\n## dispatchEvent\n\n- 这是react进行触发事件监听函数的地方，这里的listener是绑定到组件props上的事件处理函数。\n\n首先判断是否是allowReplay事件：\n\n```typescript\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n  // eventSystemFlags capture时等于4,bubble时等于0\n  // capture & 4 = 4; bubble & 4 = 0\n  // IS_CAPTURE_PHASE = 4\n```\n\n然后是先去尝试调度事件,判定是否会blockOn：\n\n```typescript\n  const blockedOn = attemptToDispatchEvent(\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n```\n\n## attemptToDispatchEvent\n\n1. 先是获取真正的事件触发元素：e.targe，这里称为nativeEventTarget\n2. 获取nativeEventTarget上的Fiber,即\"__reactFiber${Random...}\"属性。这里是targetInst.\n3. 处理让targetInst为null的情况。\n    1. 节点被unmounted,即不能通过return属性到达根节点。\n    2. 如果最近的mounted是SuspenseCompnent | HostRoot | 最近的mountedFiber  !== targetInst\n\n接下来进入真正的事件调度函数。\n\n## dispatchEventForPluginEventSystem\n\n- 在这里面，会有一个mainLoop,去寻找一个root节点，因为在root节点上，会绑定一些事件。\n- 遍历的方式是从当前节点一直往上（return）.\n- 最后batchedEventUpdates ---> dispatchEventsForPlugins\n\n```typescript\n// DOMPluginEventSystem\nfunction dispatchEventForPluginEventSystem(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber, // 触发事件的Fiber\n  targetContainer: EventTarget, // root\n): void {\n  let ancestorInst = targetInst;\n  if (\n    (eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&\n    (eventSystemFlags & IS_NON_DELEGATED) === 0\n  ) {\n    const targetContainerNode = targetContainer as Node;\n\n    if (targetInst !== null) {\n\n      let node = targetInst;\n      mainLoop: while (true) {\n        // ...搜索root container\n      }\n    }\n  }\n\n  batchedEventUpdates(() =>\n  // 进入合成事件系统\n    dispatchEventsForPlugins(\n      domEventName,\n      eventSystemFlags,\n      nativeEvent,\n      ancestorInst,\n      targetContainer,\n    ),\n  );\n}\n```\n\n## dispatchEventsForPlugins\n\n- 将nativeEvent转换成synthesizeEvent,并加入dispatchQueue，最终processDispatchQueue。\n\n_extractEvents:_\n\n  > 创建DispatchEntry:{event:listeners}，并添加到dispatchQueue\n\n  1. 工厂模式确定SyntheticEventCtor\n  2. accumulateSinglePhaseListeners从target到root遍历，获取绑定到props的事件处理函数，添加用户自己添加的事件处理函数到listeners数组里并返回。\n  3. dispatchQueue.push({event,listeners})\n  这里event也就是synthesizeEvent对象，即在事件绑定后的回调函数的默认参数event.\n\n_processDispatchQueue:_\n\n> 遍历dispatchQueue,处理每个事件的listeners数组\n\n```typescript\n/**\n * 调用processDispatchQueueItemsInOrder，执行事件处理函数\n * @param {Array<{\n * event: ReactSyntheticEvent,\n * listeners: Array<{\n * instance: null | Fiber,\n * listener: Function,\n * currentTarget: EventTarget,\n * }>}} dispatchQueue\n * @param {EventSystemFlags} eventSystemFlags\n */\nexport function processDispatchQueue(\n  dispatchQueue: DispatchQueue,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n  for (let i = 0; i < dispatchQueue.length; i++) {\n    // { event: ReactSyntheticEvent,listeners: Array < DispatchListener >};\n    const { event, listeners } = dispatchQueue[i];\n\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\n    //  event system doesn't use pooling.\n    // 事件系统不使用池。\n  }\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n```\n\n- processDispatchQueueItemsInOrder\n\n> 根据inCapturePhase判定是capture还是bubble,\n\n```typescript\n    /**\n * 执行事件队列，根据是否捕获确定事件的执行顺序\n * []dispatchListeners\n * 捕获：重最后一个到第一个\n * 冒泡：重0到最后一个\n * @param {ReactSyntheticEvent} event\n * @param {Array<DispatchListener>} dispatchListeners\n * @param {boolean} inCapturePhase\n * @returns\n */\nfunction processDispatchQueueItemsInOrder(\n  event: ReactSyntheticEvent,\n  dispatchListeners: Array<DispatchListener>,\n  inCapturePhase: boolean,\n): void {\n  let previousInstance;\n  // 捕获\n  // 因为添加dispatcher时是从当前然后return到null,所以捕获是倒过来的运行\n  if (inCapturePhase) {\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\n      // { instance: null | Fiber,listener: Function,currentTarget: EventTarget};\n      const { instance, currentTarget, listener } = dispatchListeners[i];\n\n      // 阻止冒泡stopPropagation\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  } else {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      const { instance, currentTarget, listener } = dispatchListeners[i];\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  }\n}\n```\n\n## executeDispatch\n\n- 最终调用用户的处理函数,其中包含一些react的invoke函数，以及一些在开发环境下的createEvent事件。\n\n> 本文还有许多细节没有提到，只是大致说明了事件系统的一个流程\n\n## 未完待续\n","source":"_posts/react合成事件.md","raw":"---\ntitle: react事件系统\ndate: 2022-05-01 23:06:13\ntags:\ncategories: react\n---\n\n## 开始注册事件\n\n- 这里只是简单的设置一些变量值，见下面代码\n\n```typescript\n// 注册事件\n// DOMPluginEventSystem.ts\nSimpleEventPlugin.registerEvents();\nEnterLeaveEventPlugin.registerEvents();\nChangeEventPlugin.registerEvents();\nSelectEventPlugin.registerEvents();\nBeforeInputEventPlugin.registerEvents();\n```\n\n```typescript\n\nallNativeEvent:Set<DOMEventName> = {'click','keyup','keydown',...};\n\nregistrationNameDependencies[\"onClick\"] = [\"click\"];\nregistrationNameDependencies['onMouseEnter'] = ['mouseout', 'mouseover']; //...\n\ntopLevelEventsToReactNames:Map<DOMEventName,string|null> = {\"click\":\"onClick\"};\n```\n\n<!-- more -->\n\n## 大致流程\n\n![flowchart](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202205062357.png)\n\n## listenToAllSupportedEvent\n\n- 接下来是让root容器监听所有支持的事件\n\n非委托事件只有捕获阶段。\n而委托事件捕获冒泡都会绑定。\n\n```typescript\nallNativeEvents.forEach(domEventName => {\n  // 我们单独处理selectionchange更改，因为它不会冒泡，需要出现在document上\n  if (domEventName !== 'selectionchange') {\n    if (!nonDelegatedEvents.has(domEventName)) {\n      // 不捕获\n      listenToNativeEvent(domEventName, false, rootContainerElement);\n    }\n    // nonDelegatedEvents事件是是捕获阶段监听器\n    // delegatedEvents是冒泡捕获都有\n    listenToNativeEvent(domEventName, true, rootContainerElement);\n  }\n});\n```\n\n**_注意：_**selectionChange事件是监听在document上的，因为它不会冒泡。\n\n## 绑定react的listener到root || document上\n\nlistenToNativeEvent **-->** addTrappedEventListener **-->** listener = createEventListenerWrapperWithPriority\n\n## createEventListenerWrapperWithPriority\n\n这里进行创建listener,listener有如下几种：\n\n```typescript\nfunction createEventListenerWrapperWithPriority(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n): Function {\n  const eventPriority = getEventPriority(domEventName);\n  let listenerWrapper;\n  switch (eventPriority) {\n    // 一般事件都是DiscreteEventPriority\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  }\n  return listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n  );\n}\n```\n\n这三种listener存在一个优先级的差别。\n最终都会调用dispatchEvent.\n\n## dispatchEvent\n\n- 这是react进行触发事件监听函数的地方，这里的listener是绑定到组件props上的事件处理函数。\n\n首先判断是否是allowReplay事件：\n\n```typescript\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n  // eventSystemFlags capture时等于4,bubble时等于0\n  // capture & 4 = 4; bubble & 4 = 0\n  // IS_CAPTURE_PHASE = 4\n```\n\n然后是先去尝试调度事件,判定是否会blockOn：\n\n```typescript\n  const blockedOn = attemptToDispatchEvent(\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n```\n\n## attemptToDispatchEvent\n\n1. 先是获取真正的事件触发元素：e.targe，这里称为nativeEventTarget\n2. 获取nativeEventTarget上的Fiber,即\"__reactFiber${Random...}\"属性。这里是targetInst.\n3. 处理让targetInst为null的情况。\n    1. 节点被unmounted,即不能通过return属性到达根节点。\n    2. 如果最近的mounted是SuspenseCompnent | HostRoot | 最近的mountedFiber  !== targetInst\n\n接下来进入真正的事件调度函数。\n\n## dispatchEventForPluginEventSystem\n\n- 在这里面，会有一个mainLoop,去寻找一个root节点，因为在root节点上，会绑定一些事件。\n- 遍历的方式是从当前节点一直往上（return）.\n- 最后batchedEventUpdates ---> dispatchEventsForPlugins\n\n```typescript\n// DOMPluginEventSystem\nfunction dispatchEventForPluginEventSystem(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber, // 触发事件的Fiber\n  targetContainer: EventTarget, // root\n): void {\n  let ancestorInst = targetInst;\n  if (\n    (eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&\n    (eventSystemFlags & IS_NON_DELEGATED) === 0\n  ) {\n    const targetContainerNode = targetContainer as Node;\n\n    if (targetInst !== null) {\n\n      let node = targetInst;\n      mainLoop: while (true) {\n        // ...搜索root container\n      }\n    }\n  }\n\n  batchedEventUpdates(() =>\n  // 进入合成事件系统\n    dispatchEventsForPlugins(\n      domEventName,\n      eventSystemFlags,\n      nativeEvent,\n      ancestorInst,\n      targetContainer,\n    ),\n  );\n}\n```\n\n## dispatchEventsForPlugins\n\n- 将nativeEvent转换成synthesizeEvent,并加入dispatchQueue，最终processDispatchQueue。\n\n_extractEvents:_\n\n  > 创建DispatchEntry:{event:listeners}，并添加到dispatchQueue\n\n  1. 工厂模式确定SyntheticEventCtor\n  2. accumulateSinglePhaseListeners从target到root遍历，获取绑定到props的事件处理函数，添加用户自己添加的事件处理函数到listeners数组里并返回。\n  3. dispatchQueue.push({event,listeners})\n  这里event也就是synthesizeEvent对象，即在事件绑定后的回调函数的默认参数event.\n\n_processDispatchQueue:_\n\n> 遍历dispatchQueue,处理每个事件的listeners数组\n\n```typescript\n/**\n * 调用processDispatchQueueItemsInOrder，执行事件处理函数\n * @param {Array<{\n * event: ReactSyntheticEvent,\n * listeners: Array<{\n * instance: null | Fiber,\n * listener: Function,\n * currentTarget: EventTarget,\n * }>}} dispatchQueue\n * @param {EventSystemFlags} eventSystemFlags\n */\nexport function processDispatchQueue(\n  dispatchQueue: DispatchQueue,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n  for (let i = 0; i < dispatchQueue.length; i++) {\n    // { event: ReactSyntheticEvent,listeners: Array < DispatchListener >};\n    const { event, listeners } = dispatchQueue[i];\n\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\n    //  event system doesn't use pooling.\n    // 事件系统不使用池。\n  }\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n```\n\n- processDispatchQueueItemsInOrder\n\n> 根据inCapturePhase判定是capture还是bubble,\n\n```typescript\n    /**\n * 执行事件队列，根据是否捕获确定事件的执行顺序\n * []dispatchListeners\n * 捕获：重最后一个到第一个\n * 冒泡：重0到最后一个\n * @param {ReactSyntheticEvent} event\n * @param {Array<DispatchListener>} dispatchListeners\n * @param {boolean} inCapturePhase\n * @returns\n */\nfunction processDispatchQueueItemsInOrder(\n  event: ReactSyntheticEvent,\n  dispatchListeners: Array<DispatchListener>,\n  inCapturePhase: boolean,\n): void {\n  let previousInstance;\n  // 捕获\n  // 因为添加dispatcher时是从当前然后return到null,所以捕获是倒过来的运行\n  if (inCapturePhase) {\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\n      // { instance: null | Fiber,listener: Function,currentTarget: EventTarget};\n      const { instance, currentTarget, listener } = dispatchListeners[i];\n\n      // 阻止冒泡stopPropagation\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  } else {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      const { instance, currentTarget, listener } = dispatchListeners[i];\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  }\n}\n```\n\n## executeDispatch\n\n- 最终调用用户的处理函数,其中包含一些react的invoke函数，以及一些在开发环境下的createEvent事件。\n\n> 本文还有许多细节没有提到，只是大致说明了事件系统的一个流程\n\n## 未完待续\n","slug":"react合成事件","published":1,"updated":"2022-12-31T10:26:33.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyj000lg8v7d2bz2f2w","content":"<h2 id=\"开始注册事件\"><a href=\"#开始注册事件\" class=\"headerlink\" title=\"开始注册事件\"></a>开始注册事件</h2><ul>\n<li>这里只是简单的设置一些变量值，见下面代码</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// DOMPluginEventSystem.ts</span></span><br><span class=\"line\">SimpleEventPlugin.registerEvents();</span><br><span class=\"line\">EnterLeaveEventPlugin.registerEvents();</span><br><span class=\"line\">ChangeEventPlugin.registerEvents();</span><br><span class=\"line\">SelectEventPlugin.registerEvents();</span><br><span class=\"line\">BeforeInputEventPlugin.registerEvents();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">allNativeEvent</span>:<span class=\"built_in\">Set</span>&lt;DOMEventName&gt; = &#123;<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"string\">&#x27;keyup&#x27;</span>,<span class=\"string\">&#x27;keydown&#x27;</span>,...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">registrationNameDependencies[<span class=\"string\">&quot;onClick&quot;</span>] = [<span class=\"string\">&quot;click&quot;</span>];</span><br><span class=\"line\">registrationNameDependencies[<span class=\"string\">&#x27;onMouseEnter&#x27;</span>] = [<span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"string\">&#x27;mouseover&#x27;</span>]; <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">topLevelEventsToReactNames:<span class=\"built_in\">Map</span>&lt;DOMEventName,<span class=\"built_in\">string</span>|<span class=\"literal\">null</span>&gt; = &#123;<span class=\"string\">&quot;click&quot;</span>:<span class=\"string\">&quot;onClick&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"大致流程\"><a href=\"#大致流程\" class=\"headerlink\" title=\"大致流程\"></a>大致流程</h2><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202205062357.png\" alt=\"flowchart\"></p>\n<h2 id=\"listenToAllSupportedEvent\"><a href=\"#listenToAllSupportedEvent\" class=\"headerlink\" title=\"listenToAllSupportedEvent\"></a>listenToAllSupportedEvent</h2><ul>\n<li>接下来是让root容器监听所有支持的事件</li>\n</ul>\n<p>非委托事件只有捕获阶段。<br>而委托事件捕获冒泡都会绑定。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allNativeEvents.forEach(<span class=\"function\"><span class=\"params\">domEventName</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们单独处理selectionchange更改，因为它不会冒泡，需要出现在document上</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (domEventName !== <span class=\"string\">&#x27;selectionchange&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nonDelegatedEvents.has(domEventName)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不捕获</span></span><br><span class=\"line\">      listenToNativeEvent(domEventName, <span class=\"literal\">false</span>, rootContainerElement);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// nonDelegatedEvents事件是是捕获阶段监听器</span></span><br><span class=\"line\">    <span class=\"comment\">// delegatedEvents是冒泡捕获都有</span></span><br><span class=\"line\">    listenToNativeEvent(domEventName, <span class=\"literal\">true</span>, rootContainerElement);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>**<em>注意：</em>**selectionChange事件是监听在document上的，因为它不会冒泡。</p>\n<h2 id=\"绑定react的listener到root-document上\"><a href=\"#绑定react的listener到root-document上\" class=\"headerlink\" title=\"绑定react的listener到root || document上\"></a>绑定react的listener到root || document上</h2><p>listenToNativeEvent <strong>–&gt;</strong> addTrappedEventListener <strong>–&gt;</strong> listener = createEventListenerWrapperWithPriority</p>\n<h2 id=\"createEventListenerWrapperWithPriority\"><a href=\"#createEventListenerWrapperWithPriority\" class=\"headerlink\" title=\"createEventListenerWrapperWithPriority\"></a>createEventListenerWrapperWithPriority</h2><p>这里进行创建listener,listener有如下几种：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createEventListenerWrapperWithPriority</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  targetContainer: EventTarget,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  domEventName: DOMEventName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">Function</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> eventPriority = getEventPriority(domEventName);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> listenerWrapper;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (eventPriority) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一般事件都是DiscreteEventPriority</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> DiscreteEventPriority:</span><br><span class=\"line\">      listenerWrapper = dispatchDiscreteEvent;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ContinuousEventPriority:</span><br><span class=\"line\">      listenerWrapper = dispatchContinuousEvent;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DefaultEventPriority:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      listenerWrapper = dispatchEvent;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> listenerWrapper.bind(</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    domEventName,</span><br><span class=\"line\">    eventSystemFlags,</span><br><span class=\"line\">    targetContainer,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这三种listener存在一个优先级的差别。<br>最终都会调用dispatchEvent.</p>\n<h2 id=\"dispatchEvent\"><a href=\"#dispatchEvent\" class=\"headerlink\" title=\"dispatchEvent\"></a>dispatchEvent</h2><ul>\n<li>这是react进行触发事件监听函数的地方，这里的listener是绑定到组件props上的事件处理函数。</li>\n</ul>\n<p>首先判断是否是allowReplay事件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> allowReplay = (eventSystemFlags &amp; IS_CAPTURE_PHASE) === <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// eventSystemFlags capture时等于4,bubble时等于0</span></span><br><span class=\"line\"><span class=\"comment\">// capture &amp; 4 = 4; bubble &amp; 4 = 0</span></span><br><span class=\"line\"><span class=\"comment\">// IS_CAPTURE_PHASE = 4</span></span><br></pre></td></tr></table></figure>\n\n<p>然后是先去尝试调度事件,判定是否会blockOn：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blockedOn = attemptToDispatchEvent(</span><br><span class=\"line\">  domEventName,</span><br><span class=\"line\">  eventSystemFlags,</span><br><span class=\"line\">  targetContainer,</span><br><span class=\"line\">  nativeEvent,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"attemptToDispatchEvent\"><a href=\"#attemptToDispatchEvent\" class=\"headerlink\" title=\"attemptToDispatchEvent\"></a>attemptToDispatchEvent</h2><ol>\n<li>先是获取真正的事件触发元素：e.targe，这里称为nativeEventTarget</li>\n<li>获取nativeEventTarget上的Fiber,即”__reactFiber${Random…}”属性。这里是targetInst.</li>\n<li>处理让targetInst为null的情况。<ol>\n<li>节点被unmounted,即不能通过return属性到达根节点。</li>\n<li>如果最近的mounted是SuspenseCompnent | HostRoot | 最近的mountedFiber  !== targetInst</li>\n</ol>\n</li>\n</ol>\n<p>接下来进入真正的事件调度函数。</p>\n<h2 id=\"dispatchEventForPluginEventSystem\"><a href=\"#dispatchEventForPluginEventSystem\" class=\"headerlink\" title=\"dispatchEventForPluginEventSystem\"></a>dispatchEventForPluginEventSystem</h2><ul>\n<li>在这里面，会有一个mainLoop,去寻找一个root节点，因为在root节点上，会绑定一些事件。</li>\n<li>遍历的方式是从当前节点一直往上（return）.</li>\n<li>最后batchedEventUpdates —&gt; dispatchEventsForPlugins</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DOMPluginEventSystem</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatchEventForPluginEventSystem</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  domEventName: DOMEventName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  targetInst: <span class=\"literal\">null</span> | Fiber, <span class=\"comment\">// 触发事件的Fiber</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  targetContainer: EventTarget, <span class=\"comment\">// root</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ancestorInst = targetInst;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (eventSystemFlags &amp; IS_EVENT_HANDLE_NON_MANAGED_NODE) === <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">    (eventSystemFlags &amp; IS_NON_DELEGATED) === <span class=\"number\">0</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> targetContainerNode = targetContainer <span class=\"keyword\">as</span> Node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetInst !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">let</span> node = targetInst;</span><br><span class=\"line\">      mainLoop: <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...搜索root container</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  batchedEventUpdates(<span class=\"function\">() =&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// 进入合成事件系统</span></span><br><span class=\"line\">    dispatchEventsForPlugins(</span><br><span class=\"line\">      domEventName,</span><br><span class=\"line\">      eventSystemFlags,</span><br><span class=\"line\">      nativeEvent,</span><br><span class=\"line\">      ancestorInst,</span><br><span class=\"line\">      targetContainer,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dispatchEventsForPlugins\"><a href=\"#dispatchEventsForPlugins\" class=\"headerlink\" title=\"dispatchEventsForPlugins\"></a>dispatchEventsForPlugins</h2><ul>\n<li>将nativeEvent转换成synthesizeEvent,并加入dispatchQueue，最终processDispatchQueue。</li>\n</ul>\n<p><em>extractEvents:</em></p>\n<blockquote>\n<p>创建DispatchEntry:{event:listeners}，并添加到dispatchQueue</p>\n</blockquote>\n<ol>\n<li>工厂模式确定SyntheticEventCtor</li>\n<li>accumulateSinglePhaseListeners从target到root遍历，获取绑定到props的事件处理函数，添加用户自己添加的事件处理函数到listeners数组里并返回。</li>\n<li>dispatchQueue.push({event,listeners})<br>这里event也就是synthesizeEvent对象，即在事件绑定后的回调函数的默认参数event.</li>\n</ol>\n<p><em>processDispatchQueue:</em></p>\n<blockquote>\n<p>遍历dispatchQueue,处理每个事件的listeners数组</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 调用processDispatchQueueItemsInOrder，执行事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Array&lt;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * event: ReactSyntheticEvent,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * listeners: Array&lt;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * instance: null | Fiber,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * listener: Function,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * currentTarget: EventTarget,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * &#125;</span></span>&gt;&#125;&#125; dispatchQueue</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;EventSystemFlags&#125;</span> <span class=\"variable\">eventSystemFlags</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processDispatchQueue</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  dispatchQueue: DispatchQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dispatchQueue.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123; event: ReactSyntheticEvent,listeners: Array &lt; DispatchListener &gt;&#125;;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; event, listeners &#125; = dispatchQueue[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);</span><br><span class=\"line\">    <span class=\"comment\">//  event system doesn&#x27;t use pooling.</span></span><br><span class=\"line\">    <span class=\"comment\">// 事件系统不使用池。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// This would be a good time to rethrow if any of the event handlers threw.</span></span><br><span class=\"line\">  rethrowCaughtError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>processDispatchQueueItemsInOrder</li>\n</ul>\n<blockquote>\n<p>根据inCapturePhase判定是capture还是bubble,</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 执行事件队列，根据是否捕获确定事件的执行顺序</span></span><br><span class=\"line\"><span class=\"comment\"> * []dispatchListeners</span></span><br><span class=\"line\"><span class=\"comment\"> * 捕获：重最后一个到第一个</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡：重0到最后一个</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ReactSyntheticEvent&#125;</span> <span class=\"variable\">event</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Array&lt;DispatchListener&gt;&#125;</span> <span class=\"variable\">dispatchListeners</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;boolean&#125;</span> <span class=\"variable\">inCapturePhase</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processDispatchQueueItemsInOrder</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  event: ReactSyntheticEvent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  dispatchListeners: <span class=\"built_in\">Array</span>&lt;DispatchListener&gt;,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  inCapturePhase: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> previousInstance;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为添加dispatcher时是从当前然后return到null,所以捕获是倒过来的运行</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inCapturePhase) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = dispatchListeners.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123; instance: null | Fiber,listener: Function,currentTarget: EventTarget&#125;;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 阻止冒泡stopPropagation</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      executeDispatch(event, listener, currentTarget);</span><br><span class=\"line\">      previousInstance = instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      executeDispatch(event, listener, currentTarget);</span><br><span class=\"line\">      previousInstance = instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"executeDispatch\"><a href=\"#executeDispatch\" class=\"headerlink\" title=\"executeDispatch\"></a>executeDispatch</h2><ul>\n<li>最终调用用户的处理函数,其中包含一些react的invoke函数，以及一些在开发环境下的createEvent事件。</li>\n</ul>\n<blockquote>\n<p>本文还有许多细节没有提到，只是大致说明了事件系统的一个流程</p>\n</blockquote>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2>","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":6320,"excerpt":"<h2 id=\"开始注册事件\"><a href=\"#开始注册事件\" class=\"headerlink\" title=\"开始注册事件\"></a>开始注册事件</h2><ul>\n<li>这里只是简单的设置一些变量值，见下面代码</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// DOMPluginEventSystem.ts</span></span><br><span class=\"line\">SimpleEventPlugin.registerEvents();</span><br><span class=\"line\">EnterLeaveEventPlugin.registerEvents();</span><br><span class=\"line\">ChangeEventPlugin.registerEvents();</span><br><span class=\"line\">SelectEventPlugin.registerEvents();</span><br><span class=\"line\">BeforeInputEventPlugin.registerEvents();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">allNativeEvent</span>:<span class=\"built_in\">Set</span>&lt;DOMEventName&gt; = &#123;<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"string\">&#x27;keyup&#x27;</span>,<span class=\"string\">&#x27;keydown&#x27;</span>,...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">registrationNameDependencies[<span class=\"string\">&quot;onClick&quot;</span>] = [<span class=\"string\">&quot;click&quot;</span>];</span><br><span class=\"line\">registrationNameDependencies[<span class=\"string\">&#x27;onMouseEnter&#x27;</span>] = [<span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"string\">&#x27;mouseover&#x27;</span>]; <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">topLevelEventsToReactNames:<span class=\"built_in\">Map</span>&lt;DOMEventName,<span class=\"built_in\">string</span>|<span class=\"literal\">null</span>&gt; = &#123;<span class=\"string\">&quot;click&quot;</span>:<span class=\"string\">&quot;onClick&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"大致流程\"><a href=\"#大致流程\" class=\"headerlink\" title=\"大致流程\"></a>大致流程</h2><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202205062357.png\" alt=\"flowchart\"></p>\n<h2 id=\"listenToAllSupportedEvent\"><a href=\"#listenToAllSupportedEvent\" class=\"headerlink\" title=\"listenToAllSupportedEvent\"></a>listenToAllSupportedEvent</h2><ul>\n<li>接下来是让root容器监听所有支持的事件</li>\n</ul>\n<p>非委托事件只有捕获阶段。<br>而委托事件捕获冒泡都会绑定。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allNativeEvents.forEach(<span class=\"function\"><span class=\"params\">domEventName</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们单独处理selectionchange更改，因为它不会冒泡，需要出现在document上</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (domEventName !== <span class=\"string\">&#x27;selectionchange&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nonDelegatedEvents.has(domEventName)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不捕获</span></span><br><span class=\"line\">      listenToNativeEvent(domEventName, <span class=\"literal\">false</span>, rootContainerElement);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// nonDelegatedEvents事件是是捕获阶段监听器</span></span><br><span class=\"line\">    <span class=\"comment\">// delegatedEvents是冒泡捕获都有</span></span><br><span class=\"line\">    listenToNativeEvent(domEventName, <span class=\"literal\">true</span>, rootContainerElement);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>**<em>注意：</em>**selectionChange事件是监听在document上的，因为它不会冒泡。</p>\n<h2 id=\"绑定react的listener到root-document上\"><a href=\"#绑定react的listener到root-document上\" class=\"headerlink\" title=\"绑定react的listener到root || document上\"></a>绑定react的listener到root || document上</h2><p>listenToNativeEvent <strong>–&gt;</strong> addTrappedEventListener <strong>–&gt;</strong> listener = createEventListenerWrapperWithPriority</p>\n<h2 id=\"createEventListenerWrapperWithPriority\"><a href=\"#createEventListenerWrapperWithPriority\" class=\"headerlink\" title=\"createEventListenerWrapperWithPriority\"></a>createEventListenerWrapperWithPriority</h2><p>这里进行创建listener,listener有如下几种：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createEventListenerWrapperWithPriority</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  targetContainer: EventTarget,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  domEventName: DOMEventName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">Function</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> eventPriority = getEventPriority(domEventName);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> listenerWrapper;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (eventPriority) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一般事件都是DiscreteEventPriority</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> DiscreteEventPriority:</span><br><span class=\"line\">      listenerWrapper = dispatchDiscreteEvent;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ContinuousEventPriority:</span><br><span class=\"line\">      listenerWrapper = dispatchContinuousEvent;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DefaultEventPriority:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      listenerWrapper = dispatchEvent;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> listenerWrapper.bind(</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    domEventName,</span><br><span class=\"line\">    eventSystemFlags,</span><br><span class=\"line\">    targetContainer,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这三种listener存在一个优先级的差别。<br>最终都会调用dispatchEvent.</p>\n<h2 id=\"dispatchEvent\"><a href=\"#dispatchEvent\" class=\"headerlink\" title=\"dispatchEvent\"></a>dispatchEvent</h2><ul>\n<li>这是react进行触发事件监听函数的地方，这里的listener是绑定到组件props上的事件处理函数。</li>\n</ul>\n<p>首先判断是否是allowReplay事件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> allowReplay = (eventSystemFlags &amp; IS_CAPTURE_PHASE) === <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// eventSystemFlags capture时等于4,bubble时等于0</span></span><br><span class=\"line\"><span class=\"comment\">// capture &amp; 4 = 4; bubble &amp; 4 = 0</span></span><br><span class=\"line\"><span class=\"comment\">// IS_CAPTURE_PHASE = 4</span></span><br></pre></td></tr></table></figure>\n\n<p>然后是先去尝试调度事件,判定是否会blockOn：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blockedOn = attemptToDispatchEvent(</span><br><span class=\"line\">  domEventName,</span><br><span class=\"line\">  eventSystemFlags,</span><br><span class=\"line\">  targetContainer,</span><br><span class=\"line\">  nativeEvent,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"attemptToDispatchEvent\"><a href=\"#attemptToDispatchEvent\" class=\"headerlink\" title=\"attemptToDispatchEvent\"></a>attemptToDispatchEvent</h2><ol>\n<li>先是获取真正的事件触发元素：e.targe，这里称为nativeEventTarget</li>\n<li>获取nativeEventTarget上的Fiber,即”__reactFiber${Random…}”属性。这里是targetInst.</li>\n<li>处理让targetInst为null的情况。<ol>\n<li>节点被unmounted,即不能通过return属性到达根节点。</li>\n<li>如果最近的mounted是SuspenseCompnent | HostRoot | 最近的mountedFiber  !== targetInst</li>\n</ol>\n</li>\n</ol>\n<p>接下来进入真正的事件调度函数。</p>\n<h2 id=\"dispatchEventForPluginEventSystem\"><a href=\"#dispatchEventForPluginEventSystem\" class=\"headerlink\" title=\"dispatchEventForPluginEventSystem\"></a>dispatchEventForPluginEventSystem</h2><ul>\n<li>在这里面，会有一个mainLoop,去寻找一个root节点，因为在root节点上，会绑定一些事件。</li>\n<li>遍历的方式是从当前节点一直往上（return）.</li>\n<li>最后batchedEventUpdates —&gt; dispatchEventsForPlugins</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DOMPluginEventSystem</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatchEventForPluginEventSystem</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  domEventName: DOMEventName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  targetInst: <span class=\"literal\">null</span> | Fiber, <span class=\"comment\">// 触发事件的Fiber</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  targetContainer: EventTarget, <span class=\"comment\">// root</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ancestorInst = targetInst;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (eventSystemFlags &amp; IS_EVENT_HANDLE_NON_MANAGED_NODE) === <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">    (eventSystemFlags &amp; IS_NON_DELEGATED) === <span class=\"number\">0</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> targetContainerNode = targetContainer <span class=\"keyword\">as</span> Node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetInst !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">let</span> node = targetInst;</span><br><span class=\"line\">      mainLoop: <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...搜索root container</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  batchedEventUpdates(<span class=\"function\">() =&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// 进入合成事件系统</span></span><br><span class=\"line\">    dispatchEventsForPlugins(</span><br><span class=\"line\">      domEventName,</span><br><span class=\"line\">      eventSystemFlags,</span><br><span class=\"line\">      nativeEvent,</span><br><span class=\"line\">      ancestorInst,</span><br><span class=\"line\">      targetContainer,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dispatchEventsForPlugins\"><a href=\"#dispatchEventsForPlugins\" class=\"headerlink\" title=\"dispatchEventsForPlugins\"></a>dispatchEventsForPlugins</h2><ul>\n<li>将nativeEvent转换成synthesizeEvent,并加入dispatchQueue，最终processDispatchQueue。</li>\n</ul>\n<p><em>extractEvents:</em></p>\n<blockquote>\n<p>创建DispatchEntry:{event:listeners}，并添加到dispatchQueue</p>\n</blockquote>\n<ol>\n<li>工厂模式确定SyntheticEventCtor</li>\n<li>accumulateSinglePhaseListeners从target到root遍历，获取绑定到props的事件处理函数，添加用户自己添加的事件处理函数到listeners数组里并返回。</li>\n<li>dispatchQueue.push({event,listeners})<br>这里event也就是synthesizeEvent对象，即在事件绑定后的回调函数的默认参数event.</li>\n</ol>\n<p><em>processDispatchQueue:</em></p>\n<blockquote>\n<p>遍历dispatchQueue,处理每个事件的listeners数组</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 调用processDispatchQueueItemsInOrder，执行事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Array&lt;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * event: ReactSyntheticEvent,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * listeners: Array&lt;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * instance: null | Fiber,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * listener: Function,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * currentTarget: EventTarget,</span></span></span></span><br><span class=\"line\"><span class=\"type\"><span class=\"doctag\"><span class=\"comment\"> * &#125;</span></span>&gt;&#125;&#125; dispatchQueue</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;EventSystemFlags&#125;</span> <span class=\"variable\">eventSystemFlags</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processDispatchQueue</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  dispatchQueue: DispatchQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dispatchQueue.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123; event: ReactSyntheticEvent,listeners: Array &lt; DispatchListener &gt;&#125;;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; event, listeners &#125; = dispatchQueue[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);</span><br><span class=\"line\">    <span class=\"comment\">//  event system doesn&#x27;t use pooling.</span></span><br><span class=\"line\">    <span class=\"comment\">// 事件系统不使用池。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// This would be a good time to rethrow if any of the event handlers threw.</span></span><br><span class=\"line\">  rethrowCaughtError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>processDispatchQueueItemsInOrder</li>\n</ul>\n<blockquote>\n<p>根据inCapturePhase判定是capture还是bubble,</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 执行事件队列，根据是否捕获确定事件的执行顺序</span></span><br><span class=\"line\"><span class=\"comment\"> * []dispatchListeners</span></span><br><span class=\"line\"><span class=\"comment\"> * 捕获：重最后一个到第一个</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡：重0到最后一个</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ReactSyntheticEvent&#125;</span> <span class=\"variable\">event</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Array&lt;DispatchListener&gt;&#125;</span> <span class=\"variable\">dispatchListeners</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;boolean&#125;</span> <span class=\"variable\">inCapturePhase</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processDispatchQueueItemsInOrder</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  event: ReactSyntheticEvent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  dispatchListeners: <span class=\"built_in\">Array</span>&lt;DispatchListener&gt;,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  inCapturePhase: <span class=\"built_in\">boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> previousInstance;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为添加dispatcher时是从当前然后return到null,所以捕获是倒过来的运行</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inCapturePhase) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = dispatchListeners.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123; instance: null | Fiber,listener: Function,currentTarget: EventTarget&#125;;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 阻止冒泡stopPropagation</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      executeDispatch(event, listener, currentTarget);</span><br><span class=\"line\">      previousInstance = instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      executeDispatch(event, listener, currentTarget);</span><br><span class=\"line\">      previousInstance = instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"executeDispatch\"><a href=\"#executeDispatch\" class=\"headerlink\" title=\"executeDispatch\"></a>executeDispatch</h2><ul>\n<li>最终调用用户的处理函数,其中包含一些react的invoke函数，以及一些在开发环境下的createEvent事件。</li>\n</ul>\n<blockquote>\n<p>本文还有许多细节没有提到，只是大致说明了事件系统的一个流程</p>\n</blockquote>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2>"},{"title":"svg基础","date":"2022-07-21T07:52:53.000Z","toc":true,"_content":"\n## 定义\n\nsvg（Scalable Vector Graphics）可缩放的矢量图形，是 W3C XML 的分支语言之一，用于标记可缩放的矢量图形。\n\n<!-- more -->\n\n## 命名空间\n\n定义的命名空间可以把通配、元素、属性选择器限制在指定命名空间里的元素。\n\n### 声明命名空间\n\n使用xmlns属性进行命名空间的声明，下面的声明意味着svg以及它的子节点都属于“http://www.w3.org/2000/svg”这个svg命名空间。\n\n```\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n\n</svg>\n```\n\n## SVG 元素\n\nSee more：[mdn-svg元素参考](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#svg_%E5%85%83%E7%B4%A0%EF%BC%88%E6%8C%89%E7%B1%BB%E5%88%AB%E5%88%86%E7%B1%BB%EF%BC%89)\n> 上面列出了一些常见以及常用的svg元素，下面我们可以来看看它们是什么样子的以及怎么改变它们的属性。\n\n## 图形元素\n\n### 基础图形元素\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/RwMVwNE?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/RwMVwNE\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n### 线段属性\n\n对于stroke填充的线段来说，stroke-dasharray与stroke-dashoffset是两个比较有用的属性。\n\n-   stroke-dasharray：控制用控制线段实线与虚线的单元长度。\n\n<!---->\n\n-   stroke-dasharray：控制虚线的偏移\n\n> stroke-dasharray结合animate的例子\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ZExoMmN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ZExoMmN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n> 使用stroke-dashoffset与animateTransform、animate绘制加载动画\n\n用animate控制stroke-dashoffset虚线部分的偏移，同时animateTransform控制整个圆环的自转。\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ExELqMa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ExELqMa\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n> 心电图\n\n这里主要思路就是使用polyline绘制折线图，使用stroke-dasharray绘制虚线，stroke-dashoffset控制虚线空白处的偏移，然后用animate控制stroke-dashoffset的值，就能看见这种线段移动的效果了🫥\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/qBoYyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/qBoYyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n### 强大的path元素\n\n上面的基本图形都是可以用path来创建的，而path的功能远远不止上面这些图形😏。path元素的形状通过属性d来定义，属性d的值是一个“命令+参数”的序列。下面就列出了一些常用的命令。\n\n#### 直线命令\n\n1.  Moveto\n\n    -  `M x,y` 在这里x和y是绝对坐标，分别代表水平坐标和垂直坐标。\n    -  `m dx,dy` 在这里dx和dy是相对于当前点的距离，分别是向右和向下的距离。\n\n<!---->\n\n2.  Lineto\n   `Lineto`指令将绘制一条直线段。这个直线段从当前位置移到指定位置\n    -   `Lx,y` x与y是绝对坐标，分别代表水平坐标和垂直坐标\n    -   `ldx,dy` dx和dy是相对于当前点的距离，分别是向右和向下的距离\n    -   `Hx` 绝对坐标，水平移动\n    -   `Vy` 绝对坐标，垂直移动\n    -   `hdx` 水平移动相对距离\n    -   `vdy` 垂直移动相对距离\n\n3.  Z or z：闭合路径\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/NWYjyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/NWYjyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n#### 曲线命令\n\n小写的指令意义同上，都是跟相对的距离\n\n1.  Curveto\n\n  -    C命令创建一个三次贝塞尔曲线，其中 (x1,y1) (x2,y2)为控制点，x,y为曲线终点\n  -  ` C x1 y1, x2 y2, x y  `or `c dx1 dy1, dx2 dy2, dx dy`\n\n<!---->\n\n2.  Smooth Curveto\n\n  -    S命令可以用来创建于与前面一样的贝塞尔曲线，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或者S命令，那当前点将作为第一个控制点。最大的作用就是光滑地连接两条曲线\n  -  `S x2 y2,x y` or `s dx2 dy2, dx dy`\n\n> C、S命令例子\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/rNdmJma?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/rNdmJma\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n3.  Quadratic Bézier curveto\n\n  -   Q命令用来创建一条二次贝塞尔曲线，只需要一个控制点\n  -   `Q x1 y1,x y` or `q dx1 dx2,dx dy`\n\n4.  Smooth quadratic Bézier curveto\n\n  -  T命令类似S命令，用于平滑链接二次贝塞尔曲线\n  -  ` T x1 y1  `or `t dx dy`\n\n> Q、T命令例子\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoRJaqN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/PoRJaqN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n5.  Arc\n\n-   A命令也可以用于绘制曲线\n    -   `A rx ry x-axis-rotation large-arc-flag sweep-flag x y` `a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy`\n    -     参数说明：\n    -     rx ry: x、y轴半径\n    -     X-axis-rotation: 绕x轴旋转角度\n    -     large-arc-flag：0-弧小于180度、1-弧大于180度\n    -     sweep-flag：0-逆时针画弧、1-顺时针画弧\n    -     x y：终点坐标\n\n## 动画\n\n> 放入形状元素内部，在指定的时间段里，设置相关属性的开始与结束值，变化曲线等。\n\n### 动画元素\n  -   animate：用来定义一个元素的某个属性在相应时间的变化\n  -   animateTransform：改变目标元素上的一个变形属性，控制旋转、缩放、平移、斜切变换\n  -   animateMotion：定义目标元素如何沿一个路径运动\n  -   discard：指定在何时丢弃特定元素，从而减少 SVG 用户代理所需的资源。\n  -   mpath：配合animateMotion，可代替animateMotion的path属性，用于引用一个外部的path\n  -   set：可以用来设定一个属性值，并为该值赋予一个持续时间。它支持所有的属性类型， 包括那些原理上不能插值的， 例如值为字符串和布尔类型的属性。 set 元素是非叠加的。无法在其上使用 additive 属性或 accumulate 属性，即使声明了这些属性也会自动被忽略。\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmrYLy?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmrYLy\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n### 动画属性\n\n这里大致可以分为三类：\n\n  1.  取值属性：控制要动画的属性（如x坐标，width等属性）的值\n\n    -  **calcMode：** 设置动画的变化曲线（discrete | linear | paced | spline），除了animateMotion默认是paced外，其他是默认linear，当一些不支持线性变化的属性值（string类型的）就会变为discrete。\n\n    -  **values：** 定义动画过程中的值序列（一个或多个值的分号分隔列表）的值。 如果指定了此属性，则将忽略在元素上设置的任何 `from`, `to`, 和 `by` 属性值。\n\n    -  **keyTimes：** 以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与`values`中的值一一对应，定义了`values`中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在 [0-1] 之间的浮点数，表示动画的完成时间。每一个连续的时间值必须大于等于前一个时间值。\n\n        -   对于 linear 和 spline动画，列表中的第一个时间值必须为 0，列表的最后一个时间值必须为 1。与每个 value 关联的时间值定义了何时设置该 value，该 value 在 keyTimes 的时间 值的中间插值。\n        -   对于 discrete动画，列表中的第一个值必须为 0。与每个 value 关联的时间值定义了何时设置该 value，动画函数使用该 value，直到 keyTimes 中定义的下一个时间值。\n        -   如果插值模式是 paced动画，keyTimes 属性被忽略。\n\n    -  **keySplines：** 定义了一组与 keyTimes 列表关联的 Bézier 曲线控制点，定义了一个控制间隔（keyTimes的值列表长度减1即为间隔数）的三次 Bézier 函数。只有spline动画才会有效。\n\n    -  **from：** 指定属性的开始值\n\n    -  **by：** 指定将在动画期间修改的属性的相对偏移值\n\n    -  **to：** 表示将在动画期间修改的属性的最终值\n\n  > 取值属性例子\n\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/WNzdXNZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/WNzdXNZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n  2.  时间属性：控制动画如何开始，何时开始、重复次数等\n\n    -  **begin：** 动画开始时间\n\n    -  **end：** 动画结束时间\n\n    -  **dur：** 动画持续时间\n\n    -  **min/max：** 限制动画的最小/大持续时间\n\n    -  **restart：** 控制动画是否可以重新开始\n\n        -   `always` ：任何时候都可重新开始\n        -   `whenNotActive` ：非动画时可重新开始\n        -   `never` ：任何时候都不能重新开始\n\n    -  **repeatCount：** 指定动画重复的次数、值必须大于 0。\n\n    -  **repeatDur：** 指定动画的重复时间\n\n    -  **fill：** 控制动画结束时的状态。有两个值可选\n\n        -   remove：在动画的激活持续时间结束后，动画效果会移除（不再应用）。在动画的激活结束后，动画不再对目标元素有影响（除非动画重新开始）。\n        -   freeze：在动画激活持续时间结束后，文档持续时间的剩余时间里（或者直到动画重新开始）动画效果会“冻结”着。（保持动画终态）\n\n  3.  目标属性：控制要动画的属性\n\n    -  **ttributeType：** 当attributeType=\"XML\"时，attributeName被认为是XML的属性；当attributeType=\"CSS\"时，attributeName被认为是css的属性；不指定attributeType时，默认为\"auto\"，会先将attributeName作为css的属性，如果无效，再将attributeName作为XML的属性。\n    -  **attributeName：** 要动画的属性名\n\n<!---->\n\n  4.  其他属性：additive、accumulate\n\n    -  **additive：** 控制动画属性是否是附加的。\n    -  **accumulate：** 在原来的结果的基础上重复动画的时候每一次循环都累加。这个属性告诉动画是否是每次循环，前一个动画属性值要加上去。需要设置from与to属性。\n\n  > additive、accumulate例子\n\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoREOjj?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/PoREOjj\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n## 结构元素\n\n> 结构元素关注的是复用\n\n-   **defs：** 定义一个复用的图形。在`defs`元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用 `use`元素呈现这些元素。\n\n<!---->\n\n-   **g：** 组合子元素的容器，g元素的属性会被其所有的子元素继承 。与`defs`相比，g定义的除了复用外，在定义时会进行渲染。\n\n<!---->\n\n-   **symbol：** 定义一个图形模版对象，使用`use`元素实例化。`symbol`元素对图形的作用是在同一文档中多次使用，添加结构和语义。symbol通过`use`调用时，` <use  ``/``>`可以设置height、width控制实际绘制的大小。\n\n<!---->\n\n-   **svg** **：** 如果 `svg` 不是根元素，`svg` 元素可以用于在当前文档（比如说，一个 HTML 文档）内嵌套一个独立的 svg 片段 。 这个独立片段拥有独立的视口和坐标系统。\n\n<!---->\n\n-   **marker：** 定义了在特定的path元素、line元素、polyline元素或者polygon元素上绘制箭头或者多边形标记图形。\n\n    -   refx：定义元素参考点的x坐标 (默认是0)\n    -   refy：定义元素参考点的y坐标 (默认是0)\n    -   markerWidth：表示根据 viewBox 和 preserveAspectRatio 属性渲染 `<marker>` 时要适合的视口宽度\n    -   markerHeight：表示根据 viewBox 和 preserveAspectRatio 属性渲染 ` <marker>  `时要适合的视口高度\n    -   markerUnits：指示标记放置在形状上的位置时如何旋转\n\n<!---->\n\n-   mask\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/GRxmgEN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/GRxmgEN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n## 滤镜元素\n\n### 相关标签\n\n> 滤镜通过`<filter>`在`<defs>`中进行定义，在filter标签中提供一系列图元，使用滤镜只需为svg元素设置filter属性即可。\n\n### 常见属性\n\n  in：标识输入的原语\n\n    -   SourceGraphic：该关键词表示图形元素自身将作为`<filter>`原语的原始输入\n    -   SourceAlpha：该关键词表示图形元素自身将作为`<filter>`原语的原始输入. SourceAlpha 与 SourceGraphic 具有相同的规则除了 SourceAlpha 只使用元素的透明度。\n    -   BackgroundImage：该关键词表示 filter 元素当前底下的区域的图形快照将被调用。\n    -   BackgroundAlpha：BackgroundImage 相同除了只使用透明度。\n    -   FillPaint：此关键字表示过滤效果的目标元素上的`fill`属性值。在许多情况下，FillPaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n    -   StrokePaint：此关键字表示滤镜效果的目标元素上的笔画属性的值。在许多情况下，StrokePaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n\n<!---->\n\n  in2：in2 属性标识给定filter原语的第二个输入。它的工作原理与 in 属性完全相同。\n\n\n> colorMatrix颜色矩阵变换\n\n```typescript\n/* R G B A 1 颜色矩阵计算 */\n 1 0 0 0 0 // R = 1*R + 0*G + 0*B + 0*A + 0 \n 0 1 0 0 0 // G = 0*R + 1*G + 0*B + 0*A + 0 \n 0 0 1 0 0 // B = 0*R + 0*G + 1*B + 0*A + 0 \n 0 0 0 1 0 // A = 0*R + 0*G + 0*B + 1*A + 0\n```\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/xxWzjde?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/xxWzjde\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n> 使用feGaussianBlur、feColorMatrix、feBlend实现粘稠效果\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLZbQO?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLZbQO\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n> 使用feComposite并设置operator为in，控制显示图像的一部分。\n\n关于feComposite，更多可以看这里：[feComposite](https://apike.ca/prog_svg_filter_feComposite.html)\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmXOwZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmXOwZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n> feDisplacementMap、feTurbulence\n\nfeDisplacementMap推荐看这篇：[深入理解SVG feDisplacementMap滤镜及实际应用](https://www.zhangxinxu.com/wordpress/2017/12/understand-svg-fedisplacementmap-filter/)\n\nfeTurbulence推荐看这篇：[说说SVG的feTurbulence滤镜](https://zhuanlan.zhihu.com/p/366438535)\n\n位置转换公式：\n\n`P'(x,y) ← P(x + scale * (XC(x,y) - 0.5), y + scale * (YC(x,y) - 0.5))`\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/OJvwJqV?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/OJvwJqV\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n## 渐变元素\n###   linearGradient：线性渐变\n  -   gradientUnits: 控制渐变坐标的单位\n  -   gradientTransform: 对渐变坐标系进行变换（translate、skew、rotate。。。）\n  -   x1：线性渐变起点x坐标-   y1：线性渐变起点y坐标\n  -   x2：线性渐变终点x坐标-   y2：线性渐变终点y坐标\n  -   spreadMethod：定义如何在渐变之外填充\n    -   pad：用渐变终点颜色去填充额外区域\n    -   repeat：按照开始的渐变顺序重复\n    -   reflect：按照开始的渐变相反顺序重复\n\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLMMjR?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLMMjR\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n###   radialGradient：径向渐变\n  -   gradientUnits：控制渐变坐标的单位\n  -   gradientTransform：对渐变坐标系进行变换（translate、skew、rotate。。。）\n  -   cx: 用来定义径向渐变终止圆的 x 轴坐标(默认50%)。\n  -   cy：用来定义径向渐变终止圆的 y 轴坐标。\n  -   r：用来定义径向渐变终止圆的半径。\n  -   fx：用来定义径向渐变的焦点的 x 轴坐标\n  -   fy：用来定义径向渐变的焦点的 y 轴坐标\n  -   spreadMethod：确定如何在渐变的定义边缘之外填充形状。\n    -   pad：用渐变终点颜色去填充额外区域\n    -   repeat：按照开始的渐变顺序重复\n    -   reflect：按照开始的渐变相反顺序重复\n  -   stop：渐变的颜色坡度\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"svg-radialgradient\" src=\"https://codepen.io/l-jour/embed/zYWWLBa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/zYWWLBa\">\n  svg-radialgradient</a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n## 关于svg与canvas\n  可以看看msdn的文章[如何为您的网站在Canvas和SVG之间做出选择](https://docs.microsoft.com/zh-cn/previous-versions/msdn10/Hh377884(v=MSDN.10))\n\n## 总结\n  svg的世界非常丰富，并且很多属性可以作用不同的元素、拥有不同的效果。元素直接有可以搭配使用，如多个动画，多个滤镜等等，滤镜元素还涉及更多领域知识。总之，元素种类、元素属性非常多，还是需要得慢慢地学习、阅读相关的案例并操作一下才能有所掌握。\n## Reference\n  -   [feComposite](https://apike.ca/prog_svg_filter_feComposite.html)\n  -   [贝塞尔曲线-wiki](https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A)\n\n","source":"_posts/svg基础.md","raw":"---\ntitle: svg基础\ndate: 2022-07-21 15:52:53\ntags:\ntoc: true\n---\n\n## 定义\n\nsvg（Scalable Vector Graphics）可缩放的矢量图形，是 W3C XML 的分支语言之一，用于标记可缩放的矢量图形。\n\n<!-- more -->\n\n## 命名空间\n\n定义的命名空间可以把通配、元素、属性选择器限制在指定命名空间里的元素。\n\n### 声明命名空间\n\n使用xmlns属性进行命名空间的声明，下面的声明意味着svg以及它的子节点都属于“http://www.w3.org/2000/svg”这个svg命名空间。\n\n```\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n\n</svg>\n```\n\n## SVG 元素\n\nSee more：[mdn-svg元素参考](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#svg_%E5%85%83%E7%B4%A0%EF%BC%88%E6%8C%89%E7%B1%BB%E5%88%AB%E5%88%86%E7%B1%BB%EF%BC%89)\n> 上面列出了一些常见以及常用的svg元素，下面我们可以来看看它们是什么样子的以及怎么改变它们的属性。\n\n## 图形元素\n\n### 基础图形元素\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/RwMVwNE?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/RwMVwNE\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n### 线段属性\n\n对于stroke填充的线段来说，stroke-dasharray与stroke-dashoffset是两个比较有用的属性。\n\n-   stroke-dasharray：控制用控制线段实线与虚线的单元长度。\n\n<!---->\n\n-   stroke-dasharray：控制虚线的偏移\n\n> stroke-dasharray结合animate的例子\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ZExoMmN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ZExoMmN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n> 使用stroke-dashoffset与animateTransform、animate绘制加载动画\n\n用animate控制stroke-dashoffset虚线部分的偏移，同时animateTransform控制整个圆环的自转。\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ExELqMa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ExELqMa\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n> 心电图\n\n这里主要思路就是使用polyline绘制折线图，使用stroke-dasharray绘制虚线，stroke-dashoffset控制虚线空白处的偏移，然后用animate控制stroke-dashoffset的值，就能看见这种线段移动的效果了🫥\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/qBoYyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/qBoYyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n### 强大的path元素\n\n上面的基本图形都是可以用path来创建的，而path的功能远远不止上面这些图形😏。path元素的形状通过属性d来定义，属性d的值是一个“命令+参数”的序列。下面就列出了一些常用的命令。\n\n#### 直线命令\n\n1.  Moveto\n\n    -  `M x,y` 在这里x和y是绝对坐标，分别代表水平坐标和垂直坐标。\n    -  `m dx,dy` 在这里dx和dy是相对于当前点的距离，分别是向右和向下的距离。\n\n<!---->\n\n2.  Lineto\n   `Lineto`指令将绘制一条直线段。这个直线段从当前位置移到指定位置\n    -   `Lx,y` x与y是绝对坐标，分别代表水平坐标和垂直坐标\n    -   `ldx,dy` dx和dy是相对于当前点的距离，分别是向右和向下的距离\n    -   `Hx` 绝对坐标，水平移动\n    -   `Vy` 绝对坐标，垂直移动\n    -   `hdx` 水平移动相对距离\n    -   `vdy` 垂直移动相对距离\n\n3.  Z or z：闭合路径\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/NWYjyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/NWYjyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n#### 曲线命令\n\n小写的指令意义同上，都是跟相对的距离\n\n1.  Curveto\n\n  -    C命令创建一个三次贝塞尔曲线，其中 (x1,y1) (x2,y2)为控制点，x,y为曲线终点\n  -  ` C x1 y1, x2 y2, x y  `or `c dx1 dy1, dx2 dy2, dx dy`\n\n<!---->\n\n2.  Smooth Curveto\n\n  -    S命令可以用来创建于与前面一样的贝塞尔曲线，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或者S命令，那当前点将作为第一个控制点。最大的作用就是光滑地连接两条曲线\n  -  `S x2 y2,x y` or `s dx2 dy2, dx dy`\n\n> C、S命令例子\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/rNdmJma?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/rNdmJma\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n3.  Quadratic Bézier curveto\n\n  -   Q命令用来创建一条二次贝塞尔曲线，只需要一个控制点\n  -   `Q x1 y1,x y` or `q dx1 dx2,dx dy`\n\n4.  Smooth quadratic Bézier curveto\n\n  -  T命令类似S命令，用于平滑链接二次贝塞尔曲线\n  -  ` T x1 y1  `or `t dx dy`\n\n> Q、T命令例子\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoRJaqN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/PoRJaqN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n5.  Arc\n\n-   A命令也可以用于绘制曲线\n    -   `A rx ry x-axis-rotation large-arc-flag sweep-flag x y` `a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy`\n    -     参数说明：\n    -     rx ry: x、y轴半径\n    -     X-axis-rotation: 绕x轴旋转角度\n    -     large-arc-flag：0-弧小于180度、1-弧大于180度\n    -     sweep-flag：0-逆时针画弧、1-顺时针画弧\n    -     x y：终点坐标\n\n## 动画\n\n> 放入形状元素内部，在指定的时间段里，设置相关属性的开始与结束值，变化曲线等。\n\n### 动画元素\n  -   animate：用来定义一个元素的某个属性在相应时间的变化\n  -   animateTransform：改变目标元素上的一个变形属性，控制旋转、缩放、平移、斜切变换\n  -   animateMotion：定义目标元素如何沿一个路径运动\n  -   discard：指定在何时丢弃特定元素，从而减少 SVG 用户代理所需的资源。\n  -   mpath：配合animateMotion，可代替animateMotion的path属性，用于引用一个外部的path\n  -   set：可以用来设定一个属性值，并为该值赋予一个持续时间。它支持所有的属性类型， 包括那些原理上不能插值的， 例如值为字符串和布尔类型的属性。 set 元素是非叠加的。无法在其上使用 additive 属性或 accumulate 属性，即使声明了这些属性也会自动被忽略。\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmrYLy?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmrYLy\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n### 动画属性\n\n这里大致可以分为三类：\n\n  1.  取值属性：控制要动画的属性（如x坐标，width等属性）的值\n\n    -  **calcMode：** 设置动画的变化曲线（discrete | linear | paced | spline），除了animateMotion默认是paced外，其他是默认linear，当一些不支持线性变化的属性值（string类型的）就会变为discrete。\n\n    -  **values：** 定义动画过程中的值序列（一个或多个值的分号分隔列表）的值。 如果指定了此属性，则将忽略在元素上设置的任何 `from`, `to`, 和 `by` 属性值。\n\n    -  **keyTimes：** 以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与`values`中的值一一对应，定义了`values`中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在 [0-1] 之间的浮点数，表示动画的完成时间。每一个连续的时间值必须大于等于前一个时间值。\n\n        -   对于 linear 和 spline动画，列表中的第一个时间值必须为 0，列表的最后一个时间值必须为 1。与每个 value 关联的时间值定义了何时设置该 value，该 value 在 keyTimes 的时间 值的中间插值。\n        -   对于 discrete动画，列表中的第一个值必须为 0。与每个 value 关联的时间值定义了何时设置该 value，动画函数使用该 value，直到 keyTimes 中定义的下一个时间值。\n        -   如果插值模式是 paced动画，keyTimes 属性被忽略。\n\n    -  **keySplines：** 定义了一组与 keyTimes 列表关联的 Bézier 曲线控制点，定义了一个控制间隔（keyTimes的值列表长度减1即为间隔数）的三次 Bézier 函数。只有spline动画才会有效。\n\n    -  **from：** 指定属性的开始值\n\n    -  **by：** 指定将在动画期间修改的属性的相对偏移值\n\n    -  **to：** 表示将在动画期间修改的属性的最终值\n\n  > 取值属性例子\n\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/WNzdXNZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/WNzdXNZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n  2.  时间属性：控制动画如何开始，何时开始、重复次数等\n\n    -  **begin：** 动画开始时间\n\n    -  **end：** 动画结束时间\n\n    -  **dur：** 动画持续时间\n\n    -  **min/max：** 限制动画的最小/大持续时间\n\n    -  **restart：** 控制动画是否可以重新开始\n\n        -   `always` ：任何时候都可重新开始\n        -   `whenNotActive` ：非动画时可重新开始\n        -   `never` ：任何时候都不能重新开始\n\n    -  **repeatCount：** 指定动画重复的次数、值必须大于 0。\n\n    -  **repeatDur：** 指定动画的重复时间\n\n    -  **fill：** 控制动画结束时的状态。有两个值可选\n\n        -   remove：在动画的激活持续时间结束后，动画效果会移除（不再应用）。在动画的激活结束后，动画不再对目标元素有影响（除非动画重新开始）。\n        -   freeze：在动画激活持续时间结束后，文档持续时间的剩余时间里（或者直到动画重新开始）动画效果会“冻结”着。（保持动画终态）\n\n  3.  目标属性：控制要动画的属性\n\n    -  **ttributeType：** 当attributeType=\"XML\"时，attributeName被认为是XML的属性；当attributeType=\"CSS\"时，attributeName被认为是css的属性；不指定attributeType时，默认为\"auto\"，会先将attributeName作为css的属性，如果无效，再将attributeName作为XML的属性。\n    -  **attributeName：** 要动画的属性名\n\n<!---->\n\n  4.  其他属性：additive、accumulate\n\n    -  **additive：** 控制动画属性是否是附加的。\n    -  **accumulate：** 在原来的结果的基础上重复动画的时候每一次循环都累加。这个属性告诉动画是否是每次循环，前一个动画属性值要加上去。需要设置from与to属性。\n\n  > additive、accumulate例子\n\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoREOjj?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/PoREOjj\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n## 结构元素\n\n> 结构元素关注的是复用\n\n-   **defs：** 定义一个复用的图形。在`defs`元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用 `use`元素呈现这些元素。\n\n<!---->\n\n-   **g：** 组合子元素的容器，g元素的属性会被其所有的子元素继承 。与`defs`相比，g定义的除了复用外，在定义时会进行渲染。\n\n<!---->\n\n-   **symbol：** 定义一个图形模版对象，使用`use`元素实例化。`symbol`元素对图形的作用是在同一文档中多次使用，添加结构和语义。symbol通过`use`调用时，` <use  ``/``>`可以设置height、width控制实际绘制的大小。\n\n<!---->\n\n-   **svg** **：** 如果 `svg` 不是根元素，`svg` 元素可以用于在当前文档（比如说，一个 HTML 文档）内嵌套一个独立的 svg 片段 。 这个独立片段拥有独立的视口和坐标系统。\n\n<!---->\n\n-   **marker：** 定义了在特定的path元素、line元素、polyline元素或者polygon元素上绘制箭头或者多边形标记图形。\n\n    -   refx：定义元素参考点的x坐标 (默认是0)\n    -   refy：定义元素参考点的y坐标 (默认是0)\n    -   markerWidth：表示根据 viewBox 和 preserveAspectRatio 属性渲染 `<marker>` 时要适合的视口宽度\n    -   markerHeight：表示根据 viewBox 和 preserveAspectRatio 属性渲染 ` <marker>  `时要适合的视口高度\n    -   markerUnits：指示标记放置在形状上的位置时如何旋转\n\n<!---->\n\n-   mask\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/GRxmgEN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/GRxmgEN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n## 滤镜元素\n\n### 相关标签\n\n> 滤镜通过`<filter>`在`<defs>`中进行定义，在filter标签中提供一系列图元，使用滤镜只需为svg元素设置filter属性即可。\n\n### 常见属性\n\n  in：标识输入的原语\n\n    -   SourceGraphic：该关键词表示图形元素自身将作为`<filter>`原语的原始输入\n    -   SourceAlpha：该关键词表示图形元素自身将作为`<filter>`原语的原始输入. SourceAlpha 与 SourceGraphic 具有相同的规则除了 SourceAlpha 只使用元素的透明度。\n    -   BackgroundImage：该关键词表示 filter 元素当前底下的区域的图形快照将被调用。\n    -   BackgroundAlpha：BackgroundImage 相同除了只使用透明度。\n    -   FillPaint：此关键字表示过滤效果的目标元素上的`fill`属性值。在许多情况下，FillPaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n    -   StrokePaint：此关键字表示滤镜效果的目标元素上的笔画属性的值。在许多情况下，StrokePaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n\n<!---->\n\n  in2：in2 属性标识给定filter原语的第二个输入。它的工作原理与 in 属性完全相同。\n\n\n> colorMatrix颜色矩阵变换\n\n```typescript\n/* R G B A 1 颜色矩阵计算 */\n 1 0 0 0 0 // R = 1*R + 0*G + 0*B + 0*A + 0 \n 0 1 0 0 0 // G = 0*R + 1*G + 0*B + 0*A + 0 \n 0 0 1 0 0 // B = 0*R + 0*G + 1*B + 0*A + 0 \n 0 0 0 1 0 // A = 0*R + 0*G + 0*B + 1*A + 0\n```\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/xxWzjde?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/xxWzjde\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n> 使用feGaussianBlur、feColorMatrix、feBlend实现粘稠效果\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLZbQO?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLZbQO\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n> 使用feComposite并设置operator为in，控制显示图像的一部分。\n\n关于feComposite，更多可以看这里：[feComposite](https://apike.ca/prog_svg_filter_feComposite.html)\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmXOwZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmXOwZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n> feDisplacementMap、feTurbulence\n\nfeDisplacementMap推荐看这篇：[深入理解SVG feDisplacementMap滤镜及实际应用](https://www.zhangxinxu.com/wordpress/2017/12/understand-svg-fedisplacementmap-filter/)\n\nfeTurbulence推荐看这篇：[说说SVG的feTurbulence滤镜](https://zhuanlan.zhihu.com/p/366438535)\n\n位置转换公式：\n\n`P'(x,y) ← P(x + scale * (XC(x,y) - 0.5), y + scale * (YC(x,y) - 0.5))`\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/OJvwJqV?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/OJvwJqV\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n## 渐变元素\n###   linearGradient：线性渐变\n  -   gradientUnits: 控制渐变坐标的单位\n  -   gradientTransform: 对渐变坐标系进行变换（translate、skew、rotate。。。）\n  -   x1：线性渐变起点x坐标-   y1：线性渐变起点y坐标\n  -   x2：线性渐变终点x坐标-   y2：线性渐变终点y坐标\n  -   spreadMethod：定义如何在渐变之外填充\n    -   pad：用渐变终点颜色去填充额外区域\n    -   repeat：按照开始的渐变顺序重复\n    -   reflect：按照开始的渐变相反顺序重复\n\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLMMjR?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLMMjR\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n###   radialGradient：径向渐变\n  -   gradientUnits：控制渐变坐标的单位\n  -   gradientTransform：对渐变坐标系进行变换（translate、skew、rotate。。。）\n  -   cx: 用来定义径向渐变终止圆的 x 轴坐标(默认50%)。\n  -   cy：用来定义径向渐变终止圆的 y 轴坐标。\n  -   r：用来定义径向渐变终止圆的半径。\n  -   fx：用来定义径向渐变的焦点的 x 轴坐标\n  -   fy：用来定义径向渐变的焦点的 y 轴坐标\n  -   spreadMethod：确定如何在渐变的定义边缘之外填充形状。\n    -   pad：用渐变终点颜色去填充额外区域\n    -   repeat：按照开始的渐变顺序重复\n    -   reflect：按照开始的渐变相反顺序重复\n  -   stop：渐变的颜色坡度\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"svg-radialgradient\" src=\"https://codepen.io/l-jour/embed/zYWWLBa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/zYWWLBa\">\n  svg-radialgradient</a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n## 关于svg与canvas\n  可以看看msdn的文章[如何为您的网站在Canvas和SVG之间做出选择](https://docs.microsoft.com/zh-cn/previous-versions/msdn10/Hh377884(v=MSDN.10))\n\n## 总结\n  svg的世界非常丰富，并且很多属性可以作用不同的元素、拥有不同的效果。元素直接有可以搭配使用，如多个动画，多个滤镜等等，滤镜元素还涉及更多领域知识。总之，元素种类、元素属性非常多，还是需要得慢慢地学习、阅读相关的案例并操作一下才能有所掌握。\n## Reference\n  -   [feComposite](https://apike.ca/prog_svg_filter_feComposite.html)\n  -   [贝塞尔曲线-wiki](https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A)\n\n","slug":"svg基础","published":1,"updated":"2022-12-31T10:26:33.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyl000og8v7gvi6cfcq","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>svg（Scalable Vector Graphics）可缩放的矢量图形，是 W3C XML 的分支语言之一，用于标记可缩放的矢量图形。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>定义的命名空间可以把通配、元素、属性选择器限制在指定命名空间里的元素。</p>\n<h3 id=\"声明命名空间\"><a href=\"#声明命名空间\" class=\"headerlink\" title=\"声明命名空间\"></a>声明命名空间</h3><p>使用xmlns属性进行命名空间的声明，下面的声明意味着svg以及它的子节点都属于“<a href=\"http://www.w3.org/2000/svg%E2%80%9D%E8%BF%99%E4%B8%AAsvg%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%82\">http://www.w3.org/2000/svg”这个svg命名空间。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SVG-元素\"><a href=\"#SVG-元素\" class=\"headerlink\" title=\"SVG 元素\"></a>SVG 元素</h2><p>See more：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#svg_%E5%85%83%E7%B4%A0%EF%BC%88%E6%8C%89%E7%B1%BB%E5%88%AB%E5%88%86%E7%B1%BB%EF%BC%89\">mdn-svg元素参考</a></p>\n<blockquote>\n<p>上面列出了一些常见以及常用的svg元素，下面我们可以来看看它们是什么样子的以及怎么改变它们的属性。</p>\n</blockquote>\n<h2 id=\"图形元素\"><a href=\"#图形元素\" class=\"headerlink\" title=\"图形元素\"></a>图形元素</h2><h3 id=\"基础图形元素\"><a href=\"#基础图形元素\" class=\"headerlink\" title=\"基础图形元素\"></a>基础图形元素</h3><iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/RwMVwNE?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/RwMVwNE\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h3 id=\"线段属性\"><a href=\"#线段属性\" class=\"headerlink\" title=\"线段属性\"></a>线段属性</h3><p>对于stroke填充的线段来说，stroke-dasharray与stroke-dashoffset是两个比较有用的属性。</p>\n<ul>\n<li>  stroke-dasharray：控制用控制线段实线与虚线的单元长度。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  stroke-dasharray：控制虚线的偏移</li>\n</ul>\n<blockquote>\n<p>stroke-dasharray结合animate的例子</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ZExoMmN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ZExoMmN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<blockquote>\n<p>使用stroke-dashoffset与animateTransform、animate绘制加载动画</p>\n</blockquote>\n<p>用animate控制stroke-dashoffset虚线部分的偏移，同时animateTransform控制整个圆环的自转。</p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ExELqMa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ExELqMa\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<blockquote>\n<p>心电图</p>\n</blockquote>\n<p>这里主要思路就是使用polyline绘制折线图，使用stroke-dasharray绘制虚线，stroke-dashoffset控制虚线空白处的偏移，然后用animate控制stroke-dashoffset的值，就能看见这种线段移动的效果了🫥</p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/qBoYyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/qBoYyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h3 id=\"强大的path元素\"><a href=\"#强大的path元素\" class=\"headerlink\" title=\"强大的path元素\"></a>强大的path元素</h3><p>上面的基本图形都是可以用path来创建的，而path的功能远远不止上面这些图形😏。path元素的形状通过属性d来定义，属性d的值是一个“命令+参数”的序列。下面就列出了一些常用的命令。</p>\n<h4 id=\"直线命令\"><a href=\"#直线命令\" class=\"headerlink\" title=\"直线命令\"></a>直线命令</h4><ol>\n<li><p>Moveto</p>\n<ul>\n<li> <code>M x,y</code> 在这里x和y是绝对坐标，分别代表水平坐标和垂直坐标。</li>\n<li> <code>m dx,dy</code> 在这里dx和dy是相对于当前点的距离，分别是向右和向下的距离。</li>\n</ul>\n</li>\n</ol>\n<!---->\n\n<ol start=\"2\">\n<li><p>Lineto<br><code>Lineto</code>指令将绘制一条直线段。这个直线段从当前位置移到指定位置</p>\n<ul>\n<li>  <code>Lx,y</code> x与y是绝对坐标，分别代表水平坐标和垂直坐标</li>\n<li>  <code>ldx,dy</code> dx和dy是相对于当前点的距离，分别是向右和向下的距离</li>\n<li>  <code>Hx</code> 绝对坐标，水平移动</li>\n<li>  <code>Vy</code> 绝对坐标，垂直移动</li>\n<li>  <code>hdx</code> 水平移动相对距离</li>\n<li>  <code>vdy</code> 垂直移动相对距离</li>\n</ul>\n</li>\n<li><p> Z or z：闭合路径</p>\n</li>\n</ol>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/NWYjyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/NWYjyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h4 id=\"曲线命令\"><a href=\"#曲线命令\" class=\"headerlink\" title=\"曲线命令\"></a>曲线命令</h4><p>小写的指令意义同上，都是跟相对的距离</p>\n<ol>\n<li> Curveto</li>\n</ol>\n<ul>\n<li>   C命令创建一个三次贝塞尔曲线，其中 (x1,y1) (x2,y2)为控制点，x,y为曲线终点</li>\n<li> <code>C x1 y1, x2 y2, x y </code>or <code>c dx1 dy1, dx2 dy2, dx dy</code></li>\n</ul>\n<!---->\n\n<ol start=\"2\">\n<li> Smooth Curveto</li>\n</ol>\n<ul>\n<li>   S命令可以用来创建于与前面一样的贝塞尔曲线，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或者S命令，那当前点将作为第一个控制点。最大的作用就是光滑地连接两条曲线</li>\n<li> <code>S x2 y2,x y</code> or <code>s dx2 dy2, dx dy</code></li>\n</ul>\n<blockquote>\n<p>C、S命令例子</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/rNdmJma?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/rNdmJma\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<ol start=\"3\">\n<li> Quadratic Bézier curveto</li>\n</ol>\n<ul>\n<li>  Q命令用来创建一条二次贝塞尔曲线，只需要一个控制点</li>\n<li>  <code>Q x1 y1,x y</code> or <code>q dx1 dx2,dx dy</code></li>\n</ul>\n<ol start=\"4\">\n<li> Smooth quadratic Bézier curveto</li>\n</ol>\n<ul>\n<li> T命令类似S命令，用于平滑链接二次贝塞尔曲线</li>\n<li> <code>T x1 y1 </code>or <code>t dx dy</code></li>\n</ul>\n<blockquote>\n<p>Q、T命令例子</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoRJaqN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/PoRJaqN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<ol start=\"5\">\n<li> Arc</li>\n</ol>\n<ul>\n<li>A命令也可以用于绘制曲线<ul>\n<li>  <code>A rx ry x-axis-rotation large-arc-flag sweep-flag x y</code> <code>a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</code></li>\n<li>    参数说明：</li>\n<li>    rx ry: x、y轴半径</li>\n<li>    X-axis-rotation: 绕x轴旋转角度</li>\n<li>    large-arc-flag：0-弧小于180度、1-弧大于180度</li>\n<li>    sweep-flag：0-逆时针画弧、1-顺时针画弧</li>\n<li>    x y：终点坐标</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><blockquote>\n<p>放入形状元素内部，在指定的时间段里，设置相关属性的开始与结束值，变化曲线等。</p>\n</blockquote>\n<h3 id=\"动画元素\"><a href=\"#动画元素\" class=\"headerlink\" title=\"动画元素\"></a>动画元素</h3><ul>\n<li>  animate：用来定义一个元素的某个属性在相应时间的变化</li>\n<li>  animateTransform：改变目标元素上的一个变形属性，控制旋转、缩放、平移、斜切变换</li>\n<li>  animateMotion：定义目标元素如何沿一个路径运动</li>\n<li>  discard：指定在何时丢弃特定元素，从而减少 SVG 用户代理所需的资源。</li>\n<li>  mpath：配合animateMotion，可代替animateMotion的path属性，用于引用一个外部的path</li>\n<li>  set：可以用来设定一个属性值，并为该值赋予一个持续时间。它支持所有的属性类型， 包括那些原理上不能插值的， 例如值为字符串和布尔类型的属性。 set 元素是非叠加的。无法在其上使用 additive 属性或 accumulate 属性，即使声明了这些属性也会自动被忽略。</li>\n</ul>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmrYLy?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmrYLy\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h3 id=\"动画属性\"><a href=\"#动画属性\" class=\"headerlink\" title=\"动画属性\"></a>动画属性</h3><p>这里大致可以分为三类：</p>\n<ol>\n<li> 取值属性：控制要动画的属性（如x坐标，width等属性）的值</li>\n</ol>\n<pre><code>-  **calcMode：** 设置动画的变化曲线（discrete | linear | paced | spline），除了animateMotion默认是paced外，其他是默认linear，当一些不支持线性变化的属性值（string类型的）就会变为discrete。\n\n-  **values：** 定义动画过程中的值序列（一个或多个值的分号分隔列表）的值。 如果指定了此属性，则将忽略在元素上设置的任何 `from`, `to`, 和 `by` 属性值。\n\n-  **keyTimes：** 以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与`values`中的值一一对应，定义了`values`中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在 [0-1] 之间的浮点数，表示动画的完成时间。每一个连续的时间值必须大于等于前一个时间值。\n\n    -   对于 linear 和 spline动画，列表中的第一个时间值必须为 0，列表的最后一个时间值必须为 1。与每个 value 关联的时间值定义了何时设置该 value，该 value 在 keyTimes 的时间 值的中间插值。\n    -   对于 discrete动画，列表中的第一个值必须为 0。与每个 value 关联的时间值定义了何时设置该 value，动画函数使用该 value，直到 keyTimes 中定义的下一个时间值。\n    -   如果插值模式是 paced动画，keyTimes 属性被忽略。\n\n-  **keySplines：** 定义了一组与 keyTimes 列表关联的 Bézier 曲线控制点，定义了一个控制间隔（keyTimes的值列表长度减1即为间隔数）的三次 Bézier 函数。只有spline动画才会有效。\n\n-  **from：** 指定属性的开始值\n\n-  **by：** 指定将在动画期间修改的属性的相对偏移值\n\n-  **to：** 表示将在动画期间修改的属性的最终值\n</code></pre>\n<blockquote>\n<p>取值属性例子</p>\n</blockquote>\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/WNzdXNZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/WNzdXNZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n<ol start=\"2\">\n<li> 时间属性：控制动画如何开始，何时开始、重复次数等</li>\n</ol>\n<pre><code>-  **begin：** 动画开始时间\n\n-  **end：** 动画结束时间\n\n-  **dur：** 动画持续时间\n\n-  **min/max：** 限制动画的最小/大持续时间\n\n-  **restart：** 控制动画是否可以重新开始\n\n    -   `always` ：任何时候都可重新开始\n    -   `whenNotActive` ：非动画时可重新开始\n    -   `never` ：任何时候都不能重新开始\n\n-  **repeatCount：** 指定动画重复的次数、值必须大于 0。\n\n-  **repeatDur：** 指定动画的重复时间\n\n-  **fill：** 控制动画结束时的状态。有两个值可选\n\n    -   remove：在动画的激活持续时间结束后，动画效果会移除（不再应用）。在动画的激活结束后，动画不再对目标元素有影响（除非动画重新开始）。\n    -   freeze：在动画激活持续时间结束后，文档持续时间的剩余时间里（或者直到动画重新开始）动画效果会“冻结”着。（保持动画终态）\n</code></pre>\n<ol start=\"3\">\n<li> 目标属性：控制要动画的属性</li>\n</ol>\n<pre><code>-  **ttributeType：** 当attributeType=&quot;XML&quot;时，attributeName被认为是XML的属性；当attributeType=&quot;CSS&quot;时，attributeName被认为是css的属性；不指定attributeType时，默认为&quot;auto&quot;，会先将attributeName作为css的属性，如果无效，再将attributeName作为XML的属性。\n-  **attributeName：** 要动画的属性名\n</code></pre>\n<!---->\n\n<ol start=\"4\">\n<li> 其他属性：additive、accumulate</li>\n</ol>\n<pre><code>-  **additive：** 控制动画属性是否是附加的。\n-  **accumulate：** 在原来的结果的基础上重复动画的时候每一次循环都累加。这个属性告诉动画是否是每次循环，前一个动画属性值要加上去。需要设置from与to属性。\n</code></pre>\n<blockquote>\n<p>additive、accumulate例子</p>\n</blockquote>\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoREOjj?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/PoREOjj\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n<h2 id=\"结构元素\"><a href=\"#结构元素\" class=\"headerlink\" title=\"结构元素\"></a>结构元素</h2><blockquote>\n<p>结构元素关注的是复用</p>\n</blockquote>\n<ul>\n<li>  <strong>defs：</strong> 定义一个复用的图形。在<code>defs</code>元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用 <code>use</code>元素呈现这些元素。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  <strong>g：</strong> 组合子元素的容器，g元素的属性会被其所有的子元素继承 。与<code>defs</code>相比，g定义的除了复用外，在定义时会进行渲染。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  <strong>symbol：</strong> 定义一个图形模版对象，使用<code>use</code>元素实例化。<code>symbol</code>元素对图形的作用是在同一文档中多次使用，添加结构和语义。symbol通过<code>use</code>调用时，<code> &lt;use  ``/``&gt;</code>可以设置height、width控制实际绘制的大小。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  <strong>svg</strong> <strong>：</strong> 如果 <code>svg</code> 不是根元素，<code>svg</code> 元素可以用于在当前文档（比如说，一个 HTML 文档）内嵌套一个独立的 svg 片段 。 这个独立片段拥有独立的视口和坐标系统。</li>\n</ul>\n<!---->\n\n<ul>\n<li><p><strong>marker：</strong> 定义了在特定的path元素、line元素、polyline元素或者polygon元素上绘制箭头或者多边形标记图形。</p>\n<ul>\n<li>  refx：定义元素参考点的x坐标 (默认是0)</li>\n<li>  refy：定义元素参考点的y坐标 (默认是0)</li>\n<li>  markerWidth：表示根据 viewBox 和 preserveAspectRatio 属性渲染 <code>&lt;marker&gt;</code> 时要适合的视口宽度</li>\n<li>  markerHeight：表示根据 viewBox 和 preserveAspectRatio 属性渲染 <code>&lt;marker&gt; </code>时要适合的视口高度</li>\n<li>  markerUnits：指示标记放置在形状上的位置时如何旋转</li>\n</ul>\n</li>\n</ul>\n<!---->\n\n<ul>\n<li>  mask</li>\n</ul>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/GRxmgEN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/GRxmgEN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h2 id=\"滤镜元素\"><a href=\"#滤镜元素\" class=\"headerlink\" title=\"滤镜元素\"></a>滤镜元素</h2><h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><blockquote>\n<p>滤镜通过<code>&lt;filter&gt;</code>在<code>&lt;defs&gt;</code>中进行定义，在filter标签中提供一系列图元，使用滤镜只需为svg元素设置filter属性即可。</p>\n</blockquote>\n<h3 id=\"常见属性\"><a href=\"#常见属性\" class=\"headerlink\" title=\"常见属性\"></a>常见属性</h3><p>  in：标识输入的原语</p>\n<pre><code>-   SourceGraphic：该关键词表示图形元素自身将作为`&lt;filter&gt;`原语的原始输入\n-   SourceAlpha：该关键词表示图形元素自身将作为`&lt;filter&gt;`原语的原始输入. SourceAlpha 与 SourceGraphic 具有相同的规则除了 SourceAlpha 只使用元素的透明度。\n-   BackgroundImage：该关键词表示 filter 元素当前底下的区域的图形快照将被调用。\n-   BackgroundAlpha：BackgroundImage 相同除了只使用透明度。\n-   FillPaint：此关键字表示过滤效果的目标元素上的`fill`属性值。在许多情况下，FillPaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n-   StrokePaint：此关键字表示滤镜效果的目标元素上的笔画属性的值。在许多情况下，StrokePaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n</code></pre>\n<!---->\n\n<p>  in2：in2 属性标识给定filter原语的第二个输入。它的工作原理与 in 属性完全相同。</p>\n<blockquote>\n<p>colorMatrix颜色矩阵变换</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* R G B A 1 颜色矩阵计算 */</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"comment\">// R = 1*R + 0*G + 0*B + 0*A + 0 </span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"comment\">// G = 0*R + 1*G + 0*B + 0*A + 0 </span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"comment\">// B = 0*R + 0*G + 1*B + 0*A + 0 </span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"comment\">// A = 0*R + 0*G + 0*B + 1*A + 0</span></span><br></pre></td></tr></table></figure>\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/xxWzjde?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/xxWzjde\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n<blockquote>\n<p>使用feGaussianBlur、feColorMatrix、feBlend实现粘稠效果</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLZbQO?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLZbQO\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n<blockquote>\n<p>使用feComposite并设置operator为in，控制显示图像的一部分。</p>\n</blockquote>\n<p>关于feComposite，更多可以看这里：<a href=\"https://apike.ca/prog_svg_filter_feComposite.html\">feComposite</a></p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmXOwZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmXOwZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n<blockquote>\n<p>feDisplacementMap、feTurbulence</p>\n</blockquote>\n<p>feDisplacementMap推荐看这篇：<a href=\"https://www.zhangxinxu.com/wordpress/2017/12/understand-svg-fedisplacementmap-filter/\">深入理解SVG feDisplacementMap滤镜及实际应用</a></p>\n<p>feTurbulence推荐看这篇：<a href=\"https://zhuanlan.zhihu.com/p/366438535\">说说SVG的feTurbulence滤镜</a></p>\n<p>位置转换公式：</p>\n<p><code>P&#39;(x,y) ← P(x + scale * (XC(x,y) - 0.5), y + scale * (YC(x,y) - 0.5))</code></p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/OJvwJqV?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/OJvwJqV\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h2 id=\"渐变元素\"><a href=\"#渐变元素\" class=\"headerlink\" title=\"渐变元素\"></a>渐变元素</h2><h3 id=\"linearGradient：线性渐变\"><a href=\"#linearGradient：线性渐变\" class=\"headerlink\" title=\"linearGradient：线性渐变\"></a>linearGradient：线性渐变</h3><ul>\n<li>  gradientUnits: 控制渐变坐标的单位</li>\n<li>  gradientTransform: 对渐变坐标系进行变换（translate、skew、rotate。。。）</li>\n<li>  x1：线性渐变起点x坐标-   y1：线性渐变起点y坐标</li>\n<li>  x2：线性渐变终点x坐标-   y2：线性渐变终点y坐标</li>\n<li>  spreadMethod：定义如何在渐变之外填充    -   pad：用渐变终点颜色去填充额外区域    -   repeat：按照开始的渐变顺序重复    -   reflect：按照开始的渐变相反顺序重复</li>\n</ul>\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLMMjR?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLMMjR\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n<h3 id=\"radialGradient：径向渐变\"><a href=\"#radialGradient：径向渐变\" class=\"headerlink\" title=\"radialGradient：径向渐变\"></a>radialGradient：径向渐变</h3><ul>\n<li>  gradientUnits：控制渐变坐标的单位</li>\n<li>  gradientTransform：对渐变坐标系进行变换（translate、skew、rotate。。。）</li>\n<li>  cx: 用来定义径向渐变终止圆的 x 轴坐标(默认50%)。</li>\n<li>  cy：用来定义径向渐变终止圆的 y 轴坐标。</li>\n<li>  r：用来定义径向渐变终止圆的半径。</li>\n<li>  fx：用来定义径向渐变的焦点的 x 轴坐标</li>\n<li>  fy：用来定义径向渐变的焦点的 y 轴坐标</li>\n<li>  spreadMethod：确定如何在渐变的定义边缘之外填充形状。    -   pad：用渐变终点颜色去填充额外区域    -   repeat：按照开始的渐变顺序重复    -   reflect：按照开始的渐变相反顺序重复</li>\n<li>  stop：渐变的颜色坡度</li>\n</ul>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"svg-radialgradient\" src=\"https://codepen.io/l-jour/embed/zYWWLBa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/zYWWLBa\">\n  svg-radialgradient</a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h2 id=\"关于svg与canvas\"><a href=\"#关于svg与canvas\" class=\"headerlink\" title=\"关于svg与canvas\"></a>关于svg与canvas</h2><p>  可以看看msdn的文章<a href=\"https://docs.microsoft.com/zh-cn/previous-versions/msdn10/Hh377884(v=MSDN.10)\">如何为您的网站在Canvas和SVG之间做出选择</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>  svg的世界非常丰富，并且很多属性可以作用不同的元素、拥有不同的效果。元素直接有可以搭配使用，如多个动画，多个滤镜等等，滤镜元素还涉及更多领域知识。总之，元素种类、元素属性非常多，还是需要得慢慢地学习、阅读相关的案例并操作一下才能有所掌握。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li>  <a href=\"https://apike.ca/prog_svg_filter_feComposite.html\">feComposite</a></li>\n<li>  <a href=\"https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A\">贝塞尔曲线-wiki</a></li>\n</ul>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":6733,"excerpt":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>svg（Scalable Vector Graphics）可缩放的矢量图形，是 W3C XML 的分支语言之一，用于标记可缩放的矢量图形。</p>","more":"<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>定义的命名空间可以把通配、元素、属性选择器限制在指定命名空间里的元素。</p>\n<h3 id=\"声明命名空间\"><a href=\"#声明命名空间\" class=\"headerlink\" title=\"声明命名空间\"></a>声明命名空间</h3><p>使用xmlns属性进行命名空间的声明，下面的声明意味着svg以及它的子节点都属于“<a href=\"http://www.w3.org/2000/svg%E2%80%9D%E8%BF%99%E4%B8%AAsvg%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%82\">http://www.w3.org/2000/svg”这个svg命名空间。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SVG-元素\"><a href=\"#SVG-元素\" class=\"headerlink\" title=\"SVG 元素\"></a>SVG 元素</h2><p>See more：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#svg_%E5%85%83%E7%B4%A0%EF%BC%88%E6%8C%89%E7%B1%BB%E5%88%AB%E5%88%86%E7%B1%BB%EF%BC%89\">mdn-svg元素参考</a></p>\n<blockquote>\n<p>上面列出了一些常见以及常用的svg元素，下面我们可以来看看它们是什么样子的以及怎么改变它们的属性。</p>\n</blockquote>\n<h2 id=\"图形元素\"><a href=\"#图形元素\" class=\"headerlink\" title=\"图形元素\"></a>图形元素</h2><h3 id=\"基础图形元素\"><a href=\"#基础图形元素\" class=\"headerlink\" title=\"基础图形元素\"></a>基础图形元素</h3><iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/RwMVwNE?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/RwMVwNE\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h3 id=\"线段属性\"><a href=\"#线段属性\" class=\"headerlink\" title=\"线段属性\"></a>线段属性</h3><p>对于stroke填充的线段来说，stroke-dasharray与stroke-dashoffset是两个比较有用的属性。</p>\n<ul>\n<li>  stroke-dasharray：控制用控制线段实线与虚线的单元长度。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  stroke-dasharray：控制虚线的偏移</li>\n</ul>\n<blockquote>\n<p>stroke-dasharray结合animate的例子</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ZExoMmN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ZExoMmN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<blockquote>\n<p>使用stroke-dashoffset与animateTransform、animate绘制加载动画</p>\n</blockquote>\n<p>用animate控制stroke-dashoffset虚线部分的偏移，同时animateTransform控制整个圆环的自转。</p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/ExELqMa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/ExELqMa\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<blockquote>\n<p>心电图</p>\n</blockquote>\n<p>这里主要思路就是使用polyline绘制折线图，使用stroke-dasharray绘制虚线，stroke-dashoffset控制虚线空白处的偏移，然后用animate控制stroke-dashoffset的值，就能看见这种线段移动的效果了🫥</p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/qBoYyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/qBoYyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h3 id=\"强大的path元素\"><a href=\"#强大的path元素\" class=\"headerlink\" title=\"强大的path元素\"></a>强大的path元素</h3><p>上面的基本图形都是可以用path来创建的，而path的功能远远不止上面这些图形😏。path元素的形状通过属性d来定义，属性d的值是一个“命令+参数”的序列。下面就列出了一些常用的命令。</p>\n<h4 id=\"直线命令\"><a href=\"#直线命令\" class=\"headerlink\" title=\"直线命令\"></a>直线命令</h4><ol>\n<li><p>Moveto</p>\n<ul>\n<li> <code>M x,y</code> 在这里x和y是绝对坐标，分别代表水平坐标和垂直坐标。</li>\n<li> <code>m dx,dy</code> 在这里dx和dy是相对于当前点的距离，分别是向右和向下的距离。</li>\n</ul>\n</li>\n</ol>\n<!---->\n\n<ol start=\"2\">\n<li><p>Lineto<br><code>Lineto</code>指令将绘制一条直线段。这个直线段从当前位置移到指定位置</p>\n<ul>\n<li>  <code>Lx,y</code> x与y是绝对坐标，分别代表水平坐标和垂直坐标</li>\n<li>  <code>ldx,dy</code> dx和dy是相对于当前点的距离，分别是向右和向下的距离</li>\n<li>  <code>Hx</code> 绝对坐标，水平移动</li>\n<li>  <code>Vy</code> 绝对坐标，垂直移动</li>\n<li>  <code>hdx</code> 水平移动相对距离</li>\n<li>  <code>vdy</code> 垂直移动相对距离</li>\n</ul>\n</li>\n<li><p> Z or z：闭合路径</p>\n</li>\n</ol>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/NWYjyxL?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/NWYjyxL\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h4 id=\"曲线命令\"><a href=\"#曲线命令\" class=\"headerlink\" title=\"曲线命令\"></a>曲线命令</h4><p>小写的指令意义同上，都是跟相对的距离</p>\n<ol>\n<li> Curveto</li>\n</ol>\n<ul>\n<li>   C命令创建一个三次贝塞尔曲线，其中 (x1,y1) (x2,y2)为控制点，x,y为曲线终点</li>\n<li> <code>C x1 y1, x2 y2, x y </code>or <code>c dx1 dy1, dx2 dy2, dx dy</code></li>\n</ul>\n<!---->\n\n<ol start=\"2\">\n<li> Smooth Curveto</li>\n</ol>\n<ul>\n<li>   S命令可以用来创建于与前面一样的贝塞尔曲线，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或者S命令，那当前点将作为第一个控制点。最大的作用就是光滑地连接两条曲线</li>\n<li> <code>S x2 y2,x y</code> or <code>s dx2 dy2, dx dy</code></li>\n</ul>\n<blockquote>\n<p>C、S命令例子</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/rNdmJma?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/rNdmJma\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<ol start=\"3\">\n<li> Quadratic Bézier curveto</li>\n</ol>\n<ul>\n<li>  Q命令用来创建一条二次贝塞尔曲线，只需要一个控制点</li>\n<li>  <code>Q x1 y1,x y</code> or <code>q dx1 dx2,dx dy</code></li>\n</ul>\n<ol start=\"4\">\n<li> Smooth quadratic Bézier curveto</li>\n</ol>\n<ul>\n<li> T命令类似S命令，用于平滑链接二次贝塞尔曲线</li>\n<li> <code>T x1 y1 </code>or <code>t dx dy</code></li>\n</ul>\n<blockquote>\n<p>Q、T命令例子</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoRJaqN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/PoRJaqN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<ol start=\"5\">\n<li> Arc</li>\n</ol>\n<ul>\n<li>A命令也可以用于绘制曲线<ul>\n<li>  <code>A rx ry x-axis-rotation large-arc-flag sweep-flag x y</code> <code>a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</code></li>\n<li>    参数说明：</li>\n<li>    rx ry: x、y轴半径</li>\n<li>    X-axis-rotation: 绕x轴旋转角度</li>\n<li>    large-arc-flag：0-弧小于180度、1-弧大于180度</li>\n<li>    sweep-flag：0-逆时针画弧、1-顺时针画弧</li>\n<li>    x y：终点坐标</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><blockquote>\n<p>放入形状元素内部，在指定的时间段里，设置相关属性的开始与结束值，变化曲线等。</p>\n</blockquote>\n<h3 id=\"动画元素\"><a href=\"#动画元素\" class=\"headerlink\" title=\"动画元素\"></a>动画元素</h3><ul>\n<li>  animate：用来定义一个元素的某个属性在相应时间的变化</li>\n<li>  animateTransform：改变目标元素上的一个变形属性，控制旋转、缩放、平移、斜切变换</li>\n<li>  animateMotion：定义目标元素如何沿一个路径运动</li>\n<li>  discard：指定在何时丢弃特定元素，从而减少 SVG 用户代理所需的资源。</li>\n<li>  mpath：配合animateMotion，可代替animateMotion的path属性，用于引用一个外部的path</li>\n<li>  set：可以用来设定一个属性值，并为该值赋予一个持续时间。它支持所有的属性类型， 包括那些原理上不能插值的， 例如值为字符串和布尔类型的属性。 set 元素是非叠加的。无法在其上使用 additive 属性或 accumulate 属性，即使声明了这些属性也会自动被忽略。</li>\n</ul>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmrYLy?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmrYLy\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h3 id=\"动画属性\"><a href=\"#动画属性\" class=\"headerlink\" title=\"动画属性\"></a>动画属性</h3><p>这里大致可以分为三类：</p>\n<ol>\n<li> 取值属性：控制要动画的属性（如x坐标，width等属性）的值</li>\n</ol>\n<pre><code>-  **calcMode：** 设置动画的变化曲线（discrete | linear | paced | spline），除了animateMotion默认是paced外，其他是默认linear，当一些不支持线性变化的属性值（string类型的）就会变为discrete。\n\n-  **values：** 定义动画过程中的值序列（一个或多个值的分号分隔列表）的值。 如果指定了此属性，则将忽略在元素上设置的任何 `from`, `to`, 和 `by` 属性值。\n\n-  **keyTimes：** 以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与`values`中的值一一对应，定义了`values`中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在 [0-1] 之间的浮点数，表示动画的完成时间。每一个连续的时间值必须大于等于前一个时间值。\n\n    -   对于 linear 和 spline动画，列表中的第一个时间值必须为 0，列表的最后一个时间值必须为 1。与每个 value 关联的时间值定义了何时设置该 value，该 value 在 keyTimes 的时间 值的中间插值。\n    -   对于 discrete动画，列表中的第一个值必须为 0。与每个 value 关联的时间值定义了何时设置该 value，动画函数使用该 value，直到 keyTimes 中定义的下一个时间值。\n    -   如果插值模式是 paced动画，keyTimes 属性被忽略。\n\n-  **keySplines：** 定义了一组与 keyTimes 列表关联的 Bézier 曲线控制点，定义了一个控制间隔（keyTimes的值列表长度减1即为间隔数）的三次 Bézier 函数。只有spline动画才会有效。\n\n-  **from：** 指定属性的开始值\n\n-  **by：** 指定将在动画期间修改的属性的相对偏移值\n\n-  **to：** 表示将在动画期间修改的属性的最终值\n</code></pre>\n<blockquote>\n<p>取值属性例子</p>\n</blockquote>\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/WNzdXNZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/WNzdXNZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n<ol start=\"2\">\n<li> 时间属性：控制动画如何开始，何时开始、重复次数等</li>\n</ol>\n<pre><code>-  **begin：** 动画开始时间\n\n-  **end：** 动画结束时间\n\n-  **dur：** 动画持续时间\n\n-  **min/max：** 限制动画的最小/大持续时间\n\n-  **restart：** 控制动画是否可以重新开始\n\n    -   `always` ：任何时候都可重新开始\n    -   `whenNotActive` ：非动画时可重新开始\n    -   `never` ：任何时候都不能重新开始\n\n-  **repeatCount：** 指定动画重复的次数、值必须大于 0。\n\n-  **repeatDur：** 指定动画的重复时间\n\n-  **fill：** 控制动画结束时的状态。有两个值可选\n\n    -   remove：在动画的激活持续时间结束后，动画效果会移除（不再应用）。在动画的激活结束后，动画不再对目标元素有影响（除非动画重新开始）。\n    -   freeze：在动画激活持续时间结束后，文档持续时间的剩余时间里（或者直到动画重新开始）动画效果会“冻结”着。（保持动画终态）\n</code></pre>\n<ol start=\"3\">\n<li> 目标属性：控制要动画的属性</li>\n</ol>\n<pre><code>-  **ttributeType：** 当attributeType=&quot;XML&quot;时，attributeName被认为是XML的属性；当attributeType=&quot;CSS&quot;时，attributeName被认为是css的属性；不指定attributeType时，默认为&quot;auto&quot;，会先将attributeName作为css的属性，如果无效，再将attributeName作为XML的属性。\n-  **attributeName：** 要动画的属性名\n</code></pre>\n<!---->\n\n<ol start=\"4\">\n<li> 其他属性：additive、accumulate</li>\n</ol>\n<pre><code>-  **additive：** 控制动画属性是否是附加的。\n-  **accumulate：** 在原来的结果的基础上重复动画的时候每一次循环都累加。这个属性告诉动画是否是每次循环，前一个动画属性值要加上去。需要设置from与to属性。\n</code></pre>\n<blockquote>\n<p>additive、accumulate例子</p>\n</blockquote>\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/PoREOjj?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/PoREOjj\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n<h2 id=\"结构元素\"><a href=\"#结构元素\" class=\"headerlink\" title=\"结构元素\"></a>结构元素</h2><blockquote>\n<p>结构元素关注的是复用</p>\n</blockquote>\n<ul>\n<li>  <strong>defs：</strong> 定义一个复用的图形。在<code>defs</code>元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用 <code>use</code>元素呈现这些元素。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  <strong>g：</strong> 组合子元素的容器，g元素的属性会被其所有的子元素继承 。与<code>defs</code>相比，g定义的除了复用外，在定义时会进行渲染。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  <strong>symbol：</strong> 定义一个图形模版对象，使用<code>use</code>元素实例化。<code>symbol</code>元素对图形的作用是在同一文档中多次使用，添加结构和语义。symbol通过<code>use</code>调用时，<code> &lt;use  ``/``&gt;</code>可以设置height、width控制实际绘制的大小。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  <strong>svg</strong> <strong>：</strong> 如果 <code>svg</code> 不是根元素，<code>svg</code> 元素可以用于在当前文档（比如说，一个 HTML 文档）内嵌套一个独立的 svg 片段 。 这个独立片段拥有独立的视口和坐标系统。</li>\n</ul>\n<!---->\n\n<ul>\n<li><p><strong>marker：</strong> 定义了在特定的path元素、line元素、polyline元素或者polygon元素上绘制箭头或者多边形标记图形。</p>\n<ul>\n<li>  refx：定义元素参考点的x坐标 (默认是0)</li>\n<li>  refy：定义元素参考点的y坐标 (默认是0)</li>\n<li>  markerWidth：表示根据 viewBox 和 preserveAspectRatio 属性渲染 <code>&lt;marker&gt;</code> 时要适合的视口宽度</li>\n<li>  markerHeight：表示根据 viewBox 和 preserveAspectRatio 属性渲染 <code>&lt;marker&gt; </code>时要适合的视口高度</li>\n<li>  markerUnits：指示标记放置在形状上的位置时如何旋转</li>\n</ul>\n</li>\n</ul>\n<!---->\n\n<ul>\n<li>  mask</li>\n</ul>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/GRxmgEN?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/GRxmgEN\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h2 id=\"滤镜元素\"><a href=\"#滤镜元素\" class=\"headerlink\" title=\"滤镜元素\"></a>滤镜元素</h2><h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><blockquote>\n<p>滤镜通过<code>&lt;filter&gt;</code>在<code>&lt;defs&gt;</code>中进行定义，在filter标签中提供一系列图元，使用滤镜只需为svg元素设置filter属性即可。</p>\n</blockquote>\n<h3 id=\"常见属性\"><a href=\"#常见属性\" class=\"headerlink\" title=\"常见属性\"></a>常见属性</h3><p>  in：标识输入的原语</p>\n<pre><code>-   SourceGraphic：该关键词表示图形元素自身将作为`&lt;filter&gt;`原语的原始输入\n-   SourceAlpha：该关键词表示图形元素自身将作为`&lt;filter&gt;`原语的原始输入. SourceAlpha 与 SourceGraphic 具有相同的规则除了 SourceAlpha 只使用元素的透明度。\n-   BackgroundImage：该关键词表示 filter 元素当前底下的区域的图形快照将被调用。\n-   BackgroundAlpha：BackgroundImage 相同除了只使用透明度。\n-   FillPaint：此关键字表示过滤效果的目标元素上的`fill`属性值。在许多情况下，FillPaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n-   StrokePaint：此关键字表示滤镜效果的目标元素上的笔画属性的值。在许多情况下，StrokePaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。\n</code></pre>\n<!---->\n\n<p>  in2：in2 属性标识给定filter原语的第二个输入。它的工作原理与 in 属性完全相同。</p>\n<blockquote>\n<p>colorMatrix颜色矩阵变换</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* R G B A 1 颜色矩阵计算 */</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"comment\">// R = 1*R + 0*G + 0*B + 0*A + 0 </span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"comment\">// G = 0*R + 1*G + 0*B + 0*A + 0 </span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"comment\">// B = 0*R + 0*G + 1*B + 0*A + 0 </span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"comment\">// A = 0*R + 0*G + 0*B + 1*A + 0</span></span><br></pre></td></tr></table></figure>\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/xxWzjde?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/xxWzjde\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n<blockquote>\n<p>使用feGaussianBlur、feColorMatrix、feBlend实现粘稠效果</p>\n</blockquote>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLZbQO?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLZbQO\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n<blockquote>\n<p>使用feComposite并设置operator为in，控制显示图像的一部分。</p>\n</blockquote>\n<p>关于feComposite，更多可以看这里：<a href=\"https://apike.ca/prog_svg_filter_feComposite.html\">feComposite</a></p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/wvmXOwZ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/wvmXOwZ\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n\n<blockquote>\n<p>feDisplacementMap、feTurbulence</p>\n</blockquote>\n<p>feDisplacementMap推荐看这篇：<a href=\"https://www.zhangxinxu.com/wordpress/2017/12/understand-svg-fedisplacementmap-filter/\">深入理解SVG feDisplacementMap滤镜及实际应用</a></p>\n<p>feTurbulence推荐看这篇：<a href=\"https://zhuanlan.zhihu.com/p/366438535\">说说SVG的feTurbulence滤镜</a></p>\n<p>位置转换公式：</p>\n<p><code>P&#39;(x,y) ← P(x + scale * (XC(x,y) - 0.5), y + scale * (YC(x,y) - 0.5))</code></p>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/OJvwJqV?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/OJvwJqV\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h2 id=\"渐变元素\"><a href=\"#渐变元素\" class=\"headerlink\" title=\"渐变元素\"></a>渐变元素</h2><h3 id=\"linearGradient：线性渐变\"><a href=\"#linearGradient：线性渐变\" class=\"headerlink\" title=\"linearGradient：线性渐变\"></a>linearGradient：线性渐变</h3><ul>\n<li>  gradientUnits: 控制渐变坐标的单位</li>\n<li>  gradientTransform: 对渐变坐标系进行变换（translate、skew、rotate。。。）</li>\n<li>  x1：线性渐变起点x坐标-   y1：线性渐变起点y坐标</li>\n<li>  x2：线性渐变终点x坐标-   y2：线性渐变终点y坐标</li>\n<li>  spreadMethod：定义如何在渐变之外填充    -   pad：用渐变终点颜色去填充额外区域    -   repeat：按照开始的渐变顺序重复    -   reflect：按照开始的渐变相反顺序重复</li>\n</ul>\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"feDisplacementMap\" src=\"https://codepen.io/l-jour/embed/JjLMMjR?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n    See the Pen <a href=\"https://codepen.io/l-jour/pen/JjLMMjR\"></a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n    on <a href=\"https://codepen.io\">CodePen</a>.\n  </iframe>\n\n<h3 id=\"radialGradient：径向渐变\"><a href=\"#radialGradient：径向渐变\" class=\"headerlink\" title=\"radialGradient：径向渐变\"></a>radialGradient：径向渐变</h3><ul>\n<li>  gradientUnits：控制渐变坐标的单位</li>\n<li>  gradientTransform：对渐变坐标系进行变换（translate、skew、rotate。。。）</li>\n<li>  cx: 用来定义径向渐变终止圆的 x 轴坐标(默认50%)。</li>\n<li>  cy：用来定义径向渐变终止圆的 y 轴坐标。</li>\n<li>  r：用来定义径向渐变终止圆的半径。</li>\n<li>  fx：用来定义径向渐变的焦点的 x 轴坐标</li>\n<li>  fy：用来定义径向渐变的焦点的 y 轴坐标</li>\n<li>  spreadMethod：确定如何在渐变的定义边缘之外填充形状。    -   pad：用渐变终点颜色去填充额外区域    -   repeat：按照开始的渐变顺序重复    -   reflect：按照开始的渐变相反顺序重复</li>\n<li>  stop：渐变的颜色坡度</li>\n</ul>\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"svg-radialgradient\" src=\"https://codepen.io/l-jour/embed/zYWWLBa?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/l-jour/pen/zYWWLBa\">\n  svg-radialgradient</a> by L-jour (<a href=\"https://codepen.io/l-jour\">@l-jour</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n<h2 id=\"关于svg与canvas\"><a href=\"#关于svg与canvas\" class=\"headerlink\" title=\"关于svg与canvas\"></a>关于svg与canvas</h2><p>  可以看看msdn的文章<a href=\"https://docs.microsoft.com/zh-cn/previous-versions/msdn10/Hh377884(v=MSDN.10)\">如何为您的网站在Canvas和SVG之间做出选择</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>  svg的世界非常丰富，并且很多属性可以作用不同的元素、拥有不同的效果。元素直接有可以搭配使用，如多个动画，多个滤镜等等，滤镜元素还涉及更多领域知识。总之，元素种类、元素属性非常多，还是需要得慢慢地学习、阅读相关的案例并操作一下才能有所掌握。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li>  <a href=\"https://apike.ca/prog_svg_filter_feComposite.html\">feComposite</a></li>\n<li>  <a href=\"https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A\">贝塞尔曲线-wiki</a></li>\n</ul>"},{"title":"【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？","date":"2023-02-10T07:19:07.000Z","_content":"\n原文：[https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm](https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm)\n\n一开始，Javascript 没有导入/导出模块的方法。这是个问题。想象一下只在一个文件中编写您的应用程序——那将是一场噩梦！\n\n然后，比我聪明得多的人试图为 Javascript 添加模块化。其中一些是 CJS、AMD、UMD 和 ESM。您可能听说过其中一些方法（还有其他方法，但这些都是大玩家）。\n\n## CJS\n\nCJS 是 CommonJS 的缩写。这是它的样子：\n\n```typescript\n//importing\nconst doSomething = require(\"./doSomething.js\");\n\n//exporting\nmodule.exports = function doSomething(n) {\n  // do something\n};\n```\n\n- 你们中的一些人可能立即会认为 CJS 语法来自于 nodejs。那是因为 nodejs 使用 CJS 模块格式。\n- CJS 同步导入模块。\n- 您可以从库 node_modules 或本地目录导入。通过 `const myLocalModule = require('./some/local/file.js')` 或 `var React = require('react');`\n- 当 CJS 导入时，它会给你一个导入对象的副本。相当于一个引用地址。\n- CJS 将在浏览器中不起作用。它必须被 transpiled and bundled。\n\n```typescript\n// ============ foo.js\nmodule.exports = {\n  foo: \"from foo\",\n};\n\n// ============ bar.js\nconst foo = require(\"./foo.js\");\n\nfoo.foo = foo.foo + \" and from bar\";\n\nmodule.exports = foo;\n\n// ============ index.js\nconst foo = require(\"./foo.js\");\n\nconsole.log(\"before require bar:\", foo); // {foo: 'from foo'}\n\nconst bar = require(\"./bar.js\");\n\nconsole.log(\"after require bar:\", foo); // {foo: 'from foo and from bar'}\n\nconsole.log(\"definitely same memory address:\", bar === foo); // true\n```\n\n## AMD\n\nAMD 代表异步模块定义。这是一个示例代码：\n\n```typescript\ndefine([\"dep1\", \"dep2\"], function (dep1, dep2) {\n  //Define the module value by returning a value.\n  return function () {};\n});\n```\n\nor\n\n```typescript\n// \"simplified CommonJS wrapping\" https://requirejs.org/docs/whyamd.html\ndefine(function (require) {\n  var dep1 = require(\"dep1\"),\n    dep2 = require(\"dep2\");\n  return function () {};\n});\n```\n\n- AMD 异步导入模块（因此得名）。\n- AMD 是为前端而生的（当它被提议时）（而 CJS 是后端）。\n- AMD 语法不如 CJS 直观。我认为 AMD 与 CJS 完全相反.\n\n## UMD\n\nUMD 代表通用模块定义.\n\n```typescript\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"jquery\", \"underscore\"], factory);\n    } else if (typeof exports === \"object\") {\n        module.exports = factory(require(\"jquery\"), require(\"underscore\"));\n    } else {\n        root.Requester = factory(root.$, root._);\n    }\n}(this, function ($, _) {\n    // this is where I defined my module implementation\n\n    var Requester = { // ... };\n\n    return Requester;\n}));\n```\n\n- 适用于前端和后端（因此得名 universal）。\n- 与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。在[此处](https://github.com/umdjs/umd/)查看更多模式。\n- 在使用 Rollup/Webpack 等打包器时，UMD 通常用作后备模块\n\n## ESM\n\nESM 代表 ES 模块。实现标准的模块系统是 Javascript 的提议。相信很多人都看过这个：\n\n```typescript\nimport React from 'react';\n\nimport {foo, bar} from './myLib';\n\n...\n\nexport default function() {\n  // your Function\n};\nexport const function1() {...};\nexport const function2() {...};\n```\n\n- 适用于许多现代浏览器\n- 它兼具两全其美：类似 CJS 的简单语法和 AMD 的异步\n- Tree-shakeable，由于 ES6 的静态模块结构\n- ESM 允许像 Rollup 这样的打包器删除不必要的代码，允许站点发送更少的代码以获得更快的加载。\n- 可以在 HTML 中调用，只需执行以下操作：(script 标签标注 type='module')，node 环境下可以在`package.json`中添加`type='module'`\n\n```html\n<script type=\"module\">\n  import { func1 } from \"my-lib\";\n  func1();\n</script>\n```\n\n浏览器兼容性：\n\n- Safari 10.1.\n- Chrome 61.\n- Firefox 60.\n- Edge 16.\n\n### 异步性\n\n```typescript\n// ========== foo.js\nexport default {\n  foo: \"from foo\",\n};\n\n// ========== bar.js\nimport foo from \"./foo.js\";\n\nfoo.foo = foo.foo + \" and from bar.js\";\n\nconsole.log(foo);\n\nexport default foo;\n\n// ========== index.js\nimport foo from \"./foo.js\";\n\nconsole.log(foo);\n\nimport bar from \"./bar.js\";\n\n// 输出（import bar from './bar.js 提前了）\n// bar: { foo: 'from foo and from bar.js' }\n// index: { foo: 'from foo and from bar.js' }\n```\n\n## 总结\n\n- ESM 是最好的模块格式，这要归功于其简单的语法、异步特性和 tree-shakeability。\n- UMD 无处不在，通常用作 ESM 不起作用时的后备方案。\n- CJS 是同步的，适合后端。\n- AMD 是异步的，适合前端。\n  感谢阅读，开发者！以后打算把每个模块都写的很深入，尤其是 ESM，因为里面有很多牛逼。敬请关注！\n  如果您发现任何错误，请告诉我。\n","source":"_posts/【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？.md","raw":"---\ntitle: 【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？\ndate: 2023-02-10 15:19:07\ntags:\n---\n\n原文：[https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm](https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm)\n\n一开始，Javascript 没有导入/导出模块的方法。这是个问题。想象一下只在一个文件中编写您的应用程序——那将是一场噩梦！\n\n然后，比我聪明得多的人试图为 Javascript 添加模块化。其中一些是 CJS、AMD、UMD 和 ESM。您可能听说过其中一些方法（还有其他方法，但这些都是大玩家）。\n\n## CJS\n\nCJS 是 CommonJS 的缩写。这是它的样子：\n\n```typescript\n//importing\nconst doSomething = require(\"./doSomething.js\");\n\n//exporting\nmodule.exports = function doSomething(n) {\n  // do something\n};\n```\n\n- 你们中的一些人可能立即会认为 CJS 语法来自于 nodejs。那是因为 nodejs 使用 CJS 模块格式。\n- CJS 同步导入模块。\n- 您可以从库 node_modules 或本地目录导入。通过 `const myLocalModule = require('./some/local/file.js')` 或 `var React = require('react');`\n- 当 CJS 导入时，它会给你一个导入对象的副本。相当于一个引用地址。\n- CJS 将在浏览器中不起作用。它必须被 transpiled and bundled。\n\n```typescript\n// ============ foo.js\nmodule.exports = {\n  foo: \"from foo\",\n};\n\n// ============ bar.js\nconst foo = require(\"./foo.js\");\n\nfoo.foo = foo.foo + \" and from bar\";\n\nmodule.exports = foo;\n\n// ============ index.js\nconst foo = require(\"./foo.js\");\n\nconsole.log(\"before require bar:\", foo); // {foo: 'from foo'}\n\nconst bar = require(\"./bar.js\");\n\nconsole.log(\"after require bar:\", foo); // {foo: 'from foo and from bar'}\n\nconsole.log(\"definitely same memory address:\", bar === foo); // true\n```\n\n## AMD\n\nAMD 代表异步模块定义。这是一个示例代码：\n\n```typescript\ndefine([\"dep1\", \"dep2\"], function (dep1, dep2) {\n  //Define the module value by returning a value.\n  return function () {};\n});\n```\n\nor\n\n```typescript\n// \"simplified CommonJS wrapping\" https://requirejs.org/docs/whyamd.html\ndefine(function (require) {\n  var dep1 = require(\"dep1\"),\n    dep2 = require(\"dep2\");\n  return function () {};\n});\n```\n\n- AMD 异步导入模块（因此得名）。\n- AMD 是为前端而生的（当它被提议时）（而 CJS 是后端）。\n- AMD 语法不如 CJS 直观。我认为 AMD 与 CJS 完全相反.\n\n## UMD\n\nUMD 代表通用模块定义.\n\n```typescript\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"jquery\", \"underscore\"], factory);\n    } else if (typeof exports === \"object\") {\n        module.exports = factory(require(\"jquery\"), require(\"underscore\"));\n    } else {\n        root.Requester = factory(root.$, root._);\n    }\n}(this, function ($, _) {\n    // this is where I defined my module implementation\n\n    var Requester = { // ... };\n\n    return Requester;\n}));\n```\n\n- 适用于前端和后端（因此得名 universal）。\n- 与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。在[此处](https://github.com/umdjs/umd/)查看更多模式。\n- 在使用 Rollup/Webpack 等打包器时，UMD 通常用作后备模块\n\n## ESM\n\nESM 代表 ES 模块。实现标准的模块系统是 Javascript 的提议。相信很多人都看过这个：\n\n```typescript\nimport React from 'react';\n\nimport {foo, bar} from './myLib';\n\n...\n\nexport default function() {\n  // your Function\n};\nexport const function1() {...};\nexport const function2() {...};\n```\n\n- 适用于许多现代浏览器\n- 它兼具两全其美：类似 CJS 的简单语法和 AMD 的异步\n- Tree-shakeable，由于 ES6 的静态模块结构\n- ESM 允许像 Rollup 这样的打包器删除不必要的代码，允许站点发送更少的代码以获得更快的加载。\n- 可以在 HTML 中调用，只需执行以下操作：(script 标签标注 type='module')，node 环境下可以在`package.json`中添加`type='module'`\n\n```html\n<script type=\"module\">\n  import { func1 } from \"my-lib\";\n  func1();\n</script>\n```\n\n浏览器兼容性：\n\n- Safari 10.1.\n- Chrome 61.\n- Firefox 60.\n- Edge 16.\n\n### 异步性\n\n```typescript\n// ========== foo.js\nexport default {\n  foo: \"from foo\",\n};\n\n// ========== bar.js\nimport foo from \"./foo.js\";\n\nfoo.foo = foo.foo + \" and from bar.js\";\n\nconsole.log(foo);\n\nexport default foo;\n\n// ========== index.js\nimport foo from \"./foo.js\";\n\nconsole.log(foo);\n\nimport bar from \"./bar.js\";\n\n// 输出（import bar from './bar.js 提前了）\n// bar: { foo: 'from foo and from bar.js' }\n// index: { foo: 'from foo and from bar.js' }\n```\n\n## 总结\n\n- ESM 是最好的模块格式，这要归功于其简单的语法、异步特性和 tree-shakeability。\n- UMD 无处不在，通常用作 ESM 不起作用时的后备方案。\n- CJS 是同步的，适合后端。\n- AMD 是异步的，适合前端。\n  感谢阅读，开发者！以后打算把每个模块都写的很深入，尤其是 ESM，因为里面有很多牛逼。敬请关注！\n  如果您发现任何错误，请告诉我。\n","slug":"【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？","published":1,"updated":"2023-03-10T13:25:39.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyo000pg8v75c973sji","content":"<p>原文：<a href=\"https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm\">https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm</a></p>\n<p>一开始，Javascript 没有导入/导出模块的方法。这是个问题。想象一下只在一个文件中编写您的应用程序——那将是一场噩梦！</p>\n<p>然后，比我聪明得多的人试图为 Javascript 添加模块化。其中一些是 CJS、AMD、UMD 和 ESM。您可能听说过其中一些方法（还有其他方法，但这些都是大玩家）。</p>\n<h2 id=\"CJS\"><a href=\"#CJS\" class=\"headerlink\" title=\"CJS\"></a>CJS</h2><p>CJS 是 CommonJS 的缩写。这是它的样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//importing</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./doSomething.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//exporting</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>你们中的一些人可能立即会认为 CJS 语法来自于 nodejs。那是因为 nodejs 使用 CJS 模块格式。</li>\n<li>CJS 同步导入模块。</li>\n<li>您可以从库 node_modules 或本地目录导入。通过 <code>const myLocalModule = require(&#39;./some/local/file.js&#39;)</code> 或 <code>var React = require(&#39;react&#39;);</code></li>\n<li>当 CJS 导入时，它会给你一个导入对象的副本。相当于一个引用地址。</li>\n<li>CJS 将在浏览器中不起作用。它必须被 transpiled and bundled。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ============ foo.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"string\">&quot;from foo&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ============ bar.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./foo.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">foo.foo = foo.foo + <span class=\"string\">&quot; and from bar&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ============ index.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./foo.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;before require bar:&quot;</span>, foo); <span class=\"comment\">// &#123;foo: &#x27;from foo&#x27;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./bar.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;after require bar:&quot;</span>, foo); <span class=\"comment\">// &#123;foo: &#x27;from foo and from bar&#x27;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;definitely same memory address:&quot;</span>, bar === foo); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><p>AMD 代表异步模块定义。这是一个示例代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">&quot;dep1&quot;</span>, <span class=\"string\">&quot;dep2&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dep1, dep2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//Define the module value by returning a value.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>or</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &quot;simplified CommonJS wrapping&quot; https://requirejs.org/docs/whyamd.html</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dep1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;dep1&quot;</span>),</span><br><span class=\"line\">    dep2 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;dep2&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AMD 异步导入模块（因此得名）。</li>\n<li>AMD 是为前端而生的（当它被提议时）（而 CJS 是后端）。</li>\n<li>AMD 语法不如 CJS 直观。我认为 AMD 与 CJS 完全相反.</li>\n</ul>\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><p>UMD 代表通用模块定义.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">root, factory</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        define([<span class=\"string\">&quot;jquery&quot;</span>, <span class=\"string\">&quot;underscore&quot;</span>], factory);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">exports</span> === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.exports = factory(<span class=\"built_in\">require</span>(<span class=\"string\">&quot;jquery&quot;</span>), <span class=\"built_in\">require</span>(<span class=\"string\">&quot;underscore&quot;</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        root.Requester = factory(root.$, root._);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(<span class=\"built_in\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$, _</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this is where I defined my module implementation</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> Requester = &#123; <span class=\"comment\">// ... &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Requester;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>适用于前端和后端（因此得名 universal）。</li>\n<li>与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。在<a href=\"https://github.com/umdjs/umd/\">此处</a>查看更多模式。</li>\n<li>在使用 Rollup/Webpack 等打包器时，UMD 通常用作后备模块</li>\n</ul>\n<h2 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h2><p>ESM 代表 ES 模块。实现标准的模块系统是 Javascript 的提议。相信很多人都看过这个：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;foo, bar&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./myLib&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// your Function</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"function\"><span class=\"title\">function1</span>(<span class=\"params\"></span>)</span> &#123;...&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"function\"><span class=\"title\">function2</span>(<span class=\"params\"></span>)</span> &#123;...&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>适用于许多现代浏览器</li>\n<li>它兼具两全其美：类似 CJS 的简单语法和 AMD 的异步</li>\n<li>Tree-shakeable，由于 ES6 的静态模块结构</li>\n<li>ESM 允许像 Rollup 这样的打包器删除不必要的代码，允许站点发送更少的代码以获得更快的加载。</li>\n<li>可以在 HTML 中调用，只需执行以下操作：(script 标签标注 type=’module’)，node 环境下可以在<code>package.json</code>中添加<code>type=&#39;module&#39;</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> &#123; func1 &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;my-lib&quot;</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  func1();</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>浏览器兼容性：</p>\n<ul>\n<li>Safari 10.1.</li>\n<li>Chrome 61.</li>\n<li>Firefox 60.</li>\n<li>Edge 16.</li>\n</ul>\n<h3 id=\"异步性\"><a href=\"#异步性\" class=\"headerlink\" title=\"异步性\"></a>异步性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ========== foo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"string\">&quot;from foo&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ========== bar.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">&quot;./foo.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.foo = foo.foo + <span class=\"string\">&quot; and from bar.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ========== index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">&quot;./foo.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> bar <span class=\"keyword\">from</span> <span class=\"string\">&quot;./bar.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出（import bar from &#x27;./bar.js 提前了）</span></span><br><span class=\"line\"><span class=\"comment\">// bar: &#123; foo: &#x27;from foo and from bar.js&#x27; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// index: &#123; foo: &#x27;from foo and from bar.js&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>ESM 是最好的模块格式，这要归功于其简单的语法、异步特性和 tree-shakeability。</li>\n<li>UMD 无处不在，通常用作 ESM 不起作用时的后备方案。</li>\n<li>CJS 是同步的，适合后端。</li>\n<li>AMD 是异步的，适合前端。<br>感谢阅读，开发者！以后打算把每个模块都写的很深入，尤其是 ESM，因为里面有很多牛逼。敬请关注！<br>如果您发现任何错误，请告诉我。</li>\n</ul>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":3566,"excerpt":"","more":"<p>原文：<a href=\"https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm\">https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm</a></p>\n<p>一开始，Javascript 没有导入/导出模块的方法。这是个问题。想象一下只在一个文件中编写您的应用程序——那将是一场噩梦！</p>\n<p>然后，比我聪明得多的人试图为 Javascript 添加模块化。其中一些是 CJS、AMD、UMD 和 ESM。您可能听说过其中一些方法（还有其他方法，但这些都是大玩家）。</p>\n<h2 id=\"CJS\"><a href=\"#CJS\" class=\"headerlink\" title=\"CJS\"></a>CJS</h2><p>CJS 是 CommonJS 的缩写。这是它的样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//importing</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./doSomething.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//exporting</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>你们中的一些人可能立即会认为 CJS 语法来自于 nodejs。那是因为 nodejs 使用 CJS 模块格式。</li>\n<li>CJS 同步导入模块。</li>\n<li>您可以从库 node_modules 或本地目录导入。通过 <code>const myLocalModule = require(&#39;./some/local/file.js&#39;)</code> 或 <code>var React = require(&#39;react&#39;);</code></li>\n<li>当 CJS 导入时，它会给你一个导入对象的副本。相当于一个引用地址。</li>\n<li>CJS 将在浏览器中不起作用。它必须被 transpiled and bundled。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ============ foo.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"string\">&quot;from foo&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ============ bar.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./foo.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">foo.foo = foo.foo + <span class=\"string\">&quot; and from bar&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ============ index.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./foo.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;before require bar:&quot;</span>, foo); <span class=\"comment\">// &#123;foo: &#x27;from foo&#x27;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./bar.js&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;after require bar:&quot;</span>, foo); <span class=\"comment\">// &#123;foo: &#x27;from foo and from bar&#x27;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;definitely same memory address:&quot;</span>, bar === foo); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><p>AMD 代表异步模块定义。这是一个示例代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">&quot;dep1&quot;</span>, <span class=\"string\">&quot;dep2&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dep1, dep2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//Define the module value by returning a value.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>or</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &quot;simplified CommonJS wrapping&quot; https://requirejs.org/docs/whyamd.html</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dep1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;dep1&quot;</span>),</span><br><span class=\"line\">    dep2 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;dep2&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AMD 异步导入模块（因此得名）。</li>\n<li>AMD 是为前端而生的（当它被提议时）（而 CJS 是后端）。</li>\n<li>AMD 语法不如 CJS 直观。我认为 AMD 与 CJS 完全相反.</li>\n</ul>\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><p>UMD 代表通用模块定义.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">root, factory</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        define([<span class=\"string\">&quot;jquery&quot;</span>, <span class=\"string\">&quot;underscore&quot;</span>], factory);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">exports</span> === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.exports = factory(<span class=\"built_in\">require</span>(<span class=\"string\">&quot;jquery&quot;</span>), <span class=\"built_in\">require</span>(<span class=\"string\">&quot;underscore&quot;</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        root.Requester = factory(root.$, root._);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(<span class=\"built_in\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$, _</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this is where I defined my module implementation</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> Requester = &#123; <span class=\"comment\">// ... &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Requester;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>适用于前端和后端（因此得名 universal）。</li>\n<li>与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。在<a href=\"https://github.com/umdjs/umd/\">此处</a>查看更多模式。</li>\n<li>在使用 Rollup/Webpack 等打包器时，UMD 通常用作后备模块</li>\n</ul>\n<h2 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h2><p>ESM 代表 ES 模块。实现标准的模块系统是 Javascript 的提议。相信很多人都看过这个：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;foo, bar&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./myLib&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// your Function</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"function\"><span class=\"title\">function1</span>(<span class=\"params\"></span>)</span> &#123;...&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"function\"><span class=\"title\">function2</span>(<span class=\"params\"></span>)</span> &#123;...&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>适用于许多现代浏览器</li>\n<li>它兼具两全其美：类似 CJS 的简单语法和 AMD 的异步</li>\n<li>Tree-shakeable，由于 ES6 的静态模块结构</li>\n<li>ESM 允许像 Rollup 这样的打包器删除不必要的代码，允许站点发送更少的代码以获得更快的加载。</li>\n<li>可以在 HTML 中调用，只需执行以下操作：(script 标签标注 type=’module’)，node 环境下可以在<code>package.json</code>中添加<code>type=&#39;module&#39;</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> &#123; func1 &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;my-lib&quot;</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  func1();</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>浏览器兼容性：</p>\n<ul>\n<li>Safari 10.1.</li>\n<li>Chrome 61.</li>\n<li>Firefox 60.</li>\n<li>Edge 16.</li>\n</ul>\n<h3 id=\"异步性\"><a href=\"#异步性\" class=\"headerlink\" title=\"异步性\"></a>异步性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ========== foo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"string\">&quot;from foo&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ========== bar.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">&quot;./foo.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.foo = foo.foo + <span class=\"string\">&quot; and from bar.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ========== index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">&quot;./foo.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> bar <span class=\"keyword\">from</span> <span class=\"string\">&quot;./bar.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出（import bar from &#x27;./bar.js 提前了）</span></span><br><span class=\"line\"><span class=\"comment\">// bar: &#123; foo: &#x27;from foo and from bar.js&#x27; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// index: &#123; foo: &#x27;from foo and from bar.js&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>ESM 是最好的模块格式，这要归功于其简单的语法、异步特性和 tree-shakeability。</li>\n<li>UMD 无处不在，通常用作 ESM 不起作用时的后备方案。</li>\n<li>CJS 是同步的，适合后端。</li>\n<li>AMD 是异步的，适合前端。<br>感谢阅读，开发者！以后打算把每个模块都写的很深入，尤其是 ESM，因为里面有很多牛逼。敬请关注！<br>如果您发现任何错误，请告诉我。</li>\n</ul>\n"},{"title":"一封阿里云的喝茶邮件","date":"2022-02-08T04:37:52.000Z","_content":"\n事情是这样的，就在今天早上，收到了一封来自阿里云的【喝茶（核查）通知】。一看邮件，很明显就是域名没有解析到内地节点的服务器上面呢。回想一下自己的解析，它说的对！。。。\n![why](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081154.png)\n\n<!-- more -->\n\n## 原由\n\n在老早以前了，我用 hexo 部署 blog 在 GitHub Page 上面，然后解析了自己的域名在 gh-page 上，显然，GitHub Page 的服务器不在内地。我为了访问速度能快那么一丁点，就继续使用了 cloudflare 的 cdn 加速，因此也在上面设置了 DNS，但是我在 DNS 上也解析了一个二级域名到了阿里云的服务器上啊。按照网上的说法，设置一个二级域名解析到内地服务器就行了呢，然后点击复查连接后还是检查有问题。\n\n## 解决\n\n通过原由的分析，我这次将问题放在了 cloudflare 上面，看了一下 DNS 设置。\n![dns setting](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081207.png)\n看到上面的代理状态了吗，我就开始怀疑是这个的问题，ok,查查什么意思。看到了下面的一个问题。\n![Q&A proxy](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081210.png)\n按照上面的说法，显然 proxy 就是一个代理，访问域名时，如果设置了代理，那么就会走代理，而不是直接走解析地址。\n那我们来 ping 一下看看。\n![ping res](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081213.png)\n上面的两个域名其实是同一个 ip,但是 ping 出来响应的不一样，因此，确实是有代理的存在。\n我自己的服务器 ip 是 47 开始的，上面的 ping 结果一个是 cloudflare 代理的服务器，一个是 gh-page 的服务器。\n那么关闭代理就可以了吗？\n是的，可以了。\n![pre|left|350*0](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081229.jpg)\n![|right|250*0](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081231.png)\n![result](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081217.png)\n","source":"_posts/一封阿里云的喝茶邮件.md","raw":"---\ntitle: 一封阿里云的喝茶邮件\ndate: 2022-02-08 12:37:52\ntags:\ncategories: 一些趣事的🌟\n---\n\n事情是这样的，就在今天早上，收到了一封来自阿里云的【喝茶（核查）通知】。一看邮件，很明显就是域名没有解析到内地节点的服务器上面呢。回想一下自己的解析，它说的对！。。。\n![why](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081154.png)\n\n<!-- more -->\n\n## 原由\n\n在老早以前了，我用 hexo 部署 blog 在 GitHub Page 上面，然后解析了自己的域名在 gh-page 上，显然，GitHub Page 的服务器不在内地。我为了访问速度能快那么一丁点，就继续使用了 cloudflare 的 cdn 加速，因此也在上面设置了 DNS，但是我在 DNS 上也解析了一个二级域名到了阿里云的服务器上啊。按照网上的说法，设置一个二级域名解析到内地服务器就行了呢，然后点击复查连接后还是检查有问题。\n\n## 解决\n\n通过原由的分析，我这次将问题放在了 cloudflare 上面，看了一下 DNS 设置。\n![dns setting](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081207.png)\n看到上面的代理状态了吗，我就开始怀疑是这个的问题，ok,查查什么意思。看到了下面的一个问题。\n![Q&A proxy](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081210.png)\n按照上面的说法，显然 proxy 就是一个代理，访问域名时，如果设置了代理，那么就会走代理，而不是直接走解析地址。\n那我们来 ping 一下看看。\n![ping res](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081213.png)\n上面的两个域名其实是同一个 ip,但是 ping 出来响应的不一样，因此，确实是有代理的存在。\n我自己的服务器 ip 是 47 开始的，上面的 ping 结果一个是 cloudflare 代理的服务器，一个是 gh-page 的服务器。\n那么关闭代理就可以了吗？\n是的，可以了。\n![pre|left|350*0](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081229.jpg)\n![|right|250*0](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081231.png)\n![result](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081217.png)\n","slug":"一封阿里云的喝茶邮件","published":1,"updated":"2022-12-31T10:26:33.596Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyq000qg8v7hr310alk","content":"<p>事情是这样的，就在今天早上，收到了一封来自阿里云的【喝茶（核查）通知】。一看邮件，很明显就是域名没有解析到内地节点的服务器上面呢。回想一下自己的解析，它说的对！。。。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081154.png\" alt=\"why\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"原由\"><a href=\"#原由\" class=\"headerlink\" title=\"原由\"></a>原由</h2><p>在老早以前了，我用 hexo 部署 blog 在 GitHub Page 上面，然后解析了自己的域名在 gh-page 上，显然，GitHub Page 的服务器不在内地。我为了访问速度能快那么一丁点，就继续使用了 cloudflare 的 cdn 加速，因此也在上面设置了 DNS，但是我在 DNS 上也解析了一个二级域名到了阿里云的服务器上啊。按照网上的说法，设置一个二级域名解析到内地服务器就行了呢，然后点击复查连接后还是检查有问题。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>通过原由的分析，我这次将问题放在了 cloudflare 上面，看了一下 DNS 设置。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081207.png\" alt=\"dns setting\"><br>看到上面的代理状态了吗，我就开始怀疑是这个的问题，ok,查查什么意思。看到了下面的一个问题。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081210.png\" alt=\"Q&amp;A proxy\"><br>按照上面的说法，显然 proxy 就是一个代理，访问域名时，如果设置了代理，那么就会走代理，而不是直接走解析地址。<br>那我们来 ping 一下看看。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081213.png\" alt=\"ping res\"><br>上面的两个域名其实是同一个 ip,但是 ping 出来响应的不一样，因此，确实是有代理的存在。<br>我自己的服务器 ip 是 47 开始的，上面的 ping 结果一个是 cloudflare 代理的服务器，一个是 gh-page 的服务器。<br>那么关闭代理就可以了吗？<br>是的，可以了。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081229.jpg\" alt=\"pre|left|350*0\"><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081231.png\" alt=\"|right|250*0\"><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081217.png\" alt=\"result\"></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":566,"excerpt":"<p>事情是这样的，就在今天早上，收到了一封来自阿里云的【喝茶（核查）通知】。一看邮件，很明显就是域名没有解析到内地节点的服务器上面呢。回想一下自己的解析，它说的对！。。。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081154.png\" alt=\"why\"></p>","more":"<h2 id=\"原由\"><a href=\"#原由\" class=\"headerlink\" title=\"原由\"></a>原由</h2><p>在老早以前了，我用 hexo 部署 blog 在 GitHub Page 上面，然后解析了自己的域名在 gh-page 上，显然，GitHub Page 的服务器不在内地。我为了访问速度能快那么一丁点，就继续使用了 cloudflare 的 cdn 加速，因此也在上面设置了 DNS，但是我在 DNS 上也解析了一个二级域名到了阿里云的服务器上啊。按照网上的说法，设置一个二级域名解析到内地服务器就行了呢，然后点击复查连接后还是检查有问题。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>通过原由的分析，我这次将问题放在了 cloudflare 上面，看了一下 DNS 设置。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081207.png\" alt=\"dns setting\"><br>看到上面的代理状态了吗，我就开始怀疑是这个的问题，ok,查查什么意思。看到了下面的一个问题。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081210.png\" alt=\"Q&amp;A proxy\"><br>按照上面的说法，显然 proxy 就是一个代理，访问域名时，如果设置了代理，那么就会走代理，而不是直接走解析地址。<br>那我们来 ping 一下看看。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081213.png\" alt=\"ping res\"><br>上面的两个域名其实是同一个 ip,但是 ping 出来响应的不一样，因此，确实是有代理的存在。<br>我自己的服务器 ip 是 47 开始的，上面的 ping 结果一个是 cloudflare 代理的服务器，一个是 gh-page 的服务器。<br>那么关闭代理就可以了吗？<br>是的，可以了。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081229.jpg\" alt=\"pre|left|350*0\"><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081231.png\" alt=\"|right|250*0\"><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081217.png\" alt=\"result\"></p>"},{"title":"【译】优化长任务 Optimize long tasks","date":"2022-10-11T14:42:10.000Z","_content":"\n原文：[https://web.dev/optimize-long-tasks/](https://web.dev/optimize-long-tasks/)\n\n> 你曾被告诉过，不要阻塞主线程并且分解你的长任务，但是有想过这样做的意义吗？\n\n如果你读了很多关于网站性能的资料, 保持 JavasScript 应用程序快速运行的建议往往涉及以下的建议：\n\n- 不要阻塞主线程\n- 分解你的长任务\n\n那这些意味着什么？减少 JavaScript 是好的，但这是否自动等同在整个页面生命周期中更快速的用户界面？也许是，也许不是.\n\n<!-- more -->\n\n## 一个 task 是什么样的？\n\n一个 task 是浏览器所做的任何离散的工作，task 包括解析 HTML 和 CSS, 运行 JavaScript 代码, 以及一些你不能直接控制的事情。对于所有的这些，你所编写的并且部署到服务器的 JavaScript 是主要的任务来源。\n\n![img_1](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.23.12.png)\n\nTasks 以多种方式影响性能。例如，当浏览器在启动时下载 js 文件时，浏览器将任务进行排队并且编译 js 以让其能被执行。然后在页面的生命周期中，（例如通过事件处理程序驱动交互、JavaScript 驱动的动画和后台活动（例如分析收集））启动任务。所有的这些东西，除了 web worker 和类似的 API 都发生在主线程上。\n\n## 主线程是什么 ？\n\n主线程是大多数任务在浏览器中运行的地方。它被称为主线程的原因是：它是您编写的几乎所有 JavaScript 都在这个线程中工作。\n\n主线程一次只能处理一个任务。当任务超出某个确定的点（准确来说是 50ms ）时,它们被归类为长任务。如果用户在长时间的任务运行时尝试与页面交互 — 或者如果需要进行重要的渲染更新 — 浏览器将延迟处理该工作。这会导致交互或渲染延迟。\n\n![img_2](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.42.24.png)\n\n<em style=\"font-size:12px\">Chrome浏览器的性能分析器中描述的长任务。长任务的角落里有一个红色的三角形，任务的阻塞部分用对角线的红色条纹填充</em>\n\n你需要分解任务。这意味着将一个长任务划分为较小的任务，这些任务单独运行所需的时间更少。\n\n![img_3](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/8Bhl9Ilki4tM0aC1nfn8.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">单个长任务与同一任务分解为五个较短任务的可视化</em>\n\n这很重要，因为当任务被分解时，浏览器有更多机会响应更高优先级的工作——包括用户交互。\n\n![img_3](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0yV0ynwW7FujIwvCbCxQ.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">当任务太长，浏览器不能对互动做出足够快的反应时，与将较长的任务分解成较小的任务时相比，互动会发生什么样的情况，这是一个可视化的结果</em>\n\n如上图的上半部分所述，由用户交互排队的事件处理程序必须等待一个长任务才能运行。这延迟了交互的发生。在下半部分，事件处理程序有机会更快地运行。因为事件处理程序有机会在较小的任务之间运行。它运行得比它必须等待一个很长的任务完成要快。在上半部分中，用户可能已经感受到了延迟，在下半部分，交互可能是即时的。\n\n然而，问题在于 “分解你的长任务” 和 “不要阻塞主线程”的建议不够具体,除非你已经知道如何做这些事情，这就是本指南将要解释的内容。\n\n## 任务管理策略\n\n在软件架构中，一个常见建议是将您的工作分解更小的功能。这为您提供了更好的代码可读性和项目可维护性的好处。这使得测试更容易编写。\n\n```ts\nfunction saveSettings() {\n  validateForm();\n  showSpinner();\n  saveToDatabase();\n  updateUI();\n  sendAnalytics();\n}\n```\n在这个例子中，这里的 saveSettings 函数，在它调用时，它调用了其他五个函数。从概念上讲，这是很好的架构，如果你需要调试这些函数中的一个，你可以便利项目树以弄清每个函数的作用。\n\n然而，问题在于 JavaScript 不会将这些函数中的每一个作为单独的任务运行，因为它们是在 savaSettings 函数中执行的。__这意味着所有五个功能都作为单独任务运行。__\n\n> JavaScript 以这种方式工作是因为它使用任务执行的运行到完成模型。这意味着每个任务将一直运行到完成，无论它阻塞主线程多长时间。\n\n![img_4](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0c61l5DCix9y0GBa3pFj.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">调用五个函数的单个函数 saveSettings()。这项工作是作为一项长期的整体任务的一部分运行的</em>\n\n在最好的情况下，即使只是这些功能中的一个，也可以为任务的总长度贡献50毫秒或更多。在最坏的情况下，更多的这些任务可以运行相当长的时间–特别是在资源有限的设备上。下面是一套策略，你可以用来分解和优先处理任务。\n\n## 手动延迟代码执行\n\n开发人员使用的一种将任务分解成小任务的方法涉及到 setTimeout(). 使用这种技术，你把函数传给 setTimeout 这将回调的执行推迟到一个单独的任务中，即时你指定的时间为 0。\n\n```ts\nfunction saveSettings () {\n  // 完成用户可见的关键工作:\n  validateForm();\n  showSpinner();\n  updateUI();\n\n  // 将用户不可见的工作推迟到单独的任务:\n  setTimeout(() => {\n    saveToDatabase();\n    sendAnalytics();\n  }, 0);\n}\n```\n\n如果您有一系列需要按顺序运行的函数，这很有效，但您的代码可能并不总是以这种方式组织。例如，您可能有大量数据需要循环处理，如果您有数百万个项目，该任务可能需要很长时间。\n\n```ts\nfunction processData () {\n  for (const item of largeDataArray) {\n    // Process the individual item here.\n  }\n}\n```\n\n使用 setTimeout 是存在问题的, 因为它的人机工程学（这是什么意思🤔，原文：ergonomics）使其难以实现，并且整个数据数组可能需要很长时间处理，即使每个项目都可以非常快速地处理。这一切加起来，setTimeout 不是合适的工具，至少在这样使用时不是。\n\n除了 setTimeout 之外，还有一些其他 API 允许您将代码执行推迟到后续任务。 一种方法是使用 postMessage 来加快超时。您也可以使用 requestIdleCallback() 来分解工作。 但是要注意 – requestIdleCallback() 以尽可能低的优先级安排任务，而且只在浏览器空闲时间内进行。当主线程拥挤时,用 requestIdleCallback() 安排的任务可能永远无法运行。\n\n## 使用 async/await yield points\n\n在本指南的其余部分，你会看到一个短语是 “yield to the main thread”，但是，这意味着什么？为什么你要这么做？你什么时候该这样做？\n\n> 当你 yield to the main thread，你会给它一个机会来处理比当前排队的任务更重要的任务。理想情况下（ideally），当你有一些关键的面向用户的工作，需要比 yield 更早地执行时，你应该 yield main thread，yield main thread 可以为关键工作创造机会，使其更快地运行。\n\n当任务被分解时，其他任务可以通过浏览器内部优先级方案更好地进行优先级排序。yield main thread 的方法涉及到使用一个 Promise 的组合，该组合与对 setTimeout() 进行的调用进行解析。\n\n```ts\nfunction yieldToMain () {\n  return new Promise(resolve => {\n    setTimeout(resolve, 0);\n  });\n}\n```\n> 虽然这个代码实例返回了一个在调用 setTimeout 后解析的 Promise, 但负责在新任务中运行奇遇代码的并不是这个 Promise，而是 setTimeout 调用。Promise 回调作为微任务而不是任务运行，因此不会 yield main thread\n\n在 saveSettings() 函数中，如果在每次函数调用后 await yieldToMain() 函数，则可以在每次工作后 yield to the main\n\n```ts\nasync function saveSettings () {\n  // Create an array of functions to run:\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ]\n\n  // Loop over the tasks:\n  while (tasks.length > 0) {\n    // Shift the first task off the tasks array:\n    const task = tasks.shift();\n\n    // Run the task:\n    task();\n\n    // Yield to the main thread:\n    await yieldToMain();\n  }\n}\n```\n> 你不必在每次函数调用后都 yield。例如，如果你运行的两个函数会导致用户界面的关键性更新，你可能不想在它们之间 yield。如果可以的话，让这些 tast 先运行，然后考虑在那些不那么关键的或用户看不到的后台工作的函数之间进行 yield。\n\n结果是曾经单一的任务现在被分解为单独的任务\n\n![img_5](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/wg0FW6S29CzOCbbwk9kK.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">saveSettings() 函数现在将其子函数作为单独的任务执行。</em>\n\n使用基于 Promise 的方法来产生而不是手动使用 setTimeout() 的好处是更好的人体工程学。屈服点成为声明性的，因此更容易编写、阅读和理解。\n\n## 仅在必要时 yield\n\n如果您有一堆任务，但您只想在用户尝试与页面交互时让步怎么办？这就是 isInputPending() 的用途。\n\nisInputPending() 是一个您可以随时运行以确定用户是否正在尝试与页面元素交互的函数：对 isInputPending() 的调用将返回 true。否则返回 false。\n\n假设您可有一个需要运行的任务队列，但您不想妨碍任何输入。这段代码 — 它同时使用了 isInputPending() 函数 — 确保在用户尝试与页面交互时输入不会被延迟。\n\n```ts\nasync function saveSettings () {\n  // A task queue of functions\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ];\n  \n  while (tasks.length > 0) {\n    // Yield to a pending user input:\n    if (navigator.scheduling.isInputPending()) {\n      // There's a pending user input. Yield here:\n      await yieldToMain();\n    } else {\n      // Shift the the task out of the queue:\n      const task = tasks.shift();\n\n      // Run the task:\n      task();\n    }\n  }\n}\n```\n当 saveSettings() 运行时，它将遍历队列中的任务。如果 isInputPending() 在循环期间返回 true，则 saveSettings() 将调用 yieldToMain() 以便处理用户输入。否则，它将把下一个任务移出队列的前面并继续运行它。它将执行此操作，直到没有其他任务为止。\n\n![img_5](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/snMl3kRlWyJjdbL0qsqM.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">saveSettings()运行一个有五个任务的任务队列，但在第二个工作项运行时，用户已经点击打开了一个菜单。 isInputPending()让位于主线程来处理这个交互，并恢复运行其余的任务。</em>\n\n> isInputPending()不一定在用户输入后立即返回true。这是因为操作系统需要时间来告诉浏览器发生了交互。这意味着其他代码可能已经开始执行了（正如你在上面的截图中看到的saveToDatabase()函数）。即使你使用isInputPending()，你仍然要限制每个函数的工作量，这是至关重要的。\n\n将 isInputPending() 与让步机制结合使用是让浏览器停止其正在处理的任何任务以响应关键的面向用户的交互的好方法。这可以帮助提高您的页面在许多任务正在进行时在许多情况下响应用户的能力。\n\n另一种使用isInputPending()的方法–特别是如果你担心为不支持它的浏览器提供退路–是使用基于时间的方法与 可选链操作符 （?.）\n\n```ts\nasync function saveSettings () {\n  // A task queue of functions\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ];\n  \n  let deadline = performance.now() + 50;\n\n  while (tasks.length > 0) {\n    // Optional chaining operator used here helps to avoid\n    // errors in browsers that don't support `isInputPending`:\n    if (navigator.scheduling?.isInputPending() || performance.now() >= deadline) {\n      // There's a pending user input, or the\n      // deadline has been reached. Yield here:\n      await yieldToMain();\n\n      // Extend the deadline:\n      deadline += 50;\n\n      // Stop the execution of the current loop and\n      // move onto the next iteration:\n      continue;\n    }\n\n    // Shift the the task out of the queue:\n    const task = tasks.shift();\n\n    // Run the task:\n    task();\n  }\n}\n```\n\n通过这种方法，你可以为不支持isInputPending()的浏览器提供一个后备方案，即使用（并调整）一个截止日期，以便在必要时将工作分开，无论是通过屈服于用户输入，还是在某个时间点之前。\n\n## 当前 api 的差异\n\n到目前为止提到的API可以帮助你分解任务，但它们有一个显著的缺点：当你通过推迟代码在后续任务中运行而屈服于主线程时，该代码会被添加到任务队列的最末端。\n\n如果你控制了你页面上的所有代码，就有可能创建你自己的scheduler （参考 react 吗，😯），并能对任务进行优先排序，但第三方脚本不会使用你的调度器。实际上，在这样的环境中，你并不能真正地对工作进行优先排序。你只能把它分成几块，或者明确地屈从于用户的互动。\n\n幸运的是，目前有一个专门的调度器API正在开发中，可以解决这些问题。\n\n## 一个专门的调度程序API\n\n调度器API目前提供了postTask()函数，在撰写本文时，该函数在Chromium浏览器和Firefox的一个标志后面可用。 postTask()允许对任务进行更精细的调度，是帮助浏览器确定工作优先级的一种方法，这样低优先级的任务就会让位于主线程。 postTask()使用 Promise，并接受一个优先级设置。\n\npostTask() API 具有三个可以使用的 priorities\n\n- ‘background’ : 最低优先级任务。\n- ‘user-visible’ : 中等优先级任务，“用户可见”，如果没有设置优先级，这是默认设置。\n- ‘user-blocking’: 用于需要高优先级运行的关键任务。\n\n以下面的代码为例，postTask()API被用来以尽可能高的优先级运行三个任务，并以尽可能低的优先级运行其余两个任务。\n\n```ts\nfunction saveSettings () {\n  // Validate the form at high priority\n  scheduler.postTask(validateForm, {priority: 'user-blocking'});\n\n  // Show the spinner at high priority:\n  scheduler.postTask(showSpinner, {priority: 'user-blocking'});\n\n  // Update the database in the background:\n  scheduler.postTask(saveToDatabase, {priority: 'background'});\n\n  // Update the user interface at high priority:\n  scheduler.postTask(updateUI, {priority: 'user-blocking'});\n\n  // Send analytics data in the background:\n  scheduler.postTask(sendAnalytics, {priority: 'background'});\n};\n```\n在这里，任务的优先级以浏览器优先级任务（例如用户交互）可以正常工作的方式安排。\n\n<div style=\"color:red\">子任务执行顺序差异</div>\n\n![img_6](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/ttvI1HqusI02CAdqhjWP.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">当saveSettings()运行时，该函数使用postTask()对各个函数进行调度。面向用户的关键工作被安排在高优先级，而用户不知道的工作被安排在后台运行。这使得用户交互的执行速度更快，因为工作被分割开来并被适当地安排了优先次序。</em>\n\n这是一个如何使用 postTask() 的简单示例。可以实例化不同的 TaskController 对象，这些对象可以在任务之间共享优先级，包括根据需要更改不同 TaskController 实例的优先级的能力。\n\n> 并非所有浏览器都支持 postTask()。您可以使用特征检测来查看它是否可用，或者考虑使用 polyfill\n\n## 内置的 yield\n\n调度器API的一个拟议的部分，目前没有在任何浏览器中实现，就是一个内置的 yield 机制。它的使用类似于本文前面演示的 yieldToMain() 函数。\n\n```ts\nasync function saveSettings () {\n  // Create an array of functions to run:\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ]\n\n  // Loop over the tasks:\n  while (tasks.length > 0) {\n    // Shift the first task off the tasks array:\n    const task = tasks.shift();\n\n    // Run the task:\n    task();\n\n    // Yield to the main thread with the scheduler\n    // API's own yielding mechanism:\n    await scheduler.yield();\n  }\n}\n```\n\n您会注意到，上面的代码非常熟悉，但是您没有使用 yieldToMain()，而是调用并等待 scheduler.yield()。\n\n![img_7](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/fyuvJqAV0mLxfZDM9tAm.png?auto=format&w=1294)\n\n<em style=\"font-size:12px\">一个没有yield、yield、yield 和 continuation 的任务执行的可视化图。当使用scheduler.yield()时，任务的执行甚至在屈服点之后还能继续执行。</em>\n\nscheduler.yield() 的好处是continuation，这意味着如果你在一组任务中间yield，其他的计划任务会在yield点之后以同样的顺序继续执行。这可以避免第三方脚本中的代码篡夺您的代码执行顺序。\n\n## 总结\n\n管理任务是具有挑战性的，但这样做有助于你的页面对用户的互动作出更快速的反应。在管理和确定任务的优先次序方面，没有单一的建议。相反，它是一些不同的技术。重申一下，这些是你在管理任务时要考虑的主要事项。\n\n- 让给主线程以完成关键的、面向用户的任务。\n\n- 当用户尝试与页面交互时，使用 isInputPending() 让步给主线程。\n\n- 使用 postTask() 对任务进行优先级排序。\n\n- 最后，在你的函数中做尽可能少的工作。\n\n有了这些工具中的一个或多个，你应该能够在你的应用程序中构造工作，使其优先考虑用户的需求，同时确保不太关键的工作仍然能够完成。这将创造一个更好的用户体验，它的响应速度更快，使用起来更愉快。\n\nSpecial thanks to Philip Walton for his technical vetting of this article.\n\nHero image sourced from Unsplash, courtesy of Amirali Mirhashemian.\n\n\n\n","source":"_posts/【译】优化长任务-Optimize-long-tasks.md","raw":"---\ntitle: 【译】优化长任务 Optimize long tasks\ndate: 2022-10-11 22:42:10\ntags:\n---\n\n原文：[https://web.dev/optimize-long-tasks/](https://web.dev/optimize-long-tasks/)\n\n> 你曾被告诉过，不要阻塞主线程并且分解你的长任务，但是有想过这样做的意义吗？\n\n如果你读了很多关于网站性能的资料, 保持 JavasScript 应用程序快速运行的建议往往涉及以下的建议：\n\n- 不要阻塞主线程\n- 分解你的长任务\n\n那这些意味着什么？减少 JavaScript 是好的，但这是否自动等同在整个页面生命周期中更快速的用户界面？也许是，也许不是.\n\n<!-- more -->\n\n## 一个 task 是什么样的？\n\n一个 task 是浏览器所做的任何离散的工作，task 包括解析 HTML 和 CSS, 运行 JavaScript 代码, 以及一些你不能直接控制的事情。对于所有的这些，你所编写的并且部署到服务器的 JavaScript 是主要的任务来源。\n\n![img_1](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.23.12.png)\n\nTasks 以多种方式影响性能。例如，当浏览器在启动时下载 js 文件时，浏览器将任务进行排队并且编译 js 以让其能被执行。然后在页面的生命周期中，（例如通过事件处理程序驱动交互、JavaScript 驱动的动画和后台活动（例如分析收集））启动任务。所有的这些东西，除了 web worker 和类似的 API 都发生在主线程上。\n\n## 主线程是什么 ？\n\n主线程是大多数任务在浏览器中运行的地方。它被称为主线程的原因是：它是您编写的几乎所有 JavaScript 都在这个线程中工作。\n\n主线程一次只能处理一个任务。当任务超出某个确定的点（准确来说是 50ms ）时,它们被归类为长任务。如果用户在长时间的任务运行时尝试与页面交互 — 或者如果需要进行重要的渲染更新 — 浏览器将延迟处理该工作。这会导致交互或渲染延迟。\n\n![img_2](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.42.24.png)\n\n<em style=\"font-size:12px\">Chrome浏览器的性能分析器中描述的长任务。长任务的角落里有一个红色的三角形，任务的阻塞部分用对角线的红色条纹填充</em>\n\n你需要分解任务。这意味着将一个长任务划分为较小的任务，这些任务单独运行所需的时间更少。\n\n![img_3](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/8Bhl9Ilki4tM0aC1nfn8.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">单个长任务与同一任务分解为五个较短任务的可视化</em>\n\n这很重要，因为当任务被分解时，浏览器有更多机会响应更高优先级的工作——包括用户交互。\n\n![img_3](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0yV0ynwW7FujIwvCbCxQ.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">当任务太长，浏览器不能对互动做出足够快的反应时，与将较长的任务分解成较小的任务时相比，互动会发生什么样的情况，这是一个可视化的结果</em>\n\n如上图的上半部分所述，由用户交互排队的事件处理程序必须等待一个长任务才能运行。这延迟了交互的发生。在下半部分，事件处理程序有机会更快地运行。因为事件处理程序有机会在较小的任务之间运行。它运行得比它必须等待一个很长的任务完成要快。在上半部分中，用户可能已经感受到了延迟，在下半部分，交互可能是即时的。\n\n然而，问题在于 “分解你的长任务” 和 “不要阻塞主线程”的建议不够具体,除非你已经知道如何做这些事情，这就是本指南将要解释的内容。\n\n## 任务管理策略\n\n在软件架构中，一个常见建议是将您的工作分解更小的功能。这为您提供了更好的代码可读性和项目可维护性的好处。这使得测试更容易编写。\n\n```ts\nfunction saveSettings() {\n  validateForm();\n  showSpinner();\n  saveToDatabase();\n  updateUI();\n  sendAnalytics();\n}\n```\n在这个例子中，这里的 saveSettings 函数，在它调用时，它调用了其他五个函数。从概念上讲，这是很好的架构，如果你需要调试这些函数中的一个，你可以便利项目树以弄清每个函数的作用。\n\n然而，问题在于 JavaScript 不会将这些函数中的每一个作为单独的任务运行，因为它们是在 savaSettings 函数中执行的。__这意味着所有五个功能都作为单独任务运行。__\n\n> JavaScript 以这种方式工作是因为它使用任务执行的运行到完成模型。这意味着每个任务将一直运行到完成，无论它阻塞主线程多长时间。\n\n![img_4](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0c61l5DCix9y0GBa3pFj.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">调用五个函数的单个函数 saveSettings()。这项工作是作为一项长期的整体任务的一部分运行的</em>\n\n在最好的情况下，即使只是这些功能中的一个，也可以为任务的总长度贡献50毫秒或更多。在最坏的情况下，更多的这些任务可以运行相当长的时间–特别是在资源有限的设备上。下面是一套策略，你可以用来分解和优先处理任务。\n\n## 手动延迟代码执行\n\n开发人员使用的一种将任务分解成小任务的方法涉及到 setTimeout(). 使用这种技术，你把函数传给 setTimeout 这将回调的执行推迟到一个单独的任务中，即时你指定的时间为 0。\n\n```ts\nfunction saveSettings () {\n  // 完成用户可见的关键工作:\n  validateForm();\n  showSpinner();\n  updateUI();\n\n  // 将用户不可见的工作推迟到单独的任务:\n  setTimeout(() => {\n    saveToDatabase();\n    sendAnalytics();\n  }, 0);\n}\n```\n\n如果您有一系列需要按顺序运行的函数，这很有效，但您的代码可能并不总是以这种方式组织。例如，您可能有大量数据需要循环处理，如果您有数百万个项目，该任务可能需要很长时间。\n\n```ts\nfunction processData () {\n  for (const item of largeDataArray) {\n    // Process the individual item here.\n  }\n}\n```\n\n使用 setTimeout 是存在问题的, 因为它的人机工程学（这是什么意思🤔，原文：ergonomics）使其难以实现，并且整个数据数组可能需要很长时间处理，即使每个项目都可以非常快速地处理。这一切加起来，setTimeout 不是合适的工具，至少在这样使用时不是。\n\n除了 setTimeout 之外，还有一些其他 API 允许您将代码执行推迟到后续任务。 一种方法是使用 postMessage 来加快超时。您也可以使用 requestIdleCallback() 来分解工作。 但是要注意 – requestIdleCallback() 以尽可能低的优先级安排任务，而且只在浏览器空闲时间内进行。当主线程拥挤时,用 requestIdleCallback() 安排的任务可能永远无法运行。\n\n## 使用 async/await yield points\n\n在本指南的其余部分，你会看到一个短语是 “yield to the main thread”，但是，这意味着什么？为什么你要这么做？你什么时候该这样做？\n\n> 当你 yield to the main thread，你会给它一个机会来处理比当前排队的任务更重要的任务。理想情况下（ideally），当你有一些关键的面向用户的工作，需要比 yield 更早地执行时，你应该 yield main thread，yield main thread 可以为关键工作创造机会，使其更快地运行。\n\n当任务被分解时，其他任务可以通过浏览器内部优先级方案更好地进行优先级排序。yield main thread 的方法涉及到使用一个 Promise 的组合，该组合与对 setTimeout() 进行的调用进行解析。\n\n```ts\nfunction yieldToMain () {\n  return new Promise(resolve => {\n    setTimeout(resolve, 0);\n  });\n}\n```\n> 虽然这个代码实例返回了一个在调用 setTimeout 后解析的 Promise, 但负责在新任务中运行奇遇代码的并不是这个 Promise，而是 setTimeout 调用。Promise 回调作为微任务而不是任务运行，因此不会 yield main thread\n\n在 saveSettings() 函数中，如果在每次函数调用后 await yieldToMain() 函数，则可以在每次工作后 yield to the main\n\n```ts\nasync function saveSettings () {\n  // Create an array of functions to run:\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ]\n\n  // Loop over the tasks:\n  while (tasks.length > 0) {\n    // Shift the first task off the tasks array:\n    const task = tasks.shift();\n\n    // Run the task:\n    task();\n\n    // Yield to the main thread:\n    await yieldToMain();\n  }\n}\n```\n> 你不必在每次函数调用后都 yield。例如，如果你运行的两个函数会导致用户界面的关键性更新，你可能不想在它们之间 yield。如果可以的话，让这些 tast 先运行，然后考虑在那些不那么关键的或用户看不到的后台工作的函数之间进行 yield。\n\n结果是曾经单一的任务现在被分解为单独的任务\n\n![img_5](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/wg0FW6S29CzOCbbwk9kK.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">saveSettings() 函数现在将其子函数作为单独的任务执行。</em>\n\n使用基于 Promise 的方法来产生而不是手动使用 setTimeout() 的好处是更好的人体工程学。屈服点成为声明性的，因此更容易编写、阅读和理解。\n\n## 仅在必要时 yield\n\n如果您有一堆任务，但您只想在用户尝试与页面交互时让步怎么办？这就是 isInputPending() 的用途。\n\nisInputPending() 是一个您可以随时运行以确定用户是否正在尝试与页面元素交互的函数：对 isInputPending() 的调用将返回 true。否则返回 false。\n\n假设您可有一个需要运行的任务队列，但您不想妨碍任何输入。这段代码 — 它同时使用了 isInputPending() 函数 — 确保在用户尝试与页面交互时输入不会被延迟。\n\n```ts\nasync function saveSettings () {\n  // A task queue of functions\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ];\n  \n  while (tasks.length > 0) {\n    // Yield to a pending user input:\n    if (navigator.scheduling.isInputPending()) {\n      // There's a pending user input. Yield here:\n      await yieldToMain();\n    } else {\n      // Shift the the task out of the queue:\n      const task = tasks.shift();\n\n      // Run the task:\n      task();\n    }\n  }\n}\n```\n当 saveSettings() 运行时，它将遍历队列中的任务。如果 isInputPending() 在循环期间返回 true，则 saveSettings() 将调用 yieldToMain() 以便处理用户输入。否则，它将把下一个任务移出队列的前面并继续运行它。它将执行此操作，直到没有其他任务为止。\n\n![img_5](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/snMl3kRlWyJjdbL0qsqM.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">saveSettings()运行一个有五个任务的任务队列，但在第二个工作项运行时，用户已经点击打开了一个菜单。 isInputPending()让位于主线程来处理这个交互，并恢复运行其余的任务。</em>\n\n> isInputPending()不一定在用户输入后立即返回true。这是因为操作系统需要时间来告诉浏览器发生了交互。这意味着其他代码可能已经开始执行了（正如你在上面的截图中看到的saveToDatabase()函数）。即使你使用isInputPending()，你仍然要限制每个函数的工作量，这是至关重要的。\n\n将 isInputPending() 与让步机制结合使用是让浏览器停止其正在处理的任何任务以响应关键的面向用户的交互的好方法。这可以帮助提高您的页面在许多任务正在进行时在许多情况下响应用户的能力。\n\n另一种使用isInputPending()的方法–特别是如果你担心为不支持它的浏览器提供退路–是使用基于时间的方法与 可选链操作符 （?.）\n\n```ts\nasync function saveSettings () {\n  // A task queue of functions\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ];\n  \n  let deadline = performance.now() + 50;\n\n  while (tasks.length > 0) {\n    // Optional chaining operator used here helps to avoid\n    // errors in browsers that don't support `isInputPending`:\n    if (navigator.scheduling?.isInputPending() || performance.now() >= deadline) {\n      // There's a pending user input, or the\n      // deadline has been reached. Yield here:\n      await yieldToMain();\n\n      // Extend the deadline:\n      deadline += 50;\n\n      // Stop the execution of the current loop and\n      // move onto the next iteration:\n      continue;\n    }\n\n    // Shift the the task out of the queue:\n    const task = tasks.shift();\n\n    // Run the task:\n    task();\n  }\n}\n```\n\n通过这种方法，你可以为不支持isInputPending()的浏览器提供一个后备方案，即使用（并调整）一个截止日期，以便在必要时将工作分开，无论是通过屈服于用户输入，还是在某个时间点之前。\n\n## 当前 api 的差异\n\n到目前为止提到的API可以帮助你分解任务，但它们有一个显著的缺点：当你通过推迟代码在后续任务中运行而屈服于主线程时，该代码会被添加到任务队列的最末端。\n\n如果你控制了你页面上的所有代码，就有可能创建你自己的scheduler （参考 react 吗，😯），并能对任务进行优先排序，但第三方脚本不会使用你的调度器。实际上，在这样的环境中，你并不能真正地对工作进行优先排序。你只能把它分成几块，或者明确地屈从于用户的互动。\n\n幸运的是，目前有一个专门的调度器API正在开发中，可以解决这些问题。\n\n## 一个专门的调度程序API\n\n调度器API目前提供了postTask()函数，在撰写本文时，该函数在Chromium浏览器和Firefox的一个标志后面可用。 postTask()允许对任务进行更精细的调度，是帮助浏览器确定工作优先级的一种方法，这样低优先级的任务就会让位于主线程。 postTask()使用 Promise，并接受一个优先级设置。\n\npostTask() API 具有三个可以使用的 priorities\n\n- ‘background’ : 最低优先级任务。\n- ‘user-visible’ : 中等优先级任务，“用户可见”，如果没有设置优先级，这是默认设置。\n- ‘user-blocking’: 用于需要高优先级运行的关键任务。\n\n以下面的代码为例，postTask()API被用来以尽可能高的优先级运行三个任务，并以尽可能低的优先级运行其余两个任务。\n\n```ts\nfunction saveSettings () {\n  // Validate the form at high priority\n  scheduler.postTask(validateForm, {priority: 'user-blocking'});\n\n  // Show the spinner at high priority:\n  scheduler.postTask(showSpinner, {priority: 'user-blocking'});\n\n  // Update the database in the background:\n  scheduler.postTask(saveToDatabase, {priority: 'background'});\n\n  // Update the user interface at high priority:\n  scheduler.postTask(updateUI, {priority: 'user-blocking'});\n\n  // Send analytics data in the background:\n  scheduler.postTask(sendAnalytics, {priority: 'background'});\n};\n```\n在这里，任务的优先级以浏览器优先级任务（例如用户交互）可以正常工作的方式安排。\n\n<div style=\"color:red\">子任务执行顺序差异</div>\n\n![img_6](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/ttvI1HqusI02CAdqhjWP.png?auto=format&w=1600)\n\n<em style=\"font-size:12px\">当saveSettings()运行时，该函数使用postTask()对各个函数进行调度。面向用户的关键工作被安排在高优先级，而用户不知道的工作被安排在后台运行。这使得用户交互的执行速度更快，因为工作被分割开来并被适当地安排了优先次序。</em>\n\n这是一个如何使用 postTask() 的简单示例。可以实例化不同的 TaskController 对象，这些对象可以在任务之间共享优先级，包括根据需要更改不同 TaskController 实例的优先级的能力。\n\n> 并非所有浏览器都支持 postTask()。您可以使用特征检测来查看它是否可用，或者考虑使用 polyfill\n\n## 内置的 yield\n\n调度器API的一个拟议的部分，目前没有在任何浏览器中实现，就是一个内置的 yield 机制。它的使用类似于本文前面演示的 yieldToMain() 函数。\n\n```ts\nasync function saveSettings () {\n  // Create an array of functions to run:\n  const tasks = [\n    validateForm,\n    showSpinner,\n    saveToDatabase,\n    updateUI,\n    sendAnalytics\n  ]\n\n  // Loop over the tasks:\n  while (tasks.length > 0) {\n    // Shift the first task off the tasks array:\n    const task = tasks.shift();\n\n    // Run the task:\n    task();\n\n    // Yield to the main thread with the scheduler\n    // API's own yielding mechanism:\n    await scheduler.yield();\n  }\n}\n```\n\n您会注意到，上面的代码非常熟悉，但是您没有使用 yieldToMain()，而是调用并等待 scheduler.yield()。\n\n![img_7](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/fyuvJqAV0mLxfZDM9tAm.png?auto=format&w=1294)\n\n<em style=\"font-size:12px\">一个没有yield、yield、yield 和 continuation 的任务执行的可视化图。当使用scheduler.yield()时，任务的执行甚至在屈服点之后还能继续执行。</em>\n\nscheduler.yield() 的好处是continuation，这意味着如果你在一组任务中间yield，其他的计划任务会在yield点之后以同样的顺序继续执行。这可以避免第三方脚本中的代码篡夺您的代码执行顺序。\n\n## 总结\n\n管理任务是具有挑战性的，但这样做有助于你的页面对用户的互动作出更快速的反应。在管理和确定任务的优先次序方面，没有单一的建议。相反，它是一些不同的技术。重申一下，这些是你在管理任务时要考虑的主要事项。\n\n- 让给主线程以完成关键的、面向用户的任务。\n\n- 当用户尝试与页面交互时，使用 isInputPending() 让步给主线程。\n\n- 使用 postTask() 对任务进行优先级排序。\n\n- 最后，在你的函数中做尽可能少的工作。\n\n有了这些工具中的一个或多个，你应该能够在你的应用程序中构造工作，使其优先考虑用户的需求，同时确保不太关键的工作仍然能够完成。这将创造一个更好的用户体验，它的响应速度更快，使用起来更愉快。\n\nSpecial thanks to Philip Walton for his technical vetting of this article.\n\nHero image sourced from Unsplash, courtesy of Amirali Mirhashemian.\n\n\n\n","slug":"【译】优化长任务-Optimize-long-tasks","published":1,"updated":"2022-12-31T10:26:33.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzys000tg8v7312d5u9o","content":"<p>原文：<a href=\"https://web.dev/optimize-long-tasks/\">https://web.dev/optimize-long-tasks/</a></p>\n<blockquote>\n<p>你曾被告诉过，不要阻塞主线程并且分解你的长任务，但是有想过这样做的意义吗？</p>\n</blockquote>\n<p>如果你读了很多关于网站性能的资料, 保持 JavasScript 应用程序快速运行的建议往往涉及以下的建议：</p>\n<ul>\n<li>不要阻塞主线程</li>\n<li>分解你的长任务</li>\n</ul>\n<p>那这些意味着什么？减少 JavaScript 是好的，但这是否自动等同在整个页面生命周期中更快速的用户界面？也许是，也许不是.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一个-task-是什么样的？\"><a href=\"#一个-task-是什么样的？\" class=\"headerlink\" title=\"一个 task 是什么样的？\"></a>一个 task 是什么样的？</h2><p>一个 task 是浏览器所做的任何离散的工作，task 包括解析 HTML 和 CSS, 运行 JavaScript 代码, 以及一些你不能直接控制的事情。对于所有的这些，你所编写的并且部署到服务器的 JavaScript 是主要的任务来源。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.23.12.png\" alt=\"img_1\"></p>\n<p>Tasks 以多种方式影响性能。例如，当浏览器在启动时下载 js 文件时，浏览器将任务进行排队并且编译 js 以让其能被执行。然后在页面的生命周期中，（例如通过事件处理程序驱动交互、JavaScript 驱动的动画和后台活动（例如分析收集））启动任务。所有的这些东西，除了 web worker 和类似的 API 都发生在主线程上。</p>\n<h2 id=\"主线程是什么-？\"><a href=\"#主线程是什么-？\" class=\"headerlink\" title=\"主线程是什么 ？\"></a>主线程是什么 ？</h2><p>主线程是大多数任务在浏览器中运行的地方。它被称为主线程的原因是：它是您编写的几乎所有 JavaScript 都在这个线程中工作。</p>\n<p>主线程一次只能处理一个任务。当任务超出某个确定的点（准确来说是 50ms ）时,它们被归类为长任务。如果用户在长时间的任务运行时尝试与页面交互 — 或者如果需要进行重要的渲染更新 — 浏览器将延迟处理该工作。这会导致交互或渲染延迟。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.42.24.png\" alt=\"img_2\"></p>\n<p><em style=\"font-size:12px\">Chrome浏览器的性能分析器中描述的长任务。长任务的角落里有一个红色的三角形，任务的阻塞部分用对角线的红色条纹填充</em></p>\n<p>你需要分解任务。这意味着将一个长任务划分为较小的任务，这些任务单独运行所需的时间更少。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/8Bhl9Ilki4tM0aC1nfn8.png?auto=format&w=1600\" alt=\"img_3\"></p>\n<p><em style=\"font-size:12px\">单个长任务与同一任务分解为五个较短任务的可视化</em></p>\n<p>这很重要，因为当任务被分解时，浏览器有更多机会响应更高优先级的工作——包括用户交互。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0yV0ynwW7FujIwvCbCxQ.png?auto=format&w=1600\" alt=\"img_3\"></p>\n<p><em style=\"font-size:12px\">当任务太长，浏览器不能对互动做出足够快的反应时，与将较长的任务分解成较小的任务时相比，互动会发生什么样的情况，这是一个可视化的结果</em></p>\n<p>如上图的上半部分所述，由用户交互排队的事件处理程序必须等待一个长任务才能运行。这延迟了交互的发生。在下半部分，事件处理程序有机会更快地运行。因为事件处理程序有机会在较小的任务之间运行。它运行得比它必须等待一个很长的任务完成要快。在上半部分中，用户可能已经感受到了延迟，在下半部分，交互可能是即时的。</p>\n<p>然而，问题在于 “分解你的长任务” 和 “不要阻塞主线程”的建议不够具体,除非你已经知道如何做这些事情，这就是本指南将要解释的内容。</p>\n<h2 id=\"任务管理策略\"><a href=\"#任务管理策略\" class=\"headerlink\" title=\"任务管理策略\"></a>任务管理策略</h2><p>在软件架构中，一个常见建议是将您的工作分解更小的功能。这为您提供了更好的代码可读性和项目可维护性的好处。这使得测试更容易编写。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  validateForm();</span><br><span class=\"line\">  showSpinner();</span><br><span class=\"line\">  saveToDatabase();</span><br><span class=\"line\">  updateUI();</span><br><span class=\"line\">  sendAnalytics();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，这里的 saveSettings 函数，在它调用时，它调用了其他五个函数。从概念上讲，这是很好的架构，如果你需要调试这些函数中的一个，你可以便利项目树以弄清每个函数的作用。</p>\n<p>然而，问题在于 JavaScript 不会将这些函数中的每一个作为单独的任务运行，因为它们是在 savaSettings 函数中执行的。<strong>这意味着所有五个功能都作为单独任务运行。</strong></p>\n<blockquote>\n<p>JavaScript 以这种方式工作是因为它使用任务执行的运行到完成模型。这意味着每个任务将一直运行到完成，无论它阻塞主线程多长时间。</p>\n</blockquote>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0c61l5DCix9y0GBa3pFj.png?auto=format&w=1600\" alt=\"img_4\"></p>\n<p><em style=\"font-size:12px\">调用五个函数的单个函数 saveSettings()。这项工作是作为一项长期的整体任务的一部分运行的</em></p>\n<p>在最好的情况下，即使只是这些功能中的一个，也可以为任务的总长度贡献50毫秒或更多。在最坏的情况下，更多的这些任务可以运行相当长的时间–特别是在资源有限的设备上。下面是一套策略，你可以用来分解和优先处理任务。</p>\n<h2 id=\"手动延迟代码执行\"><a href=\"#手动延迟代码执行\" class=\"headerlink\" title=\"手动延迟代码执行\"></a>手动延迟代码执行</h2><p>开发人员使用的一种将任务分解成小任务的方法涉及到 setTimeout(). 使用这种技术，你把函数传给 setTimeout 这将回调的执行推迟到一个单独的任务中，即时你指定的时间为 0。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 完成用户可见的关键工作:</span></span><br><span class=\"line\">  validateForm();</span><br><span class=\"line\">  showSpinner();</span><br><span class=\"line\">  updateUI();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将用户不可见的工作推迟到单独的任务:</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    saveToDatabase();</span><br><span class=\"line\">    sendAnalytics();</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果您有一系列需要按顺序运行的函数，这很有效，但您的代码可能并不总是以这种方式组织。例如，您可能有大量数据需要循环处理，如果您有数百万个项目，该任务可能需要很长时间。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> item <span class=\"keyword\">of</span> largeDataArray) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Process the individual item here.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 setTimeout 是存在问题的, 因为它的人机工程学（这是什么意思🤔，原文：ergonomics）使其难以实现，并且整个数据数组可能需要很长时间处理，即使每个项目都可以非常快速地处理。这一切加起来，setTimeout 不是合适的工具，至少在这样使用时不是。</p>\n<p>除了 setTimeout 之外，还有一些其他 API 允许您将代码执行推迟到后续任务。 一种方法是使用 postMessage 来加快超时。您也可以使用 requestIdleCallback() 来分解工作。 但是要注意 – requestIdleCallback() 以尽可能低的优先级安排任务，而且只在浏览器空闲时间内进行。当主线程拥挤时,用 requestIdleCallback() 安排的任务可能永远无法运行。</p>\n<h2 id=\"使用-async-await-yield-points\"><a href=\"#使用-async-await-yield-points\" class=\"headerlink\" title=\"使用 async/await yield points\"></a>使用 async/await yield points</h2><p>在本指南的其余部分，你会看到一个短语是 “yield to the main thread”，但是，这意味着什么？为什么你要这么做？你什么时候该这样做？</p>\n<blockquote>\n<p>当你 yield to the main thread，你会给它一个机会来处理比当前排队的任务更重要的任务。理想情况下（ideally），当你有一些关键的面向用户的工作，需要比 yield 更早地执行时，你应该 yield main thread，yield main thread 可以为关键工作创造机会，使其更快地运行。</p>\n</blockquote>\n<p>当任务被分解时，其他任务可以通过浏览器内部优先级方案更好地进行优先级排序。yield main thread 的方法涉及到使用一个 Promise 的组合，该组合与对 setTimeout() 进行的调用进行解析。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yieldToMain</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>虽然这个代码实例返回了一个在调用 setTimeout 后解析的 Promise, 但负责在新任务中运行奇遇代码的并不是这个 Promise，而是 setTimeout 调用。Promise 回调作为微任务而不是任务运行，因此不会 yield main thread</p>\n</blockquote>\n<p>在 saveSettings() 函数中，如果在每次函数调用后 await yieldToMain() 函数，则可以在每次工作后 yield to the main</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create an array of functions to run:</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Loop over the tasks:</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shift the first task off the tasks array:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">    task();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Yield to the main thread:</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> yieldToMain();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>你不必在每次函数调用后都 yield。例如，如果你运行的两个函数会导致用户界面的关键性更新，你可能不想在它们之间 yield。如果可以的话，让这些 tast 先运行，然后考虑在那些不那么关键的或用户看不到的后台工作的函数之间进行 yield。</p>\n</blockquote>\n<p>结果是曾经单一的任务现在被分解为单独的任务</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/wg0FW6S29CzOCbbwk9kK.png?auto=format&w=1600\" alt=\"img_5\"></p>\n<p><em style=\"font-size:12px\">saveSettings() 函数现在将其子函数作为单独的任务执行。</em></p>\n<p>使用基于 Promise 的方法来产生而不是手动使用 setTimeout() 的好处是更好的人体工程学。屈服点成为声明性的，因此更容易编写、阅读和理解。</p>\n<h2 id=\"仅在必要时-yield\"><a href=\"#仅在必要时-yield\" class=\"headerlink\" title=\"仅在必要时 yield\"></a>仅在必要时 yield</h2><p>如果您有一堆任务，但您只想在用户尝试与页面交互时让步怎么办？这就是 isInputPending() 的用途。</p>\n<p>isInputPending() 是一个您可以随时运行以确定用户是否正在尝试与页面元素交互的函数：对 isInputPending() 的调用将返回 true。否则返回 false。</p>\n<p>假设您可有一个需要运行的任务队列，但您不想妨碍任何输入。这段代码 — 它同时使用了 isInputPending() 函数 — 确保在用户尝试与页面交互时输入不会被延迟。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A task queue of functions</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Yield to a pending user input:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navigator.scheduling.isInputPending()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// There&#x27;s a pending user input. Yield here:</span></span><br><span class=\"line\">      <span class=\"keyword\">await</span> yieldToMain();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Shift the the task out of the queue:</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">      task();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 saveSettings() 运行时，它将遍历队列中的任务。如果 isInputPending() 在循环期间返回 true，则 saveSettings() 将调用 yieldToMain() 以便处理用户输入。否则，它将把下一个任务移出队列的前面并继续运行它。它将执行此操作，直到没有其他任务为止。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/snMl3kRlWyJjdbL0qsqM.png?auto=format&w=1600\" alt=\"img_5\"></p>\n<p><em style=\"font-size:12px\">saveSettings()运行一个有五个任务的任务队列，但在第二个工作项运行时，用户已经点击打开了一个菜单。 isInputPending()让位于主线程来处理这个交互，并恢复运行其余的任务。</em></p>\n<blockquote>\n<p>isInputPending()不一定在用户输入后立即返回true。这是因为操作系统需要时间来告诉浏览器发生了交互。这意味着其他代码可能已经开始执行了（正如你在上面的截图中看到的saveToDatabase()函数）。即使你使用isInputPending()，你仍然要限制每个函数的工作量，这是至关重要的。</p>\n</blockquote>\n<p>将 isInputPending() 与让步机制结合使用是让浏览器停止其正在处理的任何任务以响应关键的面向用户的交互的好方法。这可以帮助提高您的页面在许多任务正在进行时在许多情况下响应用户的能力。</p>\n<p>另一种使用isInputPending()的方法–特别是如果你担心为不支持它的浏览器提供退路–是使用基于时间的方法与 可选链操作符 （?.）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A task queue of functions</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> deadline = performance.now() + <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Optional chaining operator used here helps to avoid</span></span><br><span class=\"line\">    <span class=\"comment\">// errors in browsers that don&#x27;t support `isInputPending`:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navigator.scheduling?.isInputPending() || performance.now() &gt;= deadline) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// There&#x27;s a pending user input, or the</span></span><br><span class=\"line\">      <span class=\"comment\">// deadline has been reached. Yield here:</span></span><br><span class=\"line\">      <span class=\"keyword\">await</span> yieldToMain();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Extend the deadline:</span></span><br><span class=\"line\">      deadline += <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Stop the execution of the current loop and</span></span><br><span class=\"line\">      <span class=\"comment\">// move onto the next iteration:</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Shift the the task out of the queue:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">    task();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方法，你可以为不支持isInputPending()的浏览器提供一个后备方案，即使用（并调整）一个截止日期，以便在必要时将工作分开，无论是通过屈服于用户输入，还是在某个时间点之前。</p>\n<h2 id=\"当前-api-的差异\"><a href=\"#当前-api-的差异\" class=\"headerlink\" title=\"当前 api 的差异\"></a>当前 api 的差异</h2><p>到目前为止提到的API可以帮助你分解任务，但它们有一个显著的缺点：当你通过推迟代码在后续任务中运行而屈服于主线程时，该代码会被添加到任务队列的最末端。</p>\n<p>如果你控制了你页面上的所有代码，就有可能创建你自己的scheduler （参考 react 吗，😯），并能对任务进行优先排序，但第三方脚本不会使用你的调度器。实际上，在这样的环境中，你并不能真正地对工作进行优先排序。你只能把它分成几块，或者明确地屈从于用户的互动。</p>\n<p>幸运的是，目前有一个专门的调度器API正在开发中，可以解决这些问题。</p>\n<h2 id=\"一个专门的调度程序API\"><a href=\"#一个专门的调度程序API\" class=\"headerlink\" title=\"一个专门的调度程序API\"></a>一个专门的调度程序API</h2><p>调度器API目前提供了postTask()函数，在撰写本文时，该函数在Chromium浏览器和Firefox的一个标志后面可用。 postTask()允许对任务进行更精细的调度，是帮助浏览器确定工作优先级的一种方法，这样低优先级的任务就会让位于主线程。 postTask()使用 Promise，并接受一个优先级设置。</p>\n<p>postTask() API 具有三个可以使用的 priorities</p>\n<ul>\n<li>‘background’ : 最低优先级任务。</li>\n<li>‘user-visible’ : 中等优先级任务，“用户可见”，如果没有设置优先级，这是默认设置。</li>\n<li>‘user-blocking’: 用于需要高优先级运行的关键任务。</li>\n</ul>\n<p>以下面的代码为例，postTask()API被用来以尽可能高的优先级运行三个任务，并以尽可能低的优先级运行其余两个任务。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Validate the form at high priority</span></span><br><span class=\"line\">  scheduler.postTask(validateForm, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;user-blocking&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Show the spinner at high priority:</span></span><br><span class=\"line\">  scheduler.postTask(showSpinner, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;user-blocking&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Update the database in the background:</span></span><br><span class=\"line\">  scheduler.postTask(saveToDatabase, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;background&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Update the user interface at high priority:</span></span><br><span class=\"line\">  scheduler.postTask(updateUI, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;user-blocking&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send analytics data in the background:</span></span><br><span class=\"line\">  scheduler.postTask(sendAnalytics, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;background&#x27;</span>&#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这里，任务的优先级以浏览器优先级任务（例如用户交互）可以正常工作的方式安排。</p>\n<div style=\"color:red\">子任务执行顺序差异</div>\n\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/ttvI1HqusI02CAdqhjWP.png?auto=format&w=1600\" alt=\"img_6\"></p>\n<p><em style=\"font-size:12px\">当saveSettings()运行时，该函数使用postTask()对各个函数进行调度。面向用户的关键工作被安排在高优先级，而用户不知道的工作被安排在后台运行。这使得用户交互的执行速度更快，因为工作被分割开来并被适当地安排了优先次序。</em></p>\n<p>这是一个如何使用 postTask() 的简单示例。可以实例化不同的 TaskController 对象，这些对象可以在任务之间共享优先级，包括根据需要更改不同 TaskController 实例的优先级的能力。</p>\n<blockquote>\n<p>并非所有浏览器都支持 postTask()。您可以使用特征检测来查看它是否可用，或者考虑使用 polyfill</p>\n</blockquote>\n<h2 id=\"内置的-yield\"><a href=\"#内置的-yield\" class=\"headerlink\" title=\"内置的 yield\"></a>内置的 yield</h2><p>调度器API的一个拟议的部分，目前没有在任何浏览器中实现，就是一个内置的 yield 机制。它的使用类似于本文前面演示的 yieldToMain() 函数。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create an array of functions to run:</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Loop over the tasks:</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shift the first task off the tasks array:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">    task();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Yield to the main thread with the scheduler</span></span><br><span class=\"line\">    <span class=\"comment\">// API&#x27;s own yielding mechanism:</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> scheduler.yield();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您会注意到，上面的代码非常熟悉，但是您没有使用 yieldToMain()，而是调用并等待 scheduler.yield()。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/fyuvJqAV0mLxfZDM9tAm.png?auto=format&w=1294\" alt=\"img_7\"></p>\n<p><em style=\"font-size:12px\">一个没有yield、yield、yield 和 continuation 的任务执行的可视化图。当使用scheduler.yield()时，任务的执行甚至在屈服点之后还能继续执行。</em></p>\n<p>scheduler.yield() 的好处是continuation，这意味着如果你在一组任务中间yield，其他的计划任务会在yield点之后以同样的顺序继续执行。这可以避免第三方脚本中的代码篡夺您的代码执行顺序。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>管理任务是具有挑战性的，但这样做有助于你的页面对用户的互动作出更快速的反应。在管理和确定任务的优先次序方面，没有单一的建议。相反，它是一些不同的技术。重申一下，这些是你在管理任务时要考虑的主要事项。</p>\n<ul>\n<li><p>让给主线程以完成关键的、面向用户的任务。</p>\n</li>\n<li><p>当用户尝试与页面交互时，使用 isInputPending() 让步给主线程。</p>\n</li>\n<li><p>使用 postTask() 对任务进行优先级排序。</p>\n</li>\n<li><p>最后，在你的函数中做尽可能少的工作。</p>\n</li>\n</ul>\n<p>有了这些工具中的一个或多个，你应该能够在你的应用程序中构造工作，使其优先考虑用户的需求，同时确保不太关键的工作仍然能够完成。这将创造一个更好的用户体验，它的响应速度更快，使用起来更愉快。</p>\n<p>Special thanks to Philip Walton for his technical vetting of this article.</p>\n<p>Hero image sourced from Unsplash, courtesy of Amirali Mirhashemian.</p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":8492,"excerpt":"<p>原文：<a href=\"https://web.dev/optimize-long-tasks/\">https://web.dev/optimize-long-tasks/</a></p>\n<blockquote>\n<p>你曾被告诉过，不要阻塞主线程并且分解你的长任务，但是有想过这样做的意义吗？</p>\n</blockquote>\n<p>如果你读了很多关于网站性能的资料, 保持 JavasScript 应用程序快速运行的建议往往涉及以下的建议：</p>\n<ul>\n<li>不要阻塞主线程</li>\n<li>分解你的长任务</li>\n</ul>\n<p>那这些意味着什么？减少 JavaScript 是好的，但这是否自动等同在整个页面生命周期中更快速的用户界面？也许是，也许不是.</p>","more":"<h2 id=\"一个-task-是什么样的？\"><a href=\"#一个-task-是什么样的？\" class=\"headerlink\" title=\"一个 task 是什么样的？\"></a>一个 task 是什么样的？</h2><p>一个 task 是浏览器所做的任何离散的工作，task 包括解析 HTML 和 CSS, 运行 JavaScript 代码, 以及一些你不能直接控制的事情。对于所有的这些，你所编写的并且部署到服务器的 JavaScript 是主要的任务来源。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.23.12.png\" alt=\"img_1\"></p>\n<p>Tasks 以多种方式影响性能。例如，当浏览器在启动时下载 js 文件时，浏览器将任务进行排队并且编译 js 以让其能被执行。然后在页面的生命周期中，（例如通过事件处理程序驱动交互、JavaScript 驱动的动画和后台活动（例如分析收集））启动任务。所有的这些东西，除了 web worker 和类似的 API 都发生在主线程上。</p>\n<h2 id=\"主线程是什么-？\"><a href=\"#主线程是什么-？\" class=\"headerlink\" title=\"主线程是什么 ？\"></a>主线程是什么 ？</h2><p>主线程是大多数任务在浏览器中运行的地方。它被称为主线程的原因是：它是您编写的几乎所有 JavaScript 都在这个线程中工作。</p>\n<p>主线程一次只能处理一个任务。当任务超出某个确定的点（准确来说是 50ms ）时,它们被归类为长任务。如果用户在长时间的任务运行时尝试与页面交互 — 或者如果需要进行重要的渲染更新 — 浏览器将延迟处理该工作。这会导致交互或渲染延迟。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.42.24.png\" alt=\"img_2\"></p>\n<p><em style=\"font-size:12px\">Chrome浏览器的性能分析器中描述的长任务。长任务的角落里有一个红色的三角形，任务的阻塞部分用对角线的红色条纹填充</em></p>\n<p>你需要分解任务。这意味着将一个长任务划分为较小的任务，这些任务单独运行所需的时间更少。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/8Bhl9Ilki4tM0aC1nfn8.png?auto=format&w=1600\" alt=\"img_3\"></p>\n<p><em style=\"font-size:12px\">单个长任务与同一任务分解为五个较短任务的可视化</em></p>\n<p>这很重要，因为当任务被分解时，浏览器有更多机会响应更高优先级的工作——包括用户交互。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0yV0ynwW7FujIwvCbCxQ.png?auto=format&w=1600\" alt=\"img_3\"></p>\n<p><em style=\"font-size:12px\">当任务太长，浏览器不能对互动做出足够快的反应时，与将较长的任务分解成较小的任务时相比，互动会发生什么样的情况，这是一个可视化的结果</em></p>\n<p>如上图的上半部分所述，由用户交互排队的事件处理程序必须等待一个长任务才能运行。这延迟了交互的发生。在下半部分，事件处理程序有机会更快地运行。因为事件处理程序有机会在较小的任务之间运行。它运行得比它必须等待一个很长的任务完成要快。在上半部分中，用户可能已经感受到了延迟，在下半部分，交互可能是即时的。</p>\n<p>然而，问题在于 “分解你的长任务” 和 “不要阻塞主线程”的建议不够具体,除非你已经知道如何做这些事情，这就是本指南将要解释的内容。</p>\n<h2 id=\"任务管理策略\"><a href=\"#任务管理策略\" class=\"headerlink\" title=\"任务管理策略\"></a>任务管理策略</h2><p>在软件架构中，一个常见建议是将您的工作分解更小的功能。这为您提供了更好的代码可读性和项目可维护性的好处。这使得测试更容易编写。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  validateForm();</span><br><span class=\"line\">  showSpinner();</span><br><span class=\"line\">  saveToDatabase();</span><br><span class=\"line\">  updateUI();</span><br><span class=\"line\">  sendAnalytics();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，这里的 saveSettings 函数，在它调用时，它调用了其他五个函数。从概念上讲，这是很好的架构，如果你需要调试这些函数中的一个，你可以便利项目树以弄清每个函数的作用。</p>\n<p>然而，问题在于 JavaScript 不会将这些函数中的每一个作为单独的任务运行，因为它们是在 savaSettings 函数中执行的。<strong>这意味着所有五个功能都作为单独任务运行。</strong></p>\n<blockquote>\n<p>JavaScript 以这种方式工作是因为它使用任务执行的运行到完成模型。这意味着每个任务将一直运行到完成，无论它阻塞主线程多长时间。</p>\n</blockquote>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0c61l5DCix9y0GBa3pFj.png?auto=format&w=1600\" alt=\"img_4\"></p>\n<p><em style=\"font-size:12px\">调用五个函数的单个函数 saveSettings()。这项工作是作为一项长期的整体任务的一部分运行的</em></p>\n<p>在最好的情况下，即使只是这些功能中的一个，也可以为任务的总长度贡献50毫秒或更多。在最坏的情况下，更多的这些任务可以运行相当长的时间–特别是在资源有限的设备上。下面是一套策略，你可以用来分解和优先处理任务。</p>\n<h2 id=\"手动延迟代码执行\"><a href=\"#手动延迟代码执行\" class=\"headerlink\" title=\"手动延迟代码执行\"></a>手动延迟代码执行</h2><p>开发人员使用的一种将任务分解成小任务的方法涉及到 setTimeout(). 使用这种技术，你把函数传给 setTimeout 这将回调的执行推迟到一个单独的任务中，即时你指定的时间为 0。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 完成用户可见的关键工作:</span></span><br><span class=\"line\">  validateForm();</span><br><span class=\"line\">  showSpinner();</span><br><span class=\"line\">  updateUI();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将用户不可见的工作推迟到单独的任务:</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    saveToDatabase();</span><br><span class=\"line\">    sendAnalytics();</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果您有一系列需要按顺序运行的函数，这很有效，但您的代码可能并不总是以这种方式组织。例如，您可能有大量数据需要循环处理，如果您有数百万个项目，该任务可能需要很长时间。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">processData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> item <span class=\"keyword\">of</span> largeDataArray) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Process the individual item here.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 setTimeout 是存在问题的, 因为它的人机工程学（这是什么意思🤔，原文：ergonomics）使其难以实现，并且整个数据数组可能需要很长时间处理，即使每个项目都可以非常快速地处理。这一切加起来，setTimeout 不是合适的工具，至少在这样使用时不是。</p>\n<p>除了 setTimeout 之外，还有一些其他 API 允许您将代码执行推迟到后续任务。 一种方法是使用 postMessage 来加快超时。您也可以使用 requestIdleCallback() 来分解工作。 但是要注意 – requestIdleCallback() 以尽可能低的优先级安排任务，而且只在浏览器空闲时间内进行。当主线程拥挤时,用 requestIdleCallback() 安排的任务可能永远无法运行。</p>\n<h2 id=\"使用-async-await-yield-points\"><a href=\"#使用-async-await-yield-points\" class=\"headerlink\" title=\"使用 async/await yield points\"></a>使用 async/await yield points</h2><p>在本指南的其余部分，你会看到一个短语是 “yield to the main thread”，但是，这意味着什么？为什么你要这么做？你什么时候该这样做？</p>\n<blockquote>\n<p>当你 yield to the main thread，你会给它一个机会来处理比当前排队的任务更重要的任务。理想情况下（ideally），当你有一些关键的面向用户的工作，需要比 yield 更早地执行时，你应该 yield main thread，yield main thread 可以为关键工作创造机会，使其更快地运行。</p>\n</blockquote>\n<p>当任务被分解时，其他任务可以通过浏览器内部优先级方案更好地进行优先级排序。yield main thread 的方法涉及到使用一个 Promise 的组合，该组合与对 setTimeout() 进行的调用进行解析。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yieldToMain</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>虽然这个代码实例返回了一个在调用 setTimeout 后解析的 Promise, 但负责在新任务中运行奇遇代码的并不是这个 Promise，而是 setTimeout 调用。Promise 回调作为微任务而不是任务运行，因此不会 yield main thread</p>\n</blockquote>\n<p>在 saveSettings() 函数中，如果在每次函数调用后 await yieldToMain() 函数，则可以在每次工作后 yield to the main</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create an array of functions to run:</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Loop over the tasks:</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shift the first task off the tasks array:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">    task();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Yield to the main thread:</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> yieldToMain();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>你不必在每次函数调用后都 yield。例如，如果你运行的两个函数会导致用户界面的关键性更新，你可能不想在它们之间 yield。如果可以的话，让这些 tast 先运行，然后考虑在那些不那么关键的或用户看不到的后台工作的函数之间进行 yield。</p>\n</blockquote>\n<p>结果是曾经单一的任务现在被分解为单独的任务</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/wg0FW6S29CzOCbbwk9kK.png?auto=format&w=1600\" alt=\"img_5\"></p>\n<p><em style=\"font-size:12px\">saveSettings() 函数现在将其子函数作为单独的任务执行。</em></p>\n<p>使用基于 Promise 的方法来产生而不是手动使用 setTimeout() 的好处是更好的人体工程学。屈服点成为声明性的，因此更容易编写、阅读和理解。</p>\n<h2 id=\"仅在必要时-yield\"><a href=\"#仅在必要时-yield\" class=\"headerlink\" title=\"仅在必要时 yield\"></a>仅在必要时 yield</h2><p>如果您有一堆任务，但您只想在用户尝试与页面交互时让步怎么办？这就是 isInputPending() 的用途。</p>\n<p>isInputPending() 是一个您可以随时运行以确定用户是否正在尝试与页面元素交互的函数：对 isInputPending() 的调用将返回 true。否则返回 false。</p>\n<p>假设您可有一个需要运行的任务队列，但您不想妨碍任何输入。这段代码 — 它同时使用了 isInputPending() 函数 — 确保在用户尝试与页面交互时输入不会被延迟。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A task queue of functions</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Yield to a pending user input:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navigator.scheduling.isInputPending()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// There&#x27;s a pending user input. Yield here:</span></span><br><span class=\"line\">      <span class=\"keyword\">await</span> yieldToMain();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Shift the the task out of the queue:</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">      task();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 saveSettings() 运行时，它将遍历队列中的任务。如果 isInputPending() 在循环期间返回 true，则 saveSettings() 将调用 yieldToMain() 以便处理用户输入。否则，它将把下一个任务移出队列的前面并继续运行它。它将执行此操作，直到没有其他任务为止。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/snMl3kRlWyJjdbL0qsqM.png?auto=format&w=1600\" alt=\"img_5\"></p>\n<p><em style=\"font-size:12px\">saveSettings()运行一个有五个任务的任务队列，但在第二个工作项运行时，用户已经点击打开了一个菜单。 isInputPending()让位于主线程来处理这个交互，并恢复运行其余的任务。</em></p>\n<blockquote>\n<p>isInputPending()不一定在用户输入后立即返回true。这是因为操作系统需要时间来告诉浏览器发生了交互。这意味着其他代码可能已经开始执行了（正如你在上面的截图中看到的saveToDatabase()函数）。即使你使用isInputPending()，你仍然要限制每个函数的工作量，这是至关重要的。</p>\n</blockquote>\n<p>将 isInputPending() 与让步机制结合使用是让浏览器停止其正在处理的任何任务以响应关键的面向用户的交互的好方法。这可以帮助提高您的页面在许多任务正在进行时在许多情况下响应用户的能力。</p>\n<p>另一种使用isInputPending()的方法–特别是如果你担心为不支持它的浏览器提供退路–是使用基于时间的方法与 可选链操作符 （?.）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A task queue of functions</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> deadline = performance.now() + <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Optional chaining operator used here helps to avoid</span></span><br><span class=\"line\">    <span class=\"comment\">// errors in browsers that don&#x27;t support `isInputPending`:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navigator.scheduling?.isInputPending() || performance.now() &gt;= deadline) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// There&#x27;s a pending user input, or the</span></span><br><span class=\"line\">      <span class=\"comment\">// deadline has been reached. Yield here:</span></span><br><span class=\"line\">      <span class=\"keyword\">await</span> yieldToMain();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Extend the deadline:</span></span><br><span class=\"line\">      deadline += <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Stop the execution of the current loop and</span></span><br><span class=\"line\">      <span class=\"comment\">// move onto the next iteration:</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Shift the the task out of the queue:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">    task();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方法，你可以为不支持isInputPending()的浏览器提供一个后备方案，即使用（并调整）一个截止日期，以便在必要时将工作分开，无论是通过屈服于用户输入，还是在某个时间点之前。</p>\n<h2 id=\"当前-api-的差异\"><a href=\"#当前-api-的差异\" class=\"headerlink\" title=\"当前 api 的差异\"></a>当前 api 的差异</h2><p>到目前为止提到的API可以帮助你分解任务，但它们有一个显著的缺点：当你通过推迟代码在后续任务中运行而屈服于主线程时，该代码会被添加到任务队列的最末端。</p>\n<p>如果你控制了你页面上的所有代码，就有可能创建你自己的scheduler （参考 react 吗，😯），并能对任务进行优先排序，但第三方脚本不会使用你的调度器。实际上，在这样的环境中，你并不能真正地对工作进行优先排序。你只能把它分成几块，或者明确地屈从于用户的互动。</p>\n<p>幸运的是，目前有一个专门的调度器API正在开发中，可以解决这些问题。</p>\n<h2 id=\"一个专门的调度程序API\"><a href=\"#一个专门的调度程序API\" class=\"headerlink\" title=\"一个专门的调度程序API\"></a>一个专门的调度程序API</h2><p>调度器API目前提供了postTask()函数，在撰写本文时，该函数在Chromium浏览器和Firefox的一个标志后面可用。 postTask()允许对任务进行更精细的调度，是帮助浏览器确定工作优先级的一种方法，这样低优先级的任务就会让位于主线程。 postTask()使用 Promise，并接受一个优先级设置。</p>\n<p>postTask() API 具有三个可以使用的 priorities</p>\n<ul>\n<li>‘background’ : 最低优先级任务。</li>\n<li>‘user-visible’ : 中等优先级任务，“用户可见”，如果没有设置优先级，这是默认设置。</li>\n<li>‘user-blocking’: 用于需要高优先级运行的关键任务。</li>\n</ul>\n<p>以下面的代码为例，postTask()API被用来以尽可能高的优先级运行三个任务，并以尽可能低的优先级运行其余两个任务。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Validate the form at high priority</span></span><br><span class=\"line\">  scheduler.postTask(validateForm, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;user-blocking&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Show the spinner at high priority:</span></span><br><span class=\"line\">  scheduler.postTask(showSpinner, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;user-blocking&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Update the database in the background:</span></span><br><span class=\"line\">  scheduler.postTask(saveToDatabase, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;background&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Update the user interface at high priority:</span></span><br><span class=\"line\">  scheduler.postTask(updateUI, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;user-blocking&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send analytics data in the background:</span></span><br><span class=\"line\">  scheduler.postTask(sendAnalytics, &#123;<span class=\"attr\">priority</span>: <span class=\"string\">&#x27;background&#x27;</span>&#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这里，任务的优先级以浏览器优先级任务（例如用户交互）可以正常工作的方式安排。</p>\n<div style=\"color:red\">子任务执行顺序差异</div>\n\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/ttvI1HqusI02CAdqhjWP.png?auto=format&w=1600\" alt=\"img_6\"></p>\n<p><em style=\"font-size:12px\">当saveSettings()运行时，该函数使用postTask()对各个函数进行调度。面向用户的关键工作被安排在高优先级，而用户不知道的工作被安排在后台运行。这使得用户交互的执行速度更快，因为工作被分割开来并被适当地安排了优先次序。</em></p>\n<p>这是一个如何使用 postTask() 的简单示例。可以实例化不同的 TaskController 对象，这些对象可以在任务之间共享优先级，包括根据需要更改不同 TaskController 实例的优先级的能力。</p>\n<blockquote>\n<p>并非所有浏览器都支持 postTask()。您可以使用特征检测来查看它是否可用，或者考虑使用 polyfill</p>\n</blockquote>\n<h2 id=\"内置的-yield\"><a href=\"#内置的-yield\" class=\"headerlink\" title=\"内置的 yield\"></a>内置的 yield</h2><p>调度器API的一个拟议的部分，目前没有在任何浏览器中实现，就是一个内置的 yield 机制。它的使用类似于本文前面演示的 yieldToMain() 函数。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saveSettings</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create an array of functions to run:</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> tasks = [</span><br><span class=\"line\">    validateForm,</span><br><span class=\"line\">    showSpinner,</span><br><span class=\"line\">    saveToDatabase,</span><br><span class=\"line\">    updateUI,</span><br><span class=\"line\">    sendAnalytics</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Loop over the tasks:</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Shift the first task off the tasks array:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> task = tasks.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Run the task:</span></span><br><span class=\"line\">    task();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Yield to the main thread with the scheduler</span></span><br><span class=\"line\">    <span class=\"comment\">// API&#x27;s own yielding mechanism:</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> scheduler.yield();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您会注意到，上面的代码非常熟悉，但是您没有使用 yieldToMain()，而是调用并等待 scheduler.yield()。</p>\n<p><img src=\"https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/fyuvJqAV0mLxfZDM9tAm.png?auto=format&w=1294\" alt=\"img_7\"></p>\n<p><em style=\"font-size:12px\">一个没有yield、yield、yield 和 continuation 的任务执行的可视化图。当使用scheduler.yield()时，任务的执行甚至在屈服点之后还能继续执行。</em></p>\n<p>scheduler.yield() 的好处是continuation，这意味着如果你在一组任务中间yield，其他的计划任务会在yield点之后以同样的顺序继续执行。这可以避免第三方脚本中的代码篡夺您的代码执行顺序。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>管理任务是具有挑战性的，但这样做有助于你的页面对用户的互动作出更快速的反应。在管理和确定任务的优先次序方面，没有单一的建议。相反，它是一些不同的技术。重申一下，这些是你在管理任务时要考虑的主要事项。</p>\n<ul>\n<li><p>让给主线程以完成关键的、面向用户的任务。</p>\n</li>\n<li><p>当用户尝试与页面交互时，使用 isInputPending() 让步给主线程。</p>\n</li>\n<li><p>使用 postTask() 对任务进行优先级排序。</p>\n</li>\n<li><p>最后，在你的函数中做尽可能少的工作。</p>\n</li>\n</ul>\n<p>有了这些工具中的一个或多个，你应该能够在你的应用程序中构造工作，使其优先考虑用户的需求，同时确保不太关键的工作仍然能够完成。这将创造一个更好的用户体验，它的响应速度更快，使用起来更愉快。</p>\n<p>Special thanks to Philip Walton for his technical vetting of this article.</p>\n<p>Hero image sourced from Unsplash, courtesy of Amirali Mirhashemian.</p>"},{"title":"一次base64指令的powershell","date":"2021-11-18T14:33:12.000Z","_content":"\n**事情发生是在一个月黑风高的晚上。。。。不好意思搞错了 😬。**\n**事情是这样的，今天在使用 webpack-dev-middleware 构建开发环境的时候，想要使用 node 启动浏览器并自动打开相关的本地网址。于是就发生了下面的一幕。**\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/u=1178727920,923148390&fm=26&fmt=auto.webp)\n\n<!--more-->\n\n# 关于 open 这个 node_module\n\n**这是一个 node 的依赖包，使用其提供的相关 api 可以用浏览器打开具体的网址。具体用法如下**\n\n```javascript\nconst open = require(\"open\");\n\n// Opens the image in the default image viewer and waits for the opened app to quit.\nawait open(\"unicorn.png\", { wait: true });\nconsole.log(\"The image viewer app quit\");\n\n// Opens the URL in the default browser.\nawait open(\"https://sindresorhus.com\");\n\n// Opens the URL in a specified browser.\nawait open(\"https://sindresorhus.com\", { app: { name: \"firefox\" } });\n\n// Specify app arguments.\nawait open(\"https://sindresorhus.com\", {\n  app: { name: \"google chrome\", arguments: [\"--incognito\"] },\n});\n\n// Open an app\nawait open.openApp(\"xcode\");\n\n// Open an app with arguments\nawait open.openApp(open.apps.chrome, { arguments: [\"--incognito\"] });\n```\n\n**为了一探究竟，它是怎样打开浏览器的，所以我就开始了查看源代码之旅。然后就出现了 powershell 执行 base64 编码的命令这个有趣的事情了。**\n\n# 在 powershell 中使用 base64 编码的指令\n\n**在 open 的源码中，有个 encodeArguments 的数组，大概是这个样子['start', 'http://....' ]，其打开浏览的的主要命令就是**\n\n```powershell\n start (application) <网址>\n```\n\n**而它在传递 powershell 命令时有这样一行代码代码,通过注释我们可以明白这是一个使用 base64 编码的 powershell 命令。于是乎我就开始了我的实验性探究了了**🥳。\n\n```javascript\n// Using Base64-encoded command, accepted by PowerShell, to allow special characters.\ntarget = Buffer.from(encodedArguments.join(\" \"), \"utf16le\").to;\n```\n\n**果不其然，在微软的文档里确实查到了 😃,不过需要注意的是需要 utf-16le 的编码。**\n**_铛铛铛铛！！_**\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/encodedCommand.png)\n\n# 实际测试\n\n**下面我就以 node 打开浏览器为例子，进行 base64 编码命令的测试。**\n**node 打开浏览器的代码如下：**\n\n```javascript\nconst cp = require('child_process');\n\n// 获取base64编码的指令\nlet command = Buffer.from(<目标指令> 'utf16le').toString('base64');\n\nlet subprocess = cp.spawn(`${process.env.SYSTEMROOT}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`, [\n    \"-EncodedCommand\",\n    'cwB0AGEAcgB0ACAAaAB0AHQAcAA6AC8ALwBiAGEAaQBkAHUALgBjAG8AbQA='\n    // 'start http://baidu.com' 上面是这一行命令的编码\n], {\n    windowsVerbatimArguments: true\n})\n```\n\n**下面是效果图**\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/20211191146.gif)\n**奇怪的知识又增加了 🌟**\n","source":"_posts/一次base64指令的powershell.md","raw":"---\ntitle: 一次base64指令的powershell\ndate: 2021-11-18 22:33:12\ntags:\ncategories: 一些趣事的🌟\n---\n\n**事情发生是在一个月黑风高的晚上。。。。不好意思搞错了 😬。**\n**事情是这样的，今天在使用 webpack-dev-middleware 构建开发环境的时候，想要使用 node 启动浏览器并自动打开相关的本地网址。于是就发生了下面的一幕。**\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/u=1178727920,923148390&fm=26&fmt=auto.webp)\n\n<!--more-->\n\n# 关于 open 这个 node_module\n\n**这是一个 node 的依赖包，使用其提供的相关 api 可以用浏览器打开具体的网址。具体用法如下**\n\n```javascript\nconst open = require(\"open\");\n\n// Opens the image in the default image viewer and waits for the opened app to quit.\nawait open(\"unicorn.png\", { wait: true });\nconsole.log(\"The image viewer app quit\");\n\n// Opens the URL in the default browser.\nawait open(\"https://sindresorhus.com\");\n\n// Opens the URL in a specified browser.\nawait open(\"https://sindresorhus.com\", { app: { name: \"firefox\" } });\n\n// Specify app arguments.\nawait open(\"https://sindresorhus.com\", {\n  app: { name: \"google chrome\", arguments: [\"--incognito\"] },\n});\n\n// Open an app\nawait open.openApp(\"xcode\");\n\n// Open an app with arguments\nawait open.openApp(open.apps.chrome, { arguments: [\"--incognito\"] });\n```\n\n**为了一探究竟，它是怎样打开浏览器的，所以我就开始了查看源代码之旅。然后就出现了 powershell 执行 base64 编码的命令这个有趣的事情了。**\n\n# 在 powershell 中使用 base64 编码的指令\n\n**在 open 的源码中，有个 encodeArguments 的数组，大概是这个样子['start', 'http://....' ]，其打开浏览的的主要命令就是**\n\n```powershell\n start (application) <网址>\n```\n\n**而它在传递 powershell 命令时有这样一行代码代码,通过注释我们可以明白这是一个使用 base64 编码的 powershell 命令。于是乎我就开始了我的实验性探究了了**🥳。\n\n```javascript\n// Using Base64-encoded command, accepted by PowerShell, to allow special characters.\ntarget = Buffer.from(encodedArguments.join(\" \"), \"utf16le\").to;\n```\n\n**果不其然，在微软的文档里确实查到了 😃,不过需要注意的是需要 utf-16le 的编码。**\n**_铛铛铛铛！！_**\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/encodedCommand.png)\n\n# 实际测试\n\n**下面我就以 node 打开浏览器为例子，进行 base64 编码命令的测试。**\n**node 打开浏览器的代码如下：**\n\n```javascript\nconst cp = require('child_process');\n\n// 获取base64编码的指令\nlet command = Buffer.from(<目标指令> 'utf16le').toString('base64');\n\nlet subprocess = cp.spawn(`${process.env.SYSTEMROOT}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`, [\n    \"-EncodedCommand\",\n    'cwB0AGEAcgB0ACAAaAB0AHQAcAA6AC8ALwBiAGEAaQBkAHUALgBjAG8AbQA='\n    // 'start http://baidu.com' 上面是这一行命令的编码\n], {\n    windowsVerbatimArguments: true\n})\n```\n\n**下面是效果图**\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/20211191146.gif)\n**奇怪的知识又增加了 🌟**\n","slug":"一次base64指令的powershell","published":1,"updated":"2022-12-31T10:26:33.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyu000ug8v76knk4i2p","content":"<p><strong>事情发生是在一个月黑风高的晚上。。。。不好意思搞错了 😬。</strong><br><strong>事情是这样的，今天在使用 webpack-dev-middleware 构建开发环境的时候，想要使用 node 启动浏览器并自动打开相关的本地网址。于是就发生了下面的一幕。</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/u=1178727920,923148390&fm=26&fmt=auto.webp\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"关于-open-这个-node-module\"><a href=\"#关于-open-这个-node-module\" class=\"headerlink\" title=\"关于 open 这个 node_module\"></a>关于 open 这个 node_module</h1><p><strong>这是一个 node 的依赖包，使用其提供的相关 api 可以用浏览器打开具体的网址。具体用法如下</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> open = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Opens the image in the default image viewer and waits for the opened app to quit.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;unicorn.png&quot;</span>, &#123; <span class=\"attr\">wait</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The image viewer app quit&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Opens the URL in the default browser.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;https://sindresorhus.com&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Opens the URL in a specified browser.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;https://sindresorhus.com&quot;</span>, &#123; <span class=\"attr\">app</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;firefox&quot;</span> &#125; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Specify app arguments.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;https://sindresorhus.com&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">app</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;google chrome&quot;</span>, <span class=\"attr\">arguments</span>: [<span class=\"string\">&quot;--incognito&quot;</span>] &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Open an app</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open.openApp(<span class=\"string\">&quot;xcode&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Open an app with arguments</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open.openApp(open.apps.chrome, &#123; <span class=\"attr\">arguments</span>: [<span class=\"string\">&quot;--incognito&quot;</span>] &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>为了一探究竟，它是怎样打开浏览器的，所以我就开始了查看源代码之旅。然后就出现了 powershell 执行 base64 编码的命令这个有趣的事情了。</strong></p>\n<h1 id=\"在-powershell-中使用-base64-编码的指令\"><a href=\"#在-powershell-中使用-base64-编码的指令\" class=\"headerlink\" title=\"在 powershell 中使用 base64 编码的指令\"></a>在 powershell 中使用 base64 编码的指令</h1><p><strong>在 open 的源码中，有个 encodeArguments 的数组，大概是这个样子[‘start’, ‘http://….’ ]，其打开浏览的的主要命令就是</strong></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">start</span> (application) &lt;网址&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>而它在传递 powershell 命令时有这样一行代码代码,通过注释我们可以明白这是一个使用 base64 编码的 powershell 命令。于是乎我就开始了我的实验性探究了了</strong>🥳。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Using Base64-encoded command, accepted by PowerShell, to allow special characters.</span></span><br><span class=\"line\">target = Buffer.from(encodedArguments.join(<span class=\"string\">&quot; &quot;</span>), <span class=\"string\">&quot;utf16le&quot;</span>).to;</span><br></pre></td></tr></table></figure>\n\n<p><strong>果不其然，在微软的文档里确实查到了 😃,不过需要注意的是需要 utf-16le 的编码。</strong><br><strong><em>铛铛铛铛！！</em></strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/encodedCommand.png\"></p>\n<h1 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h1><p><strong>下面我就以 node 打开浏览器为例子，进行 base64 编码命令的测试。</strong><br><strong>node 打开浏览器的代码如下：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取base64编码的指令</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> command = Buffer.from(&lt;目标指令&gt; <span class=\"string\">&#x27;utf16le&#x27;</span>).toString(<span class=\"string\">&#x27;base64&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> subprocess = cp.spawn(<span class=\"string\">`<span class=\"subst\">$&#123;process.env.SYSTEMROOT&#125;</span>\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`</span>, [</span><br><span class=\"line\">    <span class=\"string\">&quot;-EncodedCommand&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;cwB0AGEAcgB0ACAAaAB0AHQAcAA6AC8ALwBiAGEAaQBkAHUALgBjAG8AbQA=&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#x27;start http://baidu.com&#x27; 上面是这一行命令的编码</span></span><br><span class=\"line\">], &#123;</span><br><span class=\"line\">    <span class=\"attr\">windowsVerbatimArguments</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>下面是效果图</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/20211191146.gif\"><br><strong>奇怪的知识又增加了 🌟</strong></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":1968,"excerpt":"<p><strong>事情发生是在一个月黑风高的晚上。。。。不好意思搞错了 😬。</strong><br><strong>事情是这样的，今天在使用 webpack-dev-middleware 构建开发环境的时候，想要使用 node 启动浏览器并自动打开相关的本地网址。于是就发生了下面的一幕。</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/u=1178727920,923148390&fm=26&fmt=auto.webp\"></p>","more":"<h1 id=\"关于-open-这个-node-module\"><a href=\"#关于-open-这个-node-module\" class=\"headerlink\" title=\"关于 open 这个 node_module\"></a>关于 open 这个 node_module</h1><p><strong>这是一个 node 的依赖包，使用其提供的相关 api 可以用浏览器打开具体的网址。具体用法如下</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> open = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Opens the image in the default image viewer and waits for the opened app to quit.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;unicorn.png&quot;</span>, &#123; <span class=\"attr\">wait</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The image viewer app quit&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Opens the URL in the default browser.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;https://sindresorhus.com&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Opens the URL in a specified browser.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;https://sindresorhus.com&quot;</span>, &#123; <span class=\"attr\">app</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;firefox&quot;</span> &#125; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Specify app arguments.</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open(<span class=\"string\">&quot;https://sindresorhus.com&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">app</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;google chrome&quot;</span>, <span class=\"attr\">arguments</span>: [<span class=\"string\">&quot;--incognito&quot;</span>] &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Open an app</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open.openApp(<span class=\"string\">&quot;xcode&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Open an app with arguments</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> open.openApp(open.apps.chrome, &#123; <span class=\"attr\">arguments</span>: [<span class=\"string\">&quot;--incognito&quot;</span>] &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>为了一探究竟，它是怎样打开浏览器的，所以我就开始了查看源代码之旅。然后就出现了 powershell 执行 base64 编码的命令这个有趣的事情了。</strong></p>\n<h1 id=\"在-powershell-中使用-base64-编码的指令\"><a href=\"#在-powershell-中使用-base64-编码的指令\" class=\"headerlink\" title=\"在 powershell 中使用 base64 编码的指令\"></a>在 powershell 中使用 base64 编码的指令</h1><p><strong>在 open 的源码中，有个 encodeArguments 的数组，大概是这个样子[‘start’, ‘http://….’ ]，其打开浏览的的主要命令就是</strong></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">start</span> (application) &lt;网址&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>而它在传递 powershell 命令时有这样一行代码代码,通过注释我们可以明白这是一个使用 base64 编码的 powershell 命令。于是乎我就开始了我的实验性探究了了</strong>🥳。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Using Base64-encoded command, accepted by PowerShell, to allow special characters.</span></span><br><span class=\"line\">target = Buffer.from(encodedArguments.join(<span class=\"string\">&quot; &quot;</span>), <span class=\"string\">&quot;utf16le&quot;</span>).to;</span><br></pre></td></tr></table></figure>\n\n<p><strong>果不其然，在微软的文档里确实查到了 😃,不过需要注意的是需要 utf-16le 的编码。</strong><br><strong><em>铛铛铛铛！！</em></strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/encodedCommand.png\"></p>\n<h1 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h1><p><strong>下面我就以 node 打开浏览器为例子，进行 base64 编码命令的测试。</strong><br><strong>node 打开浏览器的代码如下：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取base64编码的指令</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> command = Buffer.from(&lt;目标指令&gt; <span class=\"string\">&#x27;utf16le&#x27;</span>).toString(<span class=\"string\">&#x27;base64&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> subprocess = cp.spawn(<span class=\"string\">`<span class=\"subst\">$&#123;process.env.SYSTEMROOT&#125;</span>\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`</span>, [</span><br><span class=\"line\">    <span class=\"string\">&quot;-EncodedCommand&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;cwB0AGEAcgB0ACAAaAB0AHQAcAA6AC8ALwBiAGEAaQBkAHUALgBjAG8AbQA=&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#x27;start http://baidu.com&#x27; 上面是这一行命令的编码</span></span><br><span class=\"line\">], &#123;</span><br><span class=\"line\">    <span class=\"attr\">windowsVerbatimArguments</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>下面是效果图</strong><br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/20211191146.gif\"><br><strong>奇怪的知识又增加了 🌟</strong></p>"},{"title":"聊聊JavaScript事件循环","date":"2022-01-12T15:37:00.000Z","_content":"\n**事情还得从这么一道题开始：**\n\n```javascript\nlet p = new Promise((resolve, reject) => {\n  console.log(\"p\");\n});\nsetTimeout(() => {\n  console.log(\"setTime\");\n}, 0);\nconsole.log(\"end\");\n```\n\n各位想想下面的输出顺序是什么吧？\n我先说一下我的答案吧：\n\n> end\n> p\n> setTime\n\n上面的输出是错误的 😥，我是怎么也不开心啊，于是我就开始翻遍各种资料，其中包括任务、微任务、JavaScript 事件循环、Promise 等等资料。下面就让我来细说吧。\n\n<!-- more-->\n\n**首先介绍几个重要的概念。**\n\n## 相关概念\n\n### 任务（宏任务）\n\n任务有以下三类：\n\n- 一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 &lt;script&gt; 元素中运行代码）。\n- 触发了一个事件，将其**回调函数**添加到任务队列时。\n- 执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的**回调函数**被添加到任务队列时。\n- setImmediate()回调（nodejs）\n- I/O\n- UI\n- postMessage\n- requestAnimationFrame\n\n### 微任务\n\n- promise.then(callback)中的**callback**。\n- MutationObserver\n- process.nextTick(Node.js)\n\n### 执行栈\n\n函数的互相调用会让函数树形成一个调用栈，而函数的执行会按照这个栈来执行，即后进先执行。执行栈会占用 JavaScript 的 run time。\n\n### 执行上下文\n\nJavaScript 在运行时，是运行在执行上下文中的，每一个上下文拥有自己的变量、对象，执行上下文有如下几类：\n\n- 全局上下文：在 JavaScript 开始执行时便创建，是最基础的上下文。\n- 函数上下文（局部上下文）：在函数调用时会创建，一个函数的执行，伴随一个函数上下文的产生。\n- eval 上下文：使用 eval 函数所创建的上下文。\n\n### JavaScript RunTime\n\n执行 js 代码时，运行时引擎拥有一系列的代理，每一个代理由一系列的执行上下文、执行栈、主线程、附加线程（worker）、任务队列、微任务队列。常见的 JavaScript run time 有 iframe、web worker、JavaScript 主线程。\n\n### 事件循环\n\n事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。每一个 JavaScript run time 都会拥有自己的事件循环，RunTime 里面的代理由事件循环所驱动。\n**事件循环分为三类：**\n\n#### window event loop\n\n驱动同源的窗口（Frame,Tab）的事件循环，来自相同 origin 的 window 可能共享同一个事件循环\n\n#### worker event loop\n\n驱动 worker 执行（web workers、 shared workers、service workers）worker 拥有一个或多个与主程序不同的代理。\n\n#### worklet event loop\n\n驱动 worklet 代理的运行。worklet 的类型包括（Worklet、AudioWorklet、PaintWorklet）。\n\n### Promise\n\n一种异步 JavaScript 的解决方案，是对异步方法的返回值的一种描述，用于在将来某个时刻将异步结果返回给使用者，最重要的一点是通过 then 链式调用。\n\n## 事件循环机制\n\n在每一轮事件循环开始时，RunTime 会从任务队列里面取出任务来执行，如果任务里面又添加了新任务到队列里面，新任务不会再本轮事件循环里去执行。当一个任务执行完弹出任务队列时，并且执行栈位空时，这时会开始执行微任务队列，微任务不会像任务那样每次只执行一个，而是将微任务队列里的微任务执行完，即使是在执行微任务时有新的微任务加入到微任务队列，在下一个任务开始以及事件循环迭代结束之前依然会执行微任务。\nOK，说到这儿，我们就可以来分析以下刚才的题了。\n\n## 题目分析\n\n```javascript\nlet p = new Promise((resolve, reject) => {\n  console.log(\"p\");\n});\nsetTimeout(() => {\n  console.log(\"setTime\");\n}, 0);\nconsole.log(\"end\");\n```\n\n**最开始：**将整体代码（一段新程序）加入任务队列。此时的 JavaScript RunTime 的情况如下图：\n![1](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122218.png)\n\n此时任务队列里面仅有整体程序，而微任务队列里面什么也没有。整体程序将进入执行栈中执行。\n**创建 promise 对象：**在创建 promise 对象时，传入了可选参数即：\n\n> (resolve,reject)=>{\n> console.log('p');\n> }\n\n而 Promise 构造器将会在返回新对象之前执行传入的函数参数。所以在执行栈中会执行 console.log('p')，打印出 'p'。\n**执行定时器：**执行定时器，会在传入的延迟时间之后将回调函数加入队列，加入什么队列呢，这里加入的是任务队列，因为 settimeoout 的回调属于宏任务。之后，当前执行栈不为空，会继续执行。\n**打印 end:**在执行 console.log('end')后，现在执行栈为空了，整体程序弹出任务队列。此时任务队列是**不为空的**（包含定时器的回调()=>{console.log('setTime')}）\n\n此时的 JavaScript RunTime 的情况如下图：\n![2](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122230.png)\n这时的任务队列包括定时器的回调，而微任务队列依然为空（这道题就没涉及到微任务。。。）。随后定时器回调将进入执行栈，打印出 setTime。所以最终的打印结果为：\n\n> p\n> end\n> setTime\n\n**这里就注意 promise 的构建就行了，是立即执行，我错的是应为它会进入微任务队列。而 Promise 进入微任务的是 then 的回调函数。**\n\n## 扩展题目\n\n上面的题没有涉及微任务，那我们改改原题目看看：\n\n```javascript\nconst p_2 = new Promise((res, rej) => {\n  console.log(\"p_2\");\n  // 定时器1\n  setTimeout(() => {\n    res(\"定时器1\");\n  }, 0);\n}).then((v) => console.log(v));\n// 定时器2\nsetTimeout(() => {\n  console.log(\"定时器2\");\n}, 0);\nconsole.log(\"end\");\n```\n\n上面新增的是在创建 Promise 对象时增加了一个定时器，以及增加了对 then 的回调。\n依旧从整体程序开始，进入任务队列，当整体程序执行完时，这时的 RunTime 情况如下：\n![3](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122252.png)\n此时输出为：\n\n> p_2\n> end\n\n按照队列先进先出，定时器 1 先进入队列，所以其先于定时器 2 执行。此时定时器 1 的回调进入执行栈执行，执行 res('定时器 1')改变 promise 的状态为 resolve,将 then 的回调加入微任务队列，此时 RunTime 的情况如下：\n![4](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122258.png)\n\n定时器 1 执行完毕弹出任务队列，一个任务执行完后，检索微任务队列，这时微任务队列存在一个 then 回调，所以将其加入执行栈。\n\n现在的输出是：\n\n> p_2\n> end\n> 定时器 1\n\n最终，只剩下了任务队列的定时器 2 回调，重复时间循环，将定时器 2 的回调加入执行栈并执行。最终的输出结果为：\n\n> p_2\n> end\n> 定时器 1\n> 定时器 2\n\n上面这题就说明了一个任务弹出任务队列后会执行微任务队列的任务，可是在上面的概念一章中还提到了一个任务出队列后是要执行所有的微任务，而上面的那一题只有一个微任务看不出什么蹊跷，那么我们再改一下吧。\n\n```javascript\nconst p_2 = new Promise((res, rej) => {\n  console.log(\"p_2\");\n  // 定时器1\n  setTimeout(() => {\n    res(\"定时器1\");\n  }, 0);\n}).then((v) => {\n  console.log(\"微任务开始\");\n  for (let i = 0; i < 5; i++) {\n    window.queueMicrotask(() => {\n      // 函数的内容\n      console.log(i);\n    });\n  }\n});\n// 定时器2\nsetTimeout(() => {\n  console.log(\"定时器2\");\n}, 0);\nconsole.log(\"end\");\n```\n\n这次我们更改了 then 的回调，使用了 window.queueMicrotask()来添加回调到微任务队列。这次是添加五个输出到微任务队列里面。顺着上一题的思路，我们只需将上一题的输出**‘定时器 1’**更改一下就行了。按照一次执行掉所有微任务的结论，我们可以作出如下更改。\n\n> p_2\n> end\n> 微任务开始\n> 0\n> 1\n> 2\n> 3\n> 4\n> 定时器 2\n\n在 chrome 里面试一下吧：）\n![5](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122327.png)\n\n可以看见，结论正确。\n\n**参考：**\n[https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide)\n[https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)\n","source":"_posts/聊聊JavaScript事件循环.md","raw":"---\ntitle: 聊聊JavaScript事件循环\ndate: 2022-01-12 23:37:00\ntags:\ncategories: javascript\n---\n\n**事情还得从这么一道题开始：**\n\n```javascript\nlet p = new Promise((resolve, reject) => {\n  console.log(\"p\");\n});\nsetTimeout(() => {\n  console.log(\"setTime\");\n}, 0);\nconsole.log(\"end\");\n```\n\n各位想想下面的输出顺序是什么吧？\n我先说一下我的答案吧：\n\n> end\n> p\n> setTime\n\n上面的输出是错误的 😥，我是怎么也不开心啊，于是我就开始翻遍各种资料，其中包括任务、微任务、JavaScript 事件循环、Promise 等等资料。下面就让我来细说吧。\n\n<!-- more-->\n\n**首先介绍几个重要的概念。**\n\n## 相关概念\n\n### 任务（宏任务）\n\n任务有以下三类：\n\n- 一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 &lt;script&gt; 元素中运行代码）。\n- 触发了一个事件，将其**回调函数**添加到任务队列时。\n- 执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的**回调函数**被添加到任务队列时。\n- setImmediate()回调（nodejs）\n- I/O\n- UI\n- postMessage\n- requestAnimationFrame\n\n### 微任务\n\n- promise.then(callback)中的**callback**。\n- MutationObserver\n- process.nextTick(Node.js)\n\n### 执行栈\n\n函数的互相调用会让函数树形成一个调用栈，而函数的执行会按照这个栈来执行，即后进先执行。执行栈会占用 JavaScript 的 run time。\n\n### 执行上下文\n\nJavaScript 在运行时，是运行在执行上下文中的，每一个上下文拥有自己的变量、对象，执行上下文有如下几类：\n\n- 全局上下文：在 JavaScript 开始执行时便创建，是最基础的上下文。\n- 函数上下文（局部上下文）：在函数调用时会创建，一个函数的执行，伴随一个函数上下文的产生。\n- eval 上下文：使用 eval 函数所创建的上下文。\n\n### JavaScript RunTime\n\n执行 js 代码时，运行时引擎拥有一系列的代理，每一个代理由一系列的执行上下文、执行栈、主线程、附加线程（worker）、任务队列、微任务队列。常见的 JavaScript run time 有 iframe、web worker、JavaScript 主线程。\n\n### 事件循环\n\n事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。每一个 JavaScript run time 都会拥有自己的事件循环，RunTime 里面的代理由事件循环所驱动。\n**事件循环分为三类：**\n\n#### window event loop\n\n驱动同源的窗口（Frame,Tab）的事件循环，来自相同 origin 的 window 可能共享同一个事件循环\n\n#### worker event loop\n\n驱动 worker 执行（web workers、 shared workers、service workers）worker 拥有一个或多个与主程序不同的代理。\n\n#### worklet event loop\n\n驱动 worklet 代理的运行。worklet 的类型包括（Worklet、AudioWorklet、PaintWorklet）。\n\n### Promise\n\n一种异步 JavaScript 的解决方案，是对异步方法的返回值的一种描述，用于在将来某个时刻将异步结果返回给使用者，最重要的一点是通过 then 链式调用。\n\n## 事件循环机制\n\n在每一轮事件循环开始时，RunTime 会从任务队列里面取出任务来执行，如果任务里面又添加了新任务到队列里面，新任务不会再本轮事件循环里去执行。当一个任务执行完弹出任务队列时，并且执行栈位空时，这时会开始执行微任务队列，微任务不会像任务那样每次只执行一个，而是将微任务队列里的微任务执行完，即使是在执行微任务时有新的微任务加入到微任务队列，在下一个任务开始以及事件循环迭代结束之前依然会执行微任务。\nOK，说到这儿，我们就可以来分析以下刚才的题了。\n\n## 题目分析\n\n```javascript\nlet p = new Promise((resolve, reject) => {\n  console.log(\"p\");\n});\nsetTimeout(() => {\n  console.log(\"setTime\");\n}, 0);\nconsole.log(\"end\");\n```\n\n**最开始：**将整体代码（一段新程序）加入任务队列。此时的 JavaScript RunTime 的情况如下图：\n![1](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122218.png)\n\n此时任务队列里面仅有整体程序，而微任务队列里面什么也没有。整体程序将进入执行栈中执行。\n**创建 promise 对象：**在创建 promise 对象时，传入了可选参数即：\n\n> (resolve,reject)=>{\n> console.log('p');\n> }\n\n而 Promise 构造器将会在返回新对象之前执行传入的函数参数。所以在执行栈中会执行 console.log('p')，打印出 'p'。\n**执行定时器：**执行定时器，会在传入的延迟时间之后将回调函数加入队列，加入什么队列呢，这里加入的是任务队列，因为 settimeoout 的回调属于宏任务。之后，当前执行栈不为空，会继续执行。\n**打印 end:**在执行 console.log('end')后，现在执行栈为空了，整体程序弹出任务队列。此时任务队列是**不为空的**（包含定时器的回调()=>{console.log('setTime')}）\n\n此时的 JavaScript RunTime 的情况如下图：\n![2](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122230.png)\n这时的任务队列包括定时器的回调，而微任务队列依然为空（这道题就没涉及到微任务。。。）。随后定时器回调将进入执行栈，打印出 setTime。所以最终的打印结果为：\n\n> p\n> end\n> setTime\n\n**这里就注意 promise 的构建就行了，是立即执行，我错的是应为它会进入微任务队列。而 Promise 进入微任务的是 then 的回调函数。**\n\n## 扩展题目\n\n上面的题没有涉及微任务，那我们改改原题目看看：\n\n```javascript\nconst p_2 = new Promise((res, rej) => {\n  console.log(\"p_2\");\n  // 定时器1\n  setTimeout(() => {\n    res(\"定时器1\");\n  }, 0);\n}).then((v) => console.log(v));\n// 定时器2\nsetTimeout(() => {\n  console.log(\"定时器2\");\n}, 0);\nconsole.log(\"end\");\n```\n\n上面新增的是在创建 Promise 对象时增加了一个定时器，以及增加了对 then 的回调。\n依旧从整体程序开始，进入任务队列，当整体程序执行完时，这时的 RunTime 情况如下：\n![3](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122252.png)\n此时输出为：\n\n> p_2\n> end\n\n按照队列先进先出，定时器 1 先进入队列，所以其先于定时器 2 执行。此时定时器 1 的回调进入执行栈执行，执行 res('定时器 1')改变 promise 的状态为 resolve,将 then 的回调加入微任务队列，此时 RunTime 的情况如下：\n![4](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122258.png)\n\n定时器 1 执行完毕弹出任务队列，一个任务执行完后，检索微任务队列，这时微任务队列存在一个 then 回调，所以将其加入执行栈。\n\n现在的输出是：\n\n> p_2\n> end\n> 定时器 1\n\n最终，只剩下了任务队列的定时器 2 回调，重复时间循环，将定时器 2 的回调加入执行栈并执行。最终的输出结果为：\n\n> p_2\n> end\n> 定时器 1\n> 定时器 2\n\n上面这题就说明了一个任务弹出任务队列后会执行微任务队列的任务，可是在上面的概念一章中还提到了一个任务出队列后是要执行所有的微任务，而上面的那一题只有一个微任务看不出什么蹊跷，那么我们再改一下吧。\n\n```javascript\nconst p_2 = new Promise((res, rej) => {\n  console.log(\"p_2\");\n  // 定时器1\n  setTimeout(() => {\n    res(\"定时器1\");\n  }, 0);\n}).then((v) => {\n  console.log(\"微任务开始\");\n  for (let i = 0; i < 5; i++) {\n    window.queueMicrotask(() => {\n      // 函数的内容\n      console.log(i);\n    });\n  }\n});\n// 定时器2\nsetTimeout(() => {\n  console.log(\"定时器2\");\n}, 0);\nconsole.log(\"end\");\n```\n\n这次我们更改了 then 的回调，使用了 window.queueMicrotask()来添加回调到微任务队列。这次是添加五个输出到微任务队列里面。顺着上一题的思路，我们只需将上一题的输出**‘定时器 1’**更改一下就行了。按照一次执行掉所有微任务的结论，我们可以作出如下更改。\n\n> p_2\n> end\n> 微任务开始\n> 0\n> 1\n> 2\n> 3\n> 4\n> 定时器 2\n\n在 chrome 里面试一下吧：）\n![5](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122327.png)\n\n可以看见，结论正确。\n\n**参考：**\n[https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide)\n[https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)\n","slug":"聊聊JavaScript事件循环","published":1,"updated":"2022-12-31T10:26:33.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyw000xg8v7hatbgac0","content":"<p><strong>事情还得从这么一道题开始：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;setTime&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>各位想想下面的输出顺序是什么吧？<br>我先说一下我的答案吧：</p>\n<blockquote>\n<p>end<br>p<br>setTime</p>\n</blockquote>\n<p>上面的输出是错误的 😥，我是怎么也不开心啊，于是我就开始翻遍各种资料，其中包括任务、微任务、JavaScript 事件循环、Promise 等等资料。下面就让我来细说吧。</p>\n<span id=\"more\"></span>\n\n<p><strong>首先介绍几个重要的概念。</strong></p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><h3 id=\"任务（宏任务）\"><a href=\"#任务（宏任务）\" class=\"headerlink\" title=\"任务（宏任务）\"></a>任务（宏任务）</h3><p>任务有以下三类：</p>\n<ul>\n<li>一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 &lt;script&gt; 元素中运行代码）。</li>\n<li>触发了一个事件，将其<strong>回调函数</strong>添加到任务队列时。</li>\n<li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的<strong>回调函数</strong>被添加到任务队列时。</li>\n<li>setImmediate()回调（nodejs）</li>\n<li>I/O</li>\n<li>UI</li>\n<li>postMessage</li>\n<li>requestAnimationFrame</li>\n</ul>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><ul>\n<li>promise.then(callback)中的<strong>callback</strong>。</li>\n<li>MutationObserver</li>\n<li>process.nextTick(Node.js)</li>\n</ul>\n<h3 id=\"执行栈\"><a href=\"#执行栈\" class=\"headerlink\" title=\"执行栈\"></a>执行栈</h3><p>函数的互相调用会让函数树形成一个调用栈，而函数的执行会按照这个栈来执行，即后进先执行。执行栈会占用 JavaScript 的 run time。</p>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h3><p>JavaScript 在运行时，是运行在执行上下文中的，每一个上下文拥有自己的变量、对象，执行上下文有如下几类：</p>\n<ul>\n<li>全局上下文：在 JavaScript 开始执行时便创建，是最基础的上下文。</li>\n<li>函数上下文（局部上下文）：在函数调用时会创建，一个函数的执行，伴随一个函数上下文的产生。</li>\n<li>eval 上下文：使用 eval 函数所创建的上下文。</li>\n</ul>\n<h3 id=\"JavaScript-RunTime\"><a href=\"#JavaScript-RunTime\" class=\"headerlink\" title=\"JavaScript RunTime\"></a>JavaScript RunTime</h3><p>执行 js 代码时，运行时引擎拥有一系列的代理，每一个代理由一系列的执行上下文、执行栈、主线程、附加线程（worker）、任务队列、微任务队列。常见的 JavaScript run time 有 iframe、web worker、JavaScript 主线程。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。每一个 JavaScript run time 都会拥有自己的事件循环，RunTime 里面的代理由事件循环所驱动。<br><strong>事件循环分为三类：</strong></p>\n<h4 id=\"window-event-loop\"><a href=\"#window-event-loop\" class=\"headerlink\" title=\"window event loop\"></a>window event loop</h4><p>驱动同源的窗口（Frame,Tab）的事件循环，来自相同 origin 的 window 可能共享同一个事件循环</p>\n<h4 id=\"worker-event-loop\"><a href=\"#worker-event-loop\" class=\"headerlink\" title=\"worker event loop\"></a>worker event loop</h4><p>驱动 worker 执行（web workers、 shared workers、service workers）worker 拥有一个或多个与主程序不同的代理。</p>\n<h4 id=\"worklet-event-loop\"><a href=\"#worklet-event-loop\" class=\"headerlink\" title=\"worklet event loop\"></a>worklet event loop</h4><p>驱动 worklet 代理的运行。worklet 的类型包括（Worklet、AudioWorklet、PaintWorklet）。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>一种异步 JavaScript 的解决方案，是对异步方法的返回值的一种描述，用于在将来某个时刻将异步结果返回给使用者，最重要的一点是通过 then 链式调用。</p>\n<h2 id=\"事件循环机制\"><a href=\"#事件循环机制\" class=\"headerlink\" title=\"事件循环机制\"></a>事件循环机制</h2><p>在每一轮事件循环开始时，RunTime 会从任务队列里面取出任务来执行，如果任务里面又添加了新任务到队列里面，新任务不会再本轮事件循环里去执行。当一个任务执行完弹出任务队列时，并且执行栈位空时，这时会开始执行微任务队列，微任务不会像任务那样每次只执行一个，而是将微任务队列里的微任务执行完，即使是在执行微任务时有新的微任务加入到微任务队列，在下一个任务开始以及事件循环迭代结束之前依然会执行微任务。<br>OK，说到这儿，我们就可以来分析以下刚才的题了。</p>\n<h2 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;setTime&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>最开始：</strong>将整体代码（一段新程序）加入任务队列。此时的 JavaScript RunTime 的情况如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122218.png\" alt=\"1\"></p>\n<p>此时任务队列里面仅有整体程序，而微任务队列里面什么也没有。整体程序将进入执行栈中执行。<br><strong>创建 promise 对象：</strong>在创建 promise 对象时，传入了可选参数即：</p>\n<blockquote>\n<p>(resolve,reject)=&gt;{<br>console.log(‘p’);<br>}</p>\n</blockquote>\n<p>而 Promise 构造器将会在返回新对象之前执行传入的函数参数。所以在执行栈中会执行 console.log(‘p’)，打印出 ‘p’。<br><strong>执行定时器：</strong>执行定时器，会在传入的延迟时间之后将回调函数加入队列，加入什么队列呢，这里加入的是任务队列，因为 settimeoout 的回调属于宏任务。之后，当前执行栈不为空，会继续执行。<br><strong>打印 end:<strong>在执行 console.log(‘end’)后，现在执行栈为空了，整体程序弹出任务队列。此时任务队列是</strong>不为空的</strong>（包含定时器的回调()=&gt;{console.log(‘setTime’)}）</p>\n<p>此时的 JavaScript RunTime 的情况如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122230.png\" alt=\"2\"><br>这时的任务队列包括定时器的回调，而微任务队列依然为空（这道题就没涉及到微任务。。。）。随后定时器回调将进入执行栈，打印出 setTime。所以最终的打印结果为：</p>\n<blockquote>\n<p>p<br>end<br>setTime</p>\n</blockquote>\n<p><strong>这里就注意 promise 的构建就行了，是立即执行，我错的是应为它会进入微任务队列。而 Promise 进入微任务的是 then 的回调函数。</strong></p>\n<h2 id=\"扩展题目\"><a href=\"#扩展题目\" class=\"headerlink\" title=\"扩展题目\"></a>扩展题目</h2><p>上面的题没有涉及微任务，那我们改改原题目看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p_2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">res, rej</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p_2&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 定时器1</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    res(<span class=\"string\">&quot;定时器1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(v));</span><br><span class=\"line\"><span class=\"comment\">// 定时器2</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;定时器2&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面新增的是在创建 Promise 对象时增加了一个定时器，以及增加了对 then 的回调。<br>依旧从整体程序开始，进入任务队列，当整体程序执行完时，这时的 RunTime 情况如下：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122252.png\" alt=\"3\"><br>此时输出为：</p>\n<blockquote>\n<p>p_2<br>end</p>\n</blockquote>\n<p>按照队列先进先出，定时器 1 先进入队列，所以其先于定时器 2 执行。此时定时器 1 的回调进入执行栈执行，执行 res(‘定时器 1’)改变 promise 的状态为 resolve,将 then 的回调加入微任务队列，此时 RunTime 的情况如下：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122258.png\" alt=\"4\"></p>\n<p>定时器 1 执行完毕弹出任务队列，一个任务执行完后，检索微任务队列，这时微任务队列存在一个 then 回调，所以将其加入执行栈。</p>\n<p>现在的输出是：</p>\n<blockquote>\n<p>p_2<br>end<br>定时器 1</p>\n</blockquote>\n<p>最终，只剩下了任务队列的定时器 2 回调，重复时间循环，将定时器 2 的回调加入执行栈并执行。最终的输出结果为：</p>\n<blockquote>\n<p>p_2<br>end<br>定时器 1<br>定时器 2</p>\n</blockquote>\n<p>上面这题就说明了一个任务弹出任务队列后会执行微任务队列的任务，可是在上面的概念一章中还提到了一个任务出队列后是要执行所有的微任务，而上面的那一题只有一个微任务看不出什么蹊跷，那么我们再改一下吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p_2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">res, rej</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p_2&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 定时器1</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    res(<span class=\"string\">&quot;定时器1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;微任务开始&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.queueMicrotask(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 函数的内容</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定时器2</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;定时器2&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这次我们更改了 then 的回调，使用了 window.queueMicrotask()来添加回调到微任务队列。这次是添加五个输出到微任务队列里面。顺着上一题的思路，我们只需将上一题的输出<strong>‘定时器 1’</strong>更改一下就行了。按照一次执行掉所有微任务的结论，我们可以作出如下更改。</p>\n<blockquote>\n<p>p_2<br>end<br>微任务开始<br>0<br>1<br>2<br>3<br>4<br>定时器 2</p>\n</blockquote>\n<p>在 chrome 里面试一下吧：）<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122327.png\" alt=\"5\"></p>\n<p>可以看见，结论正确。</p>\n<p><strong>参考：</strong><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide\">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth\">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth</a></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":4050,"excerpt":"<p><strong>事情还得从这么一道题开始：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;setTime&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>各位想想下面的输出顺序是什么吧？<br>我先说一下我的答案吧：</p>\n<blockquote>\n<p>end<br>p<br>setTime</p>\n</blockquote>\n<p>上面的输出是错误的 😥，我是怎么也不开心啊，于是我就开始翻遍各种资料，其中包括任务、微任务、JavaScript 事件循环、Promise 等等资料。下面就让我来细说吧。</p>","more":"<p><strong>首先介绍几个重要的概念。</strong></p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><h3 id=\"任务（宏任务）\"><a href=\"#任务（宏任务）\" class=\"headerlink\" title=\"任务（宏任务）\"></a>任务（宏任务）</h3><p>任务有以下三类：</p>\n<ul>\n<li>一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 &lt;script&gt; 元素中运行代码）。</li>\n<li>触发了一个事件，将其<strong>回调函数</strong>添加到任务队列时。</li>\n<li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的<strong>回调函数</strong>被添加到任务队列时。</li>\n<li>setImmediate()回调（nodejs）</li>\n<li>I/O</li>\n<li>UI</li>\n<li>postMessage</li>\n<li>requestAnimationFrame</li>\n</ul>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><ul>\n<li>promise.then(callback)中的<strong>callback</strong>。</li>\n<li>MutationObserver</li>\n<li>process.nextTick(Node.js)</li>\n</ul>\n<h3 id=\"执行栈\"><a href=\"#执行栈\" class=\"headerlink\" title=\"执行栈\"></a>执行栈</h3><p>函数的互相调用会让函数树形成一个调用栈，而函数的执行会按照这个栈来执行，即后进先执行。执行栈会占用 JavaScript 的 run time。</p>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h3><p>JavaScript 在运行时，是运行在执行上下文中的，每一个上下文拥有自己的变量、对象，执行上下文有如下几类：</p>\n<ul>\n<li>全局上下文：在 JavaScript 开始执行时便创建，是最基础的上下文。</li>\n<li>函数上下文（局部上下文）：在函数调用时会创建，一个函数的执行，伴随一个函数上下文的产生。</li>\n<li>eval 上下文：使用 eval 函数所创建的上下文。</li>\n</ul>\n<h3 id=\"JavaScript-RunTime\"><a href=\"#JavaScript-RunTime\" class=\"headerlink\" title=\"JavaScript RunTime\"></a>JavaScript RunTime</h3><p>执行 js 代码时，运行时引擎拥有一系列的代理，每一个代理由一系列的执行上下文、执行栈、主线程、附加线程（worker）、任务队列、微任务队列。常见的 JavaScript run time 有 iframe、web worker、JavaScript 主线程。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。每一个 JavaScript run time 都会拥有自己的事件循环，RunTime 里面的代理由事件循环所驱动。<br><strong>事件循环分为三类：</strong></p>\n<h4 id=\"window-event-loop\"><a href=\"#window-event-loop\" class=\"headerlink\" title=\"window event loop\"></a>window event loop</h4><p>驱动同源的窗口（Frame,Tab）的事件循环，来自相同 origin 的 window 可能共享同一个事件循环</p>\n<h4 id=\"worker-event-loop\"><a href=\"#worker-event-loop\" class=\"headerlink\" title=\"worker event loop\"></a>worker event loop</h4><p>驱动 worker 执行（web workers、 shared workers、service workers）worker 拥有一个或多个与主程序不同的代理。</p>\n<h4 id=\"worklet-event-loop\"><a href=\"#worklet-event-loop\" class=\"headerlink\" title=\"worklet event loop\"></a>worklet event loop</h4><p>驱动 worklet 代理的运行。worklet 的类型包括（Worklet、AudioWorklet、PaintWorklet）。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>一种异步 JavaScript 的解决方案，是对异步方法的返回值的一种描述，用于在将来某个时刻将异步结果返回给使用者，最重要的一点是通过 then 链式调用。</p>\n<h2 id=\"事件循环机制\"><a href=\"#事件循环机制\" class=\"headerlink\" title=\"事件循环机制\"></a>事件循环机制</h2><p>在每一轮事件循环开始时，RunTime 会从任务队列里面取出任务来执行，如果任务里面又添加了新任务到队列里面，新任务不会再本轮事件循环里去执行。当一个任务执行完弹出任务队列时，并且执行栈位空时，这时会开始执行微任务队列，微任务不会像任务那样每次只执行一个，而是将微任务队列里的微任务执行完，即使是在执行微任务时有新的微任务加入到微任务队列，在下一个任务开始以及事件循环迭代结束之前依然会执行微任务。<br>OK，说到这儿，我们就可以来分析以下刚才的题了。</p>\n<h2 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;setTime&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>最开始：</strong>将整体代码（一段新程序）加入任务队列。此时的 JavaScript RunTime 的情况如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122218.png\" alt=\"1\"></p>\n<p>此时任务队列里面仅有整体程序，而微任务队列里面什么也没有。整体程序将进入执行栈中执行。<br><strong>创建 promise 对象：</strong>在创建 promise 对象时，传入了可选参数即：</p>\n<blockquote>\n<p>(resolve,reject)=&gt;{<br>console.log(‘p’);<br>}</p>\n</blockquote>\n<p>而 Promise 构造器将会在返回新对象之前执行传入的函数参数。所以在执行栈中会执行 console.log(‘p’)，打印出 ‘p’。<br><strong>执行定时器：</strong>执行定时器，会在传入的延迟时间之后将回调函数加入队列，加入什么队列呢，这里加入的是任务队列，因为 settimeoout 的回调属于宏任务。之后，当前执行栈不为空，会继续执行。<br><strong>打印 end:<strong>在执行 console.log(‘end’)后，现在执行栈为空了，整体程序弹出任务队列。此时任务队列是</strong>不为空的</strong>（包含定时器的回调()=&gt;{console.log(‘setTime’)}）</p>\n<p>此时的 JavaScript RunTime 的情况如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122230.png\" alt=\"2\"><br>这时的任务队列包括定时器的回调，而微任务队列依然为空（这道题就没涉及到微任务。。。）。随后定时器回调将进入执行栈，打印出 setTime。所以最终的打印结果为：</p>\n<blockquote>\n<p>p<br>end<br>setTime</p>\n</blockquote>\n<p><strong>这里就注意 promise 的构建就行了，是立即执行，我错的是应为它会进入微任务队列。而 Promise 进入微任务的是 then 的回调函数。</strong></p>\n<h2 id=\"扩展题目\"><a href=\"#扩展题目\" class=\"headerlink\" title=\"扩展题目\"></a>扩展题目</h2><p>上面的题没有涉及微任务，那我们改改原题目看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p_2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">res, rej</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p_2&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 定时器1</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    res(<span class=\"string\">&quot;定时器1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(v));</span><br><span class=\"line\"><span class=\"comment\">// 定时器2</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;定时器2&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面新增的是在创建 Promise 对象时增加了一个定时器，以及增加了对 then 的回调。<br>依旧从整体程序开始，进入任务队列，当整体程序执行完时，这时的 RunTime 情况如下：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122252.png\" alt=\"3\"><br>此时输出为：</p>\n<blockquote>\n<p>p_2<br>end</p>\n</blockquote>\n<p>按照队列先进先出，定时器 1 先进入队列，所以其先于定时器 2 执行。此时定时器 1 的回调进入执行栈执行，执行 res(‘定时器 1’)改变 promise 的状态为 resolve,将 then 的回调加入微任务队列，此时 RunTime 的情况如下：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122258.png\" alt=\"4\"></p>\n<p>定时器 1 执行完毕弹出任务队列，一个任务执行完后，检索微任务队列，这时微任务队列存在一个 then 回调，所以将其加入执行栈。</p>\n<p>现在的输出是：</p>\n<blockquote>\n<p>p_2<br>end<br>定时器 1</p>\n</blockquote>\n<p>最终，只剩下了任务队列的定时器 2 回调，重复时间循环，将定时器 2 的回调加入执行栈并执行。最终的输出结果为：</p>\n<blockquote>\n<p>p_2<br>end<br>定时器 1<br>定时器 2</p>\n</blockquote>\n<p>上面这题就说明了一个任务弹出任务队列后会执行微任务队列的任务，可是在上面的概念一章中还提到了一个任务出队列后是要执行所有的微任务，而上面的那一题只有一个微任务看不出什么蹊跷，那么我们再改一下吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p_2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">res, rej</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;p_2&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 定时器1</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    res(<span class=\"string\">&quot;定时器1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;微任务开始&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.queueMicrotask(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 函数的内容</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定时器2</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;定时器2&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这次我们更改了 then 的回调，使用了 window.queueMicrotask()来添加回调到微任务队列。这次是添加五个输出到微任务队列里面。顺着上一题的思路，我们只需将上一题的输出<strong>‘定时器 1’</strong>更改一下就行了。按照一次执行掉所有微任务的结论，我们可以作出如下更改。</p>\n<blockquote>\n<p>p_2<br>end<br>微任务开始<br>0<br>1<br>2<br>3<br>4<br>定时器 2</p>\n</blockquote>\n<p>在 chrome 里面试一下吧：）<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122327.png\" alt=\"5\"></p>\n<p>可以看见，结论正确。</p>\n<p><strong>参考：</strong><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide\">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth\">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth</a></p>"},{"title":"对javaScript事件冒泡与事件捕获的再学习","date":"2021-10-20T16:39:16.000Z","_content":"\n# 对 javaScript 事件冒泡与事件捕获的再学习\n\n## DOM 树结构\n\n我们在浏览器上会看见一颗 dom 树，这样的树状结构决定了事件的冒泡与捕获。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1>hello Github Action</h1>\n    <div class=\"out-A\">\n      <div class=\"out-B\">\n        <div class=\"out-C\">hello, I'am C</div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n<!--more-->\n\n## 事件捕获与事件冒泡流程\n\n![事件冒泡与捕获](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bubbling-capturing.png)\n\n#### 首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。\n\n##### 1.当我们点击最里面的 div 标签时，\n\n会先沿着 window->document->parentNodes->EventTarget 路线进行事件捕获，在捕获时会进行对每个 html 对象询问是否绑定了该事件的 listener,如果有则执行它。而事件冒泡则与上面路线相反，但询问行为相同。 ######一般我们给 html 元素添加事件时，会使用 HTMLElement.addEventListener(type, listener, useCapture)给其添加事件处理函数，这里的参数详见[EventTarget.addEventListener](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)。需要特别说明的是第三个参数:\n\n```JavaScript\nuseCapture:boolean\n\nOR\n\n{\n\tcapture:boolean,\n\tonce:boolean,\n\tpassive:boolean\n}\n```\n\n这里的 useCapture 以及 capture 就是设置该事件 listener 是否会在捕获阶段触发，默认为 false。\n\n##### 2.我们以如下例子为例：\n\n###### 这里绘制一个三层嵌套的 div，并给它们添加点击事件。\n\n![div](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/div.png)\n\n```javascript\nvar diva = document.querySelector(\".out-A\");\nvar divb = document.querySelector(\".out-B\");\nvar divc = document.querySelector(\".out-C\");\ndiva.addEventListener(\"click\", function () {\n  console.log(\"A\");\n});\ndivb.addEventListener(\"click\", function () {\n  console.log(\"B\");\n});\ndivc.addEventListener(\"click\", function () {\n  console.log(\"C\");\n});\n```\n\n然后我们点击 C,出现如下结果：\n![output](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/output.png)\n可以看见点击 C 后出现了 C->B->A 的输出顺序，为什么会出现 CBA 的输出顺序呢，因为我们在添加事件时，使用了 capture 的默认值 false,即在事件捕获阶段不会触发事件处理函数。\n\n###### 将 capture 的值设置为 true\n\n```javascript\ndiva.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"A\");\n  },\n  true\n);\ndivb.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"B\");\n  },\n  true\n);\ndivc.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"C\");\n  },\n  true\n);\n```\n\n输出结果为：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202333.png)\n这里可以看见输出结果变为了 ABC，这就是从父节点到 EventTarget 节点的捕获。同时我们也可以发现，如果只给节点添加一个事件处理，这样只会进行捕获或者冒泡。所以下面我们给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.\n\n###### 给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.\n\n```javascript\ndiva.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"A:capture=true\");\n  },\n  true\n);\ndivb.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"B:capture=true\");\n  },\n  true\n);\ndivc.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"C:capture=true\");\n  },\n  true\n);\n//   默认false\ndiva.addEventListener(\"click\", function () {\n  console.log(\"A:capture=false\");\n});\ndivb.addEventListener(\"click\", function () {\n  console.log(\"B:capture=false\");\n});\ndivc.addEventListener(\"click\", function () {\n  console.log(\"C:capture=false\");\n});\n```\n\n我们再次点击 C,输出结果如下：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202341.png)\n看看，这里的结果表示同时出现了事件捕获与事件冒泡。\n<font color=\"green\">到了这里，想必大家对于事件的捕获与冒泡流程有了一定的了解吧。</font>下面我们再来聊聊 Event.stopPropagation()与 Event.preventDefault()\n\n## Event.stopPropagation()与 Event.preventDefault()\n\n#### Event.stopPropagation()\n\n###### 同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：\n\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202353.png)\n\n###### 只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：\n\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110210005.png)\n\n###### 同样的，事件捕获与事件冒泡流程被截断了。\n\n##### 看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\n\n- 而整个流程是：\n\n###### 事件捕获到事件冒泡\n\n###### 父节点到 EventTarget 节点再到父节点\n\n#### Event.preventDefault()\n\n那把上面的改成 preventDefault 又会是怎样的结果呢？那就试试看咯：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202356.png)\n没有影响！！！preventDefault 在没有对事件捕获产生影响，那冒泡阶段呢？也没有影响。所以 preventDefault 只是单纯的阻止了 html 元素的默认事件，比如一个 a 标签能够跳转链接，加上 preventDefault 后就不能跳转了。\n\n## 总结\n\n###### 我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。\n\n参考：[JavaScript eventing deep dive](https://web.dev/eventing-deepdive/)\n","source":"_posts/对javaScript事件冒泡与事件捕获的再学习.md","raw":"---\ntitle: 对javaScript事件冒泡与事件捕获的再学习\ndate: 2021-10-21 00:39:16\ntags: Event\ncategories: javascript\n---\n\n# 对 javaScript 事件冒泡与事件捕获的再学习\n\n## DOM 树结构\n\n我们在浏览器上会看见一颗 dom 树，这样的树状结构决定了事件的冒泡与捕获。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1>hello Github Action</h1>\n    <div class=\"out-A\">\n      <div class=\"out-B\">\n        <div class=\"out-C\">hello, I'am C</div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n<!--more-->\n\n## 事件捕获与事件冒泡流程\n\n![事件冒泡与捕获](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bubbling-capturing.png)\n\n#### 首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。\n\n##### 1.当我们点击最里面的 div 标签时，\n\n会先沿着 window->document->parentNodes->EventTarget 路线进行事件捕获，在捕获时会进行对每个 html 对象询问是否绑定了该事件的 listener,如果有则执行它。而事件冒泡则与上面路线相反，但询问行为相同。 ######一般我们给 html 元素添加事件时，会使用 HTMLElement.addEventListener(type, listener, useCapture)给其添加事件处理函数，这里的参数详见[EventTarget.addEventListener](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)。需要特别说明的是第三个参数:\n\n```JavaScript\nuseCapture:boolean\n\nOR\n\n{\n\tcapture:boolean,\n\tonce:boolean,\n\tpassive:boolean\n}\n```\n\n这里的 useCapture 以及 capture 就是设置该事件 listener 是否会在捕获阶段触发，默认为 false。\n\n##### 2.我们以如下例子为例：\n\n###### 这里绘制一个三层嵌套的 div，并给它们添加点击事件。\n\n![div](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/div.png)\n\n```javascript\nvar diva = document.querySelector(\".out-A\");\nvar divb = document.querySelector(\".out-B\");\nvar divc = document.querySelector(\".out-C\");\ndiva.addEventListener(\"click\", function () {\n  console.log(\"A\");\n});\ndivb.addEventListener(\"click\", function () {\n  console.log(\"B\");\n});\ndivc.addEventListener(\"click\", function () {\n  console.log(\"C\");\n});\n```\n\n然后我们点击 C,出现如下结果：\n![output](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/output.png)\n可以看见点击 C 后出现了 C->B->A 的输出顺序，为什么会出现 CBA 的输出顺序呢，因为我们在添加事件时，使用了 capture 的默认值 false,即在事件捕获阶段不会触发事件处理函数。\n\n###### 将 capture 的值设置为 true\n\n```javascript\ndiva.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"A\");\n  },\n  true\n);\ndivb.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"B\");\n  },\n  true\n);\ndivc.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"C\");\n  },\n  true\n);\n```\n\n输出结果为：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202333.png)\n这里可以看见输出结果变为了 ABC，这就是从父节点到 EventTarget 节点的捕获。同时我们也可以发现，如果只给节点添加一个事件处理，这样只会进行捕获或者冒泡。所以下面我们给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.\n\n###### 给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.\n\n```javascript\ndiva.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"A:capture=true\");\n  },\n  true\n);\ndivb.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"B:capture=true\");\n  },\n  true\n);\ndivc.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"C:capture=true\");\n  },\n  true\n);\n//   默认false\ndiva.addEventListener(\"click\", function () {\n  console.log(\"A:capture=false\");\n});\ndivb.addEventListener(\"click\", function () {\n  console.log(\"B:capture=false\");\n});\ndivc.addEventListener(\"click\", function () {\n  console.log(\"C:capture=false\");\n});\n```\n\n我们再次点击 C,输出结果如下：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202341.png)\n看看，这里的结果表示同时出现了事件捕获与事件冒泡。\n<font color=\"green\">到了这里，想必大家对于事件的捕获与冒泡流程有了一定的了解吧。</font>下面我们再来聊聊 Event.stopPropagation()与 Event.preventDefault()\n\n## Event.stopPropagation()与 Event.preventDefault()\n\n#### Event.stopPropagation()\n\n###### 同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：\n\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202353.png)\n\n###### 只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：\n\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110210005.png)\n\n###### 同样的，事件捕获与事件冒泡流程被截断了。\n\n##### 看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\n\n- 而整个流程是：\n\n###### 事件捕获到事件冒泡\n\n###### 父节点到 EventTarget 节点再到父节点\n\n#### Event.preventDefault()\n\n那把上面的改成 preventDefault 又会是怎样的结果呢？那就试试看咯：\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202356.png)\n没有影响！！！preventDefault 在没有对事件捕获产生影响，那冒泡阶段呢？也没有影响。所以 preventDefault 只是单纯的阻止了 html 元素的默认事件，比如一个 a 标签能够跳转链接，加上 preventDefault 后就不能跳转了。\n\n## 总结\n\n###### 我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。\n\n参考：[JavaScript eventing deep dive](https://web.dev/eventing-deepdive/)\n","slug":"对javaScript事件冒泡与事件捕获的再学习","published":1,"updated":"2022-12-31T10:26:33.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyx000yg8v7heylfa28","content":"<h1 id=\"对-javaScript-事件冒泡与事件捕获的再学习\"><a href=\"#对-javaScript-事件冒泡与事件捕获的再学习\" class=\"headerlink\" title=\"对 javaScript 事件冒泡与事件捕获的再学习\"></a>对 javaScript 事件冒泡与事件捕获的再学习</h1><h2 id=\"DOM-树结构\"><a href=\"#DOM-树结构\" class=\"headerlink\" title=\"DOM 树结构\"></a>DOM 树结构</h2><p>我们在浏览器上会看见一颗 dom 树，这样的树状结构决定了事件的冒泡与捕获。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello Github Action<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;out-A&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;out-B&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;out-C&quot;</span>&gt;</span>hello, I&#x27;am C<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"事件捕获与事件冒泡流程\"><a href=\"#事件捕获与事件冒泡流程\" class=\"headerlink\" title=\"事件捕获与事件冒泡流程\"></a>事件捕获与事件冒泡流程</h2><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bubbling-capturing.png\" alt=\"事件冒泡与捕获\"></p>\n<h4 id=\"首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了-onclick-点击事件。\"><a href=\"#首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了-onclick-点击事件。\" class=\"headerlink\" title=\"首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。\"></a>首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。</h4><h5 id=\"1-当我们点击最里面的-div-标签时，\"><a href=\"#1-当我们点击最里面的-div-标签时，\" class=\"headerlink\" title=\"1.当我们点击最里面的 div 标签时，\"></a>1.当我们点击最里面的 div 标签时，</h5><p>会先沿着 window-&gt;document-&gt;parentNodes-&gt;EventTarget 路线进行事件捕获，在捕获时会进行对每个 html 对象询问是否绑定了该事件的 listener,如果有则执行它。而事件冒泡则与上面路线相反，但询问行为相同。 ######一般我们给 html 元素添加事件时，会使用 HTMLElement.addEventListener(type, listener, useCapture)给其添加事件处理函数，这里的参数详见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\">EventTarget.addEventListener</a>。需要特别说明的是第三个参数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useCapture:boolean</span><br><span class=\"line\"></span><br><span class=\"line\">OR</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">capture</span>:boolean,</span><br><span class=\"line\">\t<span class=\"attr\">once</span>:boolean,</span><br><span class=\"line\">\t<span class=\"attr\">passive</span>:boolean</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 useCapture 以及 capture 就是设置该事件 listener 是否会在捕获阶段触发，默认为 false。</p>\n<h5 id=\"2-我们以如下例子为例：\"><a href=\"#2-我们以如下例子为例：\" class=\"headerlink\" title=\"2.我们以如下例子为例：\"></a>2.我们以如下例子为例：</h5><h6 id=\"这里绘制一个三层嵌套的-div，并给它们添加点击事件。\"><a href=\"#这里绘制一个三层嵌套的-div，并给它们添加点击事件。\" class=\"headerlink\" title=\"这里绘制一个三层嵌套的 div，并给它们添加点击事件。\"></a>这里绘制一个三层嵌套的 div，并给它们添加点击事件。</h6><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/div.png\" alt=\"div\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> diva = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.out-A&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> divb = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.out-B&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> divc = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.out-C&quot;</span>);</span><br><span class=\"line\">diva.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divb.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divc.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后我们点击 C,出现如下结果：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/output.png\" alt=\"output\"><br>可以看见点击 C 后出现了 C-&gt;B-&gt;A 的输出顺序，为什么会出现 CBA 的输出顺序呢，因为我们在添加事件时，使用了 capture 的默认值 false,即在事件捕获阶段不会触发事件处理函数。</p>\n<h6 id=\"将-capture-的值设置为-true\"><a href=\"#将-capture-的值设置为-true\" class=\"headerlink\" title=\"将 capture 的值设置为 true\"></a>将 capture 的值设置为 true</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diva.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divb.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divc.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202333.png\"><br>这里可以看见输出结果变为了 ABC，这就是从父节点到 EventTarget 节点的捕获。同时我们也可以发现，如果只给节点添加一个事件处理，这样只会进行捕获或者冒泡。所以下面我们给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.</p>\n<h6 id=\"给一个节点添加两个-click-事件，并且把其中一个的-capture-设置为-true-另一个为-false\"><a href=\"#给一个节点添加两个-click-事件，并且把其中一个的-capture-设置为-true-另一个为-false\" class=\"headerlink\" title=\"给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.\"></a>给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diva.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A:capture=true&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divb.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B:capture=true&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divc.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C:capture=true&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//   默认false</span></span><br><span class=\"line\">diva.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A:capture=false&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divb.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B:capture=false&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divc.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C:capture=false&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们再次点击 C,输出结果如下：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202341.png\"><br>看看，这里的结果表示同时出现了事件捕获与事件冒泡。<br><font color=\"green\">到了这里，想必大家对于事件的捕获与冒泡流程有了一定的了解吧。</font>下面我们再来聊聊 Event.stopPropagation()与 Event.preventDefault()</p>\n<h2 id=\"Event-stopPropagation-与-Event-preventDefault\"><a href=\"#Event-stopPropagation-与-Event-preventDefault\" class=\"headerlink\" title=\"Event.stopPropagation()与 Event.preventDefault()\"></a>Event.stopPropagation()与 Event.preventDefault()</h2><h4 id=\"Event-stopPropagation\"><a href=\"#Event-stopPropagation\" class=\"headerlink\" title=\"Event.stopPropagation()\"></a>Event.stopPropagation()</h4><h6 id=\"同样是上面的例子。我们给-A-capture-true（捕获阶段）的那个事件处理加上-stopPropagation-看看下面的输出：\"><a href=\"#同样是上面的例子。我们给-A-capture-true（捕获阶段）的那个事件处理加上-stopPropagation-看看下面的输出：\" class=\"headerlink\" title=\"同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：\"></a>同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：</h6><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202353.png\"></p>\n<h6 id=\"只输出了捕获阶段的-A-处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加-stopPropagation-到-C-的冒泡处理函数里，即在-C-capture-false-里面。下面是输出结果：\"><a href=\"#只输出了捕获阶段的-A-处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加-stopPropagation-到-C-的冒泡处理函数里，即在-C-capture-false-里面。下面是输出结果：\" class=\"headerlink\" title=\"只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：\"></a>只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：</h6><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110210005.png\"></p>\n<h6 id=\"同样的，事件捕获与事件冒泡流程被截断了。\"><a href=\"#同样的，事件捕获与事件冒泡流程被截断了。\" class=\"headerlink\" title=\"同样的，事件捕获与事件冒泡流程被截断了。\"></a>同样的，事件捕获与事件冒泡流程被截断了。</h6><h5 id=\"看到这里，想必明白了吧，stopPropagation-就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\"><a href=\"#看到这里，想必明白了吧，stopPropagation-就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\" class=\"headerlink\" title=\"看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\"></a>看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。</h5><ul>\n<li>而整个流程是：</li>\n</ul>\n<h6 id=\"事件捕获到事件冒泡\"><a href=\"#事件捕获到事件冒泡\" class=\"headerlink\" title=\"事件捕获到事件冒泡\"></a>事件捕获到事件冒泡</h6><h6 id=\"父节点到-EventTarget-节点再到父节点\"><a href=\"#父节点到-EventTarget-节点再到父节点\" class=\"headerlink\" title=\"父节点到 EventTarget 节点再到父节点\"></a>父节点到 EventTarget 节点再到父节点</h6><h4 id=\"Event-preventDefault\"><a href=\"#Event-preventDefault\" class=\"headerlink\" title=\"Event.preventDefault()\"></a>Event.preventDefault()</h4><p>那把上面的改成 preventDefault 又会是怎样的结果呢？那就试试看咯：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202356.png\"><br>没有影响！！！preventDefault 在没有对事件捕获产生影响，那冒泡阶段呢？也没有影响。所以 preventDefault 只是单纯的阻止了 html 元素的默认事件，比如一个 a 标签能够跳转链接，加上 preventDefault 后就不能跳转了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h6 id=\"我们可以看到，可以使用-stopPropagation-阻止事件的冒泡。通常我们在给-html-元素添加事件时，一般都会使用-capture-的默认值：false-这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在-capture-为-false-的情况下，给-EventTarget-元素添加-stopPropagation-就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发-EventTarget-的事件处理函数，从而减少不必要的副作用。\"><a href=\"#我们可以看到，可以使用-stopPropagation-阻止事件的冒泡。通常我们在给-html-元素添加事件时，一般都会使用-capture-的默认值：false-这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在-capture-为-false-的情况下，给-EventTarget-元素添加-stopPropagation-就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发-EventTarget-的事件处理函数，从而减少不必要的副作用。\" class=\"headerlink\" title=\"我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。\"></a>我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。</h6><p>参考：<a href=\"https://web.dev/eventing-deepdive/\">JavaScript eventing deep dive</a></p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":3868,"excerpt":"<h1 id=\"对-javaScript-事件冒泡与事件捕获的再学习\"><a href=\"#对-javaScript-事件冒泡与事件捕获的再学习\" class=\"headerlink\" title=\"对 javaScript 事件冒泡与事件捕获的再学习\"></a>对 javaScript 事件冒泡与事件捕获的再学习</h1><h2 id=\"DOM-树结构\"><a href=\"#DOM-树结构\" class=\"headerlink\" title=\"DOM 树结构\"></a>DOM 树结构</h2><p>我们在浏览器上会看见一颗 dom 树，这样的树状结构决定了事件的冒泡与捕获。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello Github Action<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;out-A&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;out-B&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;out-C&quot;</span>&gt;</span>hello, I&#x27;am C<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"事件捕获与事件冒泡流程\"><a href=\"#事件捕获与事件冒泡流程\" class=\"headerlink\" title=\"事件捕获与事件冒泡流程\"></a>事件捕获与事件冒泡流程</h2><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bubbling-capturing.png\" alt=\"事件冒泡与捕获\"></p>\n<h4 id=\"首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了-onclick-点击事件。\"><a href=\"#首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了-onclick-点击事件。\" class=\"headerlink\" title=\"首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。\"></a>首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。</h4><h5 id=\"1-当我们点击最里面的-div-标签时，\"><a href=\"#1-当我们点击最里面的-div-标签时，\" class=\"headerlink\" title=\"1.当我们点击最里面的 div 标签时，\"></a>1.当我们点击最里面的 div 标签时，</h5><p>会先沿着 window-&gt;document-&gt;parentNodes-&gt;EventTarget 路线进行事件捕获，在捕获时会进行对每个 html 对象询问是否绑定了该事件的 listener,如果有则执行它。而事件冒泡则与上面路线相反，但询问行为相同。 ######一般我们给 html 元素添加事件时，会使用 HTMLElement.addEventListener(type, listener, useCapture)给其添加事件处理函数，这里的参数详见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\">EventTarget.addEventListener</a>。需要特别说明的是第三个参数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useCapture:boolean</span><br><span class=\"line\"></span><br><span class=\"line\">OR</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">capture</span>:boolean,</span><br><span class=\"line\">\t<span class=\"attr\">once</span>:boolean,</span><br><span class=\"line\">\t<span class=\"attr\">passive</span>:boolean</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 useCapture 以及 capture 就是设置该事件 listener 是否会在捕获阶段触发，默认为 false。</p>\n<h5 id=\"2-我们以如下例子为例：\"><a href=\"#2-我们以如下例子为例：\" class=\"headerlink\" title=\"2.我们以如下例子为例：\"></a>2.我们以如下例子为例：</h5><h6 id=\"这里绘制一个三层嵌套的-div，并给它们添加点击事件。\"><a href=\"#这里绘制一个三层嵌套的-div，并给它们添加点击事件。\" class=\"headerlink\" title=\"这里绘制一个三层嵌套的 div，并给它们添加点击事件。\"></a>这里绘制一个三层嵌套的 div，并给它们添加点击事件。</h6><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/div.png\" alt=\"div\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> diva = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.out-A&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> divb = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.out-B&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> divc = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.out-C&quot;</span>);</span><br><span class=\"line\">diva.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divb.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divc.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后我们点击 C,出现如下结果：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/output.png\" alt=\"output\"><br>可以看见点击 C 后出现了 C-&gt;B-&gt;A 的输出顺序，为什么会出现 CBA 的输出顺序呢，因为我们在添加事件时，使用了 capture 的默认值 false,即在事件捕获阶段不会触发事件处理函数。</p>\n<h6 id=\"将-capture-的值设置为-true\"><a href=\"#将-capture-的值设置为-true\" class=\"headerlink\" title=\"将 capture 的值设置为 true\"></a>将 capture 的值设置为 true</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diva.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divb.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divc.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202333.png\"><br>这里可以看见输出结果变为了 ABC，这就是从父节点到 EventTarget 节点的捕获。同时我们也可以发现，如果只给节点添加一个事件处理，这样只会进行捕获或者冒泡。所以下面我们给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.</p>\n<h6 id=\"给一个节点添加两个-click-事件，并且把其中一个的-capture-设置为-true-另一个为-false\"><a href=\"#给一个节点添加两个-click-事件，并且把其中一个的-capture-设置为-true-另一个为-false\" class=\"headerlink\" title=\"给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.\"></a>给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diva.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A:capture=true&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divb.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B:capture=true&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\">divc.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">&quot;click&quot;</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C:capture=true&quot;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//   默认false</span></span><br><span class=\"line\">diva.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;A:capture=false&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divb.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;B:capture=false&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">divc.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;C:capture=false&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们再次点击 C,输出结果如下：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202341.png\"><br>看看，这里的结果表示同时出现了事件捕获与事件冒泡。<br><font color=\"green\">到了这里，想必大家对于事件的捕获与冒泡流程有了一定的了解吧。</font>下面我们再来聊聊 Event.stopPropagation()与 Event.preventDefault()</p>\n<h2 id=\"Event-stopPropagation-与-Event-preventDefault\"><a href=\"#Event-stopPropagation-与-Event-preventDefault\" class=\"headerlink\" title=\"Event.stopPropagation()与 Event.preventDefault()\"></a>Event.stopPropagation()与 Event.preventDefault()</h2><h4 id=\"Event-stopPropagation\"><a href=\"#Event-stopPropagation\" class=\"headerlink\" title=\"Event.stopPropagation()\"></a>Event.stopPropagation()</h4><h6 id=\"同样是上面的例子。我们给-A-capture-true（捕获阶段）的那个事件处理加上-stopPropagation-看看下面的输出：\"><a href=\"#同样是上面的例子。我们给-A-capture-true（捕获阶段）的那个事件处理加上-stopPropagation-看看下面的输出：\" class=\"headerlink\" title=\"同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：\"></a>同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：</h6><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202353.png\"></p>\n<h6 id=\"只输出了捕获阶段的-A-处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加-stopPropagation-到-C-的冒泡处理函数里，即在-C-capture-false-里面。下面是输出结果：\"><a href=\"#只输出了捕获阶段的-A-处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加-stopPropagation-到-C-的冒泡处理函数里，即在-C-capture-false-里面。下面是输出结果：\" class=\"headerlink\" title=\"只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：\"></a>只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：</h6><p><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110210005.png\"></p>\n<h6 id=\"同样的，事件捕获与事件冒泡流程被截断了。\"><a href=\"#同样的，事件捕获与事件冒泡流程被截断了。\" class=\"headerlink\" title=\"同样的，事件捕获与事件冒泡流程被截断了。\"></a>同样的，事件捕获与事件冒泡流程被截断了。</h6><h5 id=\"看到这里，想必明白了吧，stopPropagation-就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\"><a href=\"#看到这里，想必明白了吧，stopPropagation-就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\" class=\"headerlink\" title=\"看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。\"></a>看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。</h5><ul>\n<li>而整个流程是：</li>\n</ul>\n<h6 id=\"事件捕获到事件冒泡\"><a href=\"#事件捕获到事件冒泡\" class=\"headerlink\" title=\"事件捕获到事件冒泡\"></a>事件捕获到事件冒泡</h6><h6 id=\"父节点到-EventTarget-节点再到父节点\"><a href=\"#父节点到-EventTarget-节点再到父节点\" class=\"headerlink\" title=\"父节点到 EventTarget 节点再到父节点\"></a>父节点到 EventTarget 节点再到父节点</h6><h4 id=\"Event-preventDefault\"><a href=\"#Event-preventDefault\" class=\"headerlink\" title=\"Event.preventDefault()\"></a>Event.preventDefault()</h4><p>那把上面的改成 preventDefault 又会是怎样的结果呢？那就试试看咯：<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202356.png\"><br>没有影响！！！preventDefault 在没有对事件捕获产生影响，那冒泡阶段呢？也没有影响。所以 preventDefault 只是单纯的阻止了 html 元素的默认事件，比如一个 a 标签能够跳转链接，加上 preventDefault 后就不能跳转了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h6 id=\"我们可以看到，可以使用-stopPropagation-阻止事件的冒泡。通常我们在给-html-元素添加事件时，一般都会使用-capture-的默认值：false-这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在-capture-为-false-的情况下，给-EventTarget-元素添加-stopPropagation-就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发-EventTarget-的事件处理函数，从而减少不必要的副作用。\"><a href=\"#我们可以看到，可以使用-stopPropagation-阻止事件的冒泡。通常我们在给-html-元素添加事件时，一般都会使用-capture-的默认值：false-这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在-capture-为-false-的情况下，给-EventTarget-元素添加-stopPropagation-就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发-EventTarget-的事件处理函数，从而减少不必要的副作用。\" class=\"headerlink\" title=\"我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。\"></a>我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。</h6><p>参考：<a href=\"https://web.dev/eventing-deepdive/\">JavaScript eventing deep dive</a></p>"},{"title":"谈谈cookie、session与token(jwt)","date":"2021-12-07T14:04:05.000Z","_content":"\n**首先呢，网上关于它们的文章已经很多了，在这里我就只是来记录以下我的理解，其实也是看其他网上内容的一个总结吧。**\n\n> **前言：由于 HTTP 协议无状态的缺陷。WEB 的设计者们提出了 Cookie 和 Session 两种解决机制。而 token,通常是 jwt(json web token)作为一种用户身份令牌，也常常用于记录 http 的状态存储，通常是在用户登录后，伴随每一次请求发送给给后端。下面就来聊聊它们。**\n\n <!--more-->\n\n### cookie\n\n#### 概念\n\nCookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。\n包括：\n\n1. Name/Value：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌。\n2. Expires 属性：设置 Cookie 的生存期。有两种存储类型的 Cookie：会话性与持久性。Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。\n3. Domain 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域（域名前缀不同）可以设置或获取其父域的 Cookie。\n4. Secure 属性：指定是否使用 HTTPS 安全协议发送 Cookie。\n5. Path 属性：定义了 Web 站点上可以访问该 Cookie 的目录。\n6. HTTPOnly 属性 ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头。\n   **好了，以上内容是来自百度百科。简单地做个总结：cookie 是一种存储在客户端的小型文本数据，里面的类容有键值对、生存周期、访问域、是否使用 http,web 站点可访问 cookie 的目录以及是否允许客户端读取 cookie。**\n\n#### 安全性\n\n**XSRF/CSRF（跨站请求伪造）**：利用的是 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器,却不能保证请求本身是用户自愿发出的。这里有一些如 Firefox、Opera 等浏览器使用单进程机制，**多个窗口或标签使用同一个进程，共享 Cookie 等会话数据**。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用“CTRL+N” 或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行 IE 可执行程序打开窗口时，才会创建新的进程。**Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。**因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 CSRF 攻击篡夺用户的会话 Cookie 创造了条件。却不能保证请求本身是用户自愿发出的。其最典型的例子**就是当 cookie 还没过期时，用户浏览的网站有与其没过期的网站的一些 api 请求，那么当用户浏览这个恶意网站时就可能会受到危害**。\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202112161949.png)\n**会话定置(Session Fixation)攻击**是指，攻击者向受害者主机注入自己控制的认证 Cookie 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。注入 Cookie 的方法包括：使用跨站脚本或木马等恶意程序；或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过 HTTP 响应中的 Set-Cookie 头将攻击者拥有的该域 Cookie 发送给用户等。因为 sessionID 一般都会放在 cookie 中存储，所以会容易受到会话定制攻击。\n\n### Session\n\n#### 概念\n\n与 cookie 相比，session 就是存放在服务端了，它表示在客户端登录时，服务端会发放一个 sessionid 到客户端，它一般存在 cookie 中，所以客户端以后的请求就会在请求头的 cookies 字段中携带这个信息。这样服务端就可以通过这个数据判断客户端的登录状态。这就好比我们去点菜，点好了后商家给我们一个号码牌，等菜好了，就送往相应号码牌的位置。\n\n#### 安全性\n\n因为 session 是放在服务器上的，所以一般的安全性就考虑 sessionid 的伪造与截获。如果 sessionid 是放在 cookie 中的，那么 cookie 的时效就决定了 sessionid 即登录状态的时效。\n需要注意的就是会话固定（session fixation)：意思是攻击者先自己获取一个 sessionid,然后假冒一个网站并将连接发给被攻击的人，当受害者登录后，攻击者就可以劫持受害人的会话。因为在攻击者登录获取 sessionid 后，网络服务器看到会话已经建立，无需创建新的会话。所以攻击者就成功地冒充了受害者，从而获取了受害者的信息。\n\n### Token（JWT）\n\n#### 概念：\n\nJSON Web Token (JWT) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。由于此信息经过数字签名，因此可以验证和信任。 JWT 可以使用秘密（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。尽管 JWTs 可以被加密，以便在各方之间提供保密性，但我们将专注于签名的令牌。签名的令牌可以验证其中包含的索赔的完整性，而加密的令牌则对其他各方隐藏这些索赔。当令牌使用公钥/私钥对签名时，签名也证明了只有持有私钥的一方才是签名者。 - - - - https://jwt.io/introduction\n\n#### 组成：\n\n> 形如：xxxxx.yyyyy.zzzzz\n\n1. header：标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。**然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第一部分。**\n\n```javascript\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n2. payload：包含一些声明， 声明是关于实体（通常是用户）和附加数据的声明。共有三种类型的 claims：注册负载、公共负载和私人负载。\n\n- Registered claims（注册）: 通常有四个部分，iss(issuer)，exp (expiration time), sub (subject), aud (audience)。还有一些其他的，比如：nbf (Not Before)、iat (Issued At)、jti (JWT ID)。\n  **iss（issuer）**：声明标识发行该证书的委托人。\n  **exp (expiration time)**：声明标识了过期时间或之后不得接受 JWT 进行处理\n  **sub (subject)**：JWT 的主题。 JWT 中的声明通常是声明，关于主题。主题值必须要么被限定为在发行人的上下文中是本地唯一的，或者是全球唯一的。\n  **aud (audience)**：声明标识了 JWT 的接收者。\n- Public claims（公共）：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在 [IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) 中定义，或者定义为包含抗冲突命名空间的 URI。\n- Private claims（私有）：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明，这些声明既不是注册声明也不是公开声明。此声明的处理通常是**特定于应用程序**的。\n\n**然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第二部分。**\n**这里，header 与 payload 都是可以直接通过 base64url 解码获得其 json 数据的。** 3. signature：签名，这是 jwt 最核心的部分，就是包含 base64 编码的 header,payload,以及 secret，最后再将整个使用加密算法进行加密。其中的 secret 就是服务端发放的私钥。\n\n> 形如：\n> HMACSHA256(\n> base64UrlEncode(header) + \".\" +\n> base64UrlEncode(payload),\n> secret\n> )\n\n#### 使用\n\n每当用户想要访问受保护的路由或资源时，用户代理应发送 JWT，通常在使用 Bearer 模式的 Authorization 标头中。标题的内容应如下所示：\n\n```javascript\nAuthorization: Bearer <token>\n```\n\n如果令牌在 Authorization 标头中发送，则跨源资源共享 (CORS) 不会成为问题，因为它不使用 cookie（cookie 是不能跨域的）。这一点就非常适合单点登录。\n\n#### 安全性\n\n因为在 jwt 签发的时候，密钥是服务端生成的，所以来说是比较安全的，当 payload 的数据修改后，发送给服务端，服务端会采用相同的加密算法生成一个 token 副本与之前签发的进行对比，显然，修改后的数据再次加密后与之前的 token 对比肯定不同。\n在 payload 中，因为是 base64url 编码的，所以很容易解码获取信息，因此不宜在里面放一些比较重要的信息。\n","source":"_posts/谈谈cookie、session与token-jwt.md","raw":"---\ntitle: 谈谈cookie、session与token(jwt)\ndate: 2021-12-07 22:04:05\ncategories: web\n---\n\n**首先呢，网上关于它们的文章已经很多了，在这里我就只是来记录以下我的理解，其实也是看其他网上内容的一个总结吧。**\n\n> **前言：由于 HTTP 协议无状态的缺陷。WEB 的设计者们提出了 Cookie 和 Session 两种解决机制。而 token,通常是 jwt(json web token)作为一种用户身份令牌，也常常用于记录 http 的状态存储，通常是在用户登录后，伴随每一次请求发送给给后端。下面就来聊聊它们。**\n\n <!--more-->\n\n### cookie\n\n#### 概念\n\nCookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。\n包括：\n\n1. Name/Value：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌。\n2. Expires 属性：设置 Cookie 的生存期。有两种存储类型的 Cookie：会话性与持久性。Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。\n3. Domain 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域（域名前缀不同）可以设置或获取其父域的 Cookie。\n4. Secure 属性：指定是否使用 HTTPS 安全协议发送 Cookie。\n5. Path 属性：定义了 Web 站点上可以访问该 Cookie 的目录。\n6. HTTPOnly 属性 ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头。\n   **好了，以上内容是来自百度百科。简单地做个总结：cookie 是一种存储在客户端的小型文本数据，里面的类容有键值对、生存周期、访问域、是否使用 http,web 站点可访问 cookie 的目录以及是否允许客户端读取 cookie。**\n\n#### 安全性\n\n**XSRF/CSRF（跨站请求伪造）**：利用的是 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器,却不能保证请求本身是用户自愿发出的。这里有一些如 Firefox、Opera 等浏览器使用单进程机制，**多个窗口或标签使用同一个进程，共享 Cookie 等会话数据**。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用“CTRL+N” 或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行 IE 可执行程序打开窗口时，才会创建新的进程。**Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。**因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 CSRF 攻击篡夺用户的会话 Cookie 创造了条件。却不能保证请求本身是用户自愿发出的。其最典型的例子**就是当 cookie 还没过期时，用户浏览的网站有与其没过期的网站的一些 api 请求，那么当用户浏览这个恶意网站时就可能会受到危害**。\n![](https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202112161949.png)\n**会话定置(Session Fixation)攻击**是指，攻击者向受害者主机注入自己控制的认证 Cookie 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。注入 Cookie 的方法包括：使用跨站脚本或木马等恶意程序；或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过 HTTP 响应中的 Set-Cookie 头将攻击者拥有的该域 Cookie 发送给用户等。因为 sessionID 一般都会放在 cookie 中存储，所以会容易受到会话定制攻击。\n\n### Session\n\n#### 概念\n\n与 cookie 相比，session 就是存放在服务端了，它表示在客户端登录时，服务端会发放一个 sessionid 到客户端，它一般存在 cookie 中，所以客户端以后的请求就会在请求头的 cookies 字段中携带这个信息。这样服务端就可以通过这个数据判断客户端的登录状态。这就好比我们去点菜，点好了后商家给我们一个号码牌，等菜好了，就送往相应号码牌的位置。\n\n#### 安全性\n\n因为 session 是放在服务器上的，所以一般的安全性就考虑 sessionid 的伪造与截获。如果 sessionid 是放在 cookie 中的，那么 cookie 的时效就决定了 sessionid 即登录状态的时效。\n需要注意的就是会话固定（session fixation)：意思是攻击者先自己获取一个 sessionid,然后假冒一个网站并将连接发给被攻击的人，当受害者登录后，攻击者就可以劫持受害人的会话。因为在攻击者登录获取 sessionid 后，网络服务器看到会话已经建立，无需创建新的会话。所以攻击者就成功地冒充了受害者，从而获取了受害者的信息。\n\n### Token（JWT）\n\n#### 概念：\n\nJSON Web Token (JWT) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。由于此信息经过数字签名，因此可以验证和信任。 JWT 可以使用秘密（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。尽管 JWTs 可以被加密，以便在各方之间提供保密性，但我们将专注于签名的令牌。签名的令牌可以验证其中包含的索赔的完整性，而加密的令牌则对其他各方隐藏这些索赔。当令牌使用公钥/私钥对签名时，签名也证明了只有持有私钥的一方才是签名者。 - - - - https://jwt.io/introduction\n\n#### 组成：\n\n> 形如：xxxxx.yyyyy.zzzzz\n\n1. header：标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。**然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第一部分。**\n\n```javascript\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n2. payload：包含一些声明， 声明是关于实体（通常是用户）和附加数据的声明。共有三种类型的 claims：注册负载、公共负载和私人负载。\n\n- Registered claims（注册）: 通常有四个部分，iss(issuer)，exp (expiration time), sub (subject), aud (audience)。还有一些其他的，比如：nbf (Not Before)、iat (Issued At)、jti (JWT ID)。\n  **iss（issuer）**：声明标识发行该证书的委托人。\n  **exp (expiration time)**：声明标识了过期时间或之后不得接受 JWT 进行处理\n  **sub (subject)**：JWT 的主题。 JWT 中的声明通常是声明，关于主题。主题值必须要么被限定为在发行人的上下文中是本地唯一的，或者是全球唯一的。\n  **aud (audience)**：声明标识了 JWT 的接收者。\n- Public claims（公共）：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在 [IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) 中定义，或者定义为包含抗冲突命名空间的 URI。\n- Private claims（私有）：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明，这些声明既不是注册声明也不是公开声明。此声明的处理通常是**特定于应用程序**的。\n\n**然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第二部分。**\n**这里，header 与 payload 都是可以直接通过 base64url 解码获得其 json 数据的。** 3. signature：签名，这是 jwt 最核心的部分，就是包含 base64 编码的 header,payload,以及 secret，最后再将整个使用加密算法进行加密。其中的 secret 就是服务端发放的私钥。\n\n> 形如：\n> HMACSHA256(\n> base64UrlEncode(header) + \".\" +\n> base64UrlEncode(payload),\n> secret\n> )\n\n#### 使用\n\n每当用户想要访问受保护的路由或资源时，用户代理应发送 JWT，通常在使用 Bearer 模式的 Authorization 标头中。标题的内容应如下所示：\n\n```javascript\nAuthorization: Bearer <token>\n```\n\n如果令牌在 Authorization 标头中发送，则跨源资源共享 (CORS) 不会成为问题，因为它不使用 cookie（cookie 是不能跨域的）。这一点就非常适合单点登录。\n\n#### 安全性\n\n因为在 jwt 签发的时候，密钥是服务端生成的，所以来说是比较安全的，当 payload 的数据修改后，发送给服务端，服务端会采用相同的加密算法生成一个 token 副本与之前签发的进行对比，显然，修改后的数据再次加密后与之前的 token 对比肯定不同。\n在 payload 中，因为是 base64url 编码的，所以很容易解码获取信息，因此不宜在里面放一些比较重要的信息。\n","slug":"谈谈cookie、session与token-jwt","published":1,"updated":"2022-12-31T10:26:33.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf2kmzyz0011g8v76ceech4h","content":"<p><strong>首先呢，网上关于它们的文章已经很多了，在这里我就只是来记录以下我的理解，其实也是看其他网上内容的一个总结吧。</strong></p>\n<blockquote>\n<p><strong>前言：由于 HTTP 协议无状态的缺陷。WEB 的设计者们提出了 Cookie 和 Session 两种解决机制。而 token,通常是 jwt(json web token)作为一种用户身份令牌，也常常用于记录 http 的状态存储，通常是在用户登录后，伴随每一次请求发送给给后端。下面就来聊聊它们。</strong></p>\n</blockquote>\n <span id=\"more\"></span>\n\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Cookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。<br>包括：</p>\n<ol>\n<li>Name/Value：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌。</li>\n<li>Expires 属性：设置 Cookie 的生存期。有两种存储类型的 Cookie：会话性与持久性。Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</li>\n<li>Domain 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域（域名前缀不同）可以设置或获取其父域的 Cookie。</li>\n<li>Secure 属性：指定是否使用 HTTPS 安全协议发送 Cookie。</li>\n<li>Path 属性：定义了 Web 站点上可以访问该 Cookie 的目录。</li>\n<li>HTTPOnly 属性 ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头。<br><strong>好了，以上内容是来自百度百科。简单地做个总结：cookie 是一种存储在客户端的小型文本数据，里面的类容有键值对、生存周期、访问域、是否使用 http,web 站点可访问 cookie 的目录以及是否允许客户端读取 cookie。</strong></li>\n</ol>\n<h4 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p><strong>XSRF/CSRF（跨站请求伪造）</strong>：利用的是 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器,却不能保证请求本身是用户自愿发出的。这里有一些如 Firefox、Opera 等浏览器使用单进程机制，<strong>多个窗口或标签使用同一个进程，共享 Cookie 等会话数据</strong>。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用“CTRL+N” 或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行 IE 可执行程序打开窗口时，才会创建新的进程。<strong>Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。</strong>因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 CSRF 攻击篡夺用户的会话 Cookie 创造了条件。却不能保证请求本身是用户自愿发出的。其最典型的例子<strong>就是当 cookie 还没过期时，用户浏览的网站有与其没过期的网站的一些 api 请求，那么当用户浏览这个恶意网站时就可能会受到危害</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202112161949.png\"><br><strong>会话定置(Session Fixation)攻击</strong>是指，攻击者向受害者主机注入自己控制的认证 Cookie 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。注入 Cookie 的方法包括：使用跨站脚本或木马等恶意程序；或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过 HTTP 响应中的 Set-Cookie 头将攻击者拥有的该域 Cookie 发送给用户等。因为 sessionID 一般都会放在 cookie 中存储，所以会容易受到会话定制攻击。</p>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>与 cookie 相比，session 就是存放在服务端了，它表示在客户端登录时，服务端会发放一个 sessionid 到客户端，它一般存在 cookie 中，所以客户端以后的请求就会在请求头的 cookies 字段中携带这个信息。这样服务端就可以通过这个数据判断客户端的登录状态。这就好比我们去点菜，点好了后商家给我们一个号码牌，等菜好了，就送往相应号码牌的位置。</p>\n<h4 id=\"安全性-1\"><a href=\"#安全性-1\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p>因为 session 是放在服务器上的，所以一般的安全性就考虑 sessionid 的伪造与截获。如果 sessionid 是放在 cookie 中的，那么 cookie 的时效就决定了 sessionid 即登录状态的时效。<br>需要注意的就是会话固定（session fixation)：意思是攻击者先自己获取一个 sessionid,然后假冒一个网站并将连接发给被攻击的人，当受害者登录后，攻击者就可以劫持受害人的会话。因为在攻击者登录获取 sessionid 后，网络服务器看到会话已经建立，无需创建新的会话。所以攻击者就成功地冒充了受害者，从而获取了受害者的信息。</p>\n<h3 id=\"Token（JWT）\"><a href=\"#Token（JWT）\" class=\"headerlink\" title=\"Token（JWT）\"></a>Token（JWT）</h3><h4 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h4><p>JSON Web Token (JWT) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。由于此信息经过数字签名，因此可以验证和信任。 JWT 可以使用秘密（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。尽管 JWTs 可以被加密，以便在各方之间提供保密性，但我们将专注于签名的令牌。签名的令牌可以验证其中包含的索赔的完整性，而加密的令牌则对其他各方隐藏这些索赔。当令牌使用公钥/私钥对签名时，签名也证明了只有持有私钥的一方才是签名者。 - - - - <a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a></p>\n<h4 id=\"组成：\"><a href=\"#组成：\" class=\"headerlink\" title=\"组成：\"></a>组成：</h4><blockquote>\n<p>形如：xxxxx.yyyyy.zzzzz</p>\n</blockquote>\n<ol>\n<li>header：标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。<strong>然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第一部分。</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;alg&quot;</span>: <span class=\"string\">&quot;HS256&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;typ&quot;</span>: <span class=\"string\">&quot;JWT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>payload：包含一些声明， 声明是关于实体（通常是用户）和附加数据的声明。共有三种类型的 claims：注册负载、公共负载和私人负载。</li>\n</ol>\n<ul>\n<li>Registered claims（注册）: 通常有四个部分，iss(issuer)，exp (expiration time), sub (subject), aud (audience)。还有一些其他的，比如：nbf (Not Before)、iat (Issued At)、jti (JWT ID)。<br><strong>iss（issuer）</strong>：声明标识发行该证书的委托人。<br>**exp (expiration time)**：声明标识了过期时间或之后不得接受 JWT 进行处理<br>**sub (subject)**：JWT 的主题。 JWT 中的声明通常是声明，关于主题。主题值必须要么被限定为在发行人的上下文中是本地唯一的，或者是全球唯一的。<br>**aud (audience)**：声明标识了 JWT 的接收者。</li>\n<li>Public claims（公共）：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在 <a href=\"https://www.iana.org/assignments/jwt/jwt.xhtml\">IANA JSON Web Token Registry</a> 中定义，或者定义为包含抗冲突命名空间的 URI。</li>\n<li>Private claims（私有）：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明，这些声明既不是注册声明也不是公开声明。此声明的处理通常是<strong>特定于应用程序</strong>的。</li>\n</ul>\n<p><strong>然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第二部分。</strong><br><strong>这里，header 与 payload 都是可以直接通过 base64url 解码获得其 json 数据的。</strong> 3. signature：签名，这是 jwt 最核心的部分，就是包含 base64 编码的 header,payload,以及 secret，最后再将整个使用加密算法进行加密。其中的 secret 就是服务端发放的私钥。</p>\n<blockquote>\n<p>形如：<br>HMACSHA256(<br>base64UrlEncode(header) + “.” +<br>base64UrlEncode(payload),<br>secret<br>)</p>\n</blockquote>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>每当用户想要访问受保护的路由或资源时，用户代理应发送 JWT，通常在使用 Bearer 模式的 Authorization 标头中。标题的内容应如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果令牌在 Authorization 标头中发送，则跨源资源共享 (CORS) 不会成为问题，因为它不使用 cookie（cookie 是不能跨域的）。这一点就非常适合单点登录。</p>\n<h4 id=\"安全性-2\"><a href=\"#安全性-2\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p>因为在 jwt 签发的时候，密钥是服务端生成的，所以来说是比较安全的，当 payload 的数据修改后，发送给服务端，服务端会采用相同的加密算法生成一个 token 副本与之前签发的进行对比，显然，修改后的数据再次加密后与之前的 token 对比肯定不同。<br>在 payload 中，因为是 base64url 编码的，所以很容易解码获取信息，因此不宜在里面放一些比较重要的信息。</p>\n","site":{"data":{"linklist":[{"nickname":"ZCW","avatar":"http://sherry.formeky.xyz:8090/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210629151630-d1748408bc4d4d3b995abaf38440b71d.jpg","site":"http://sherry.formeky.xyz:8090/","descp":"后端工程师"},{"nickname":"LJC","site":"https://lengthmin.me/","descp":"这大概就是大佬吧","avatar":"https://lengthmin.me/images/avatar.png"}]}},"length":3732,"excerpt":"<p><strong>首先呢，网上关于它们的文章已经很多了，在这里我就只是来记录以下我的理解，其实也是看其他网上内容的一个总结吧。</strong></p>\n<blockquote>\n<p><strong>前言：由于 HTTP 协议无状态的缺陷。WEB 的设计者们提出了 Cookie 和 Session 两种解决机制。而 token,通常是 jwt(json web token)作为一种用户身份令牌，也常常用于记录 http 的状态存储，通常是在用户登录后，伴随每一次请求发送给给后端。下面就来聊聊它们。</strong></p>\n</blockquote>","more":"<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>Cookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。<br>包括：</p>\n<ol>\n<li>Name/Value：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌。</li>\n<li>Expires 属性：设置 Cookie 的生存期。有两种存储类型的 Cookie：会话性与持久性。Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</li>\n<li>Domain 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域（域名前缀不同）可以设置或获取其父域的 Cookie。</li>\n<li>Secure 属性：指定是否使用 HTTPS 安全协议发送 Cookie。</li>\n<li>Path 属性：定义了 Web 站点上可以访问该 Cookie 的目录。</li>\n<li>HTTPOnly 属性 ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头。<br><strong>好了，以上内容是来自百度百科。简单地做个总结：cookie 是一种存储在客户端的小型文本数据，里面的类容有键值对、生存周期、访问域、是否使用 http,web 站点可访问 cookie 的目录以及是否允许客户端读取 cookie。</strong></li>\n</ol>\n<h4 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p><strong>XSRF/CSRF（跨站请求伪造）</strong>：利用的是 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器,却不能保证请求本身是用户自愿发出的。这里有一些如 Firefox、Opera 等浏览器使用单进程机制，<strong>多个窗口或标签使用同一个进程，共享 Cookie 等会话数据</strong>。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用“CTRL+N” 或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行 IE 可执行程序打开窗口时，才会创建新的进程。<strong>Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。</strong>因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 CSRF 攻击篡夺用户的会话 Cookie 创造了条件。却不能保证请求本身是用户自愿发出的。其最典型的例子<strong>就是当 cookie 还没过期时，用户浏览的网站有与其没过期的网站的一些 api 请求，那么当用户浏览这个恶意网站时就可能会受到危害</strong>。<br><img src=\"https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202112161949.png\"><br><strong>会话定置(Session Fixation)攻击</strong>是指，攻击者向受害者主机注入自己控制的认证 Cookie 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。注入 Cookie 的方法包括：使用跨站脚本或木马等恶意程序；或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过 HTTP 响应中的 Set-Cookie 头将攻击者拥有的该域 Cookie 发送给用户等。因为 sessionID 一般都会放在 cookie 中存储，所以会容易受到会话定制攻击。</p>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>与 cookie 相比，session 就是存放在服务端了，它表示在客户端登录时，服务端会发放一个 sessionid 到客户端，它一般存在 cookie 中，所以客户端以后的请求就会在请求头的 cookies 字段中携带这个信息。这样服务端就可以通过这个数据判断客户端的登录状态。这就好比我们去点菜，点好了后商家给我们一个号码牌，等菜好了，就送往相应号码牌的位置。</p>\n<h4 id=\"安全性-1\"><a href=\"#安全性-1\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p>因为 session 是放在服务器上的，所以一般的安全性就考虑 sessionid 的伪造与截获。如果 sessionid 是放在 cookie 中的，那么 cookie 的时效就决定了 sessionid 即登录状态的时效。<br>需要注意的就是会话固定（session fixation)：意思是攻击者先自己获取一个 sessionid,然后假冒一个网站并将连接发给被攻击的人，当受害者登录后，攻击者就可以劫持受害人的会话。因为在攻击者登录获取 sessionid 后，网络服务器看到会话已经建立，无需创建新的会话。所以攻击者就成功地冒充了受害者，从而获取了受害者的信息。</p>\n<h3 id=\"Token（JWT）\"><a href=\"#Token（JWT）\" class=\"headerlink\" title=\"Token（JWT）\"></a>Token（JWT）</h3><h4 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h4><p>JSON Web Token (JWT) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。由于此信息经过数字签名，因此可以验证和信任。 JWT 可以使用秘密（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。尽管 JWTs 可以被加密，以便在各方之间提供保密性，但我们将专注于签名的令牌。签名的令牌可以验证其中包含的索赔的完整性，而加密的令牌则对其他各方隐藏这些索赔。当令牌使用公钥/私钥对签名时，签名也证明了只有持有私钥的一方才是签名者。 - - - - <a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a></p>\n<h4 id=\"组成：\"><a href=\"#组成：\" class=\"headerlink\" title=\"组成：\"></a>组成：</h4><blockquote>\n<p>形如：xxxxx.yyyyy.zzzzz</p>\n</blockquote>\n<ol>\n<li>header：标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。<strong>然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第一部分。</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;alg&quot;</span>: <span class=\"string\">&quot;HS256&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;typ&quot;</span>: <span class=\"string\">&quot;JWT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>payload：包含一些声明， 声明是关于实体（通常是用户）和附加数据的声明。共有三种类型的 claims：注册负载、公共负载和私人负载。</li>\n</ol>\n<ul>\n<li>Registered claims（注册）: 通常有四个部分，iss(issuer)，exp (expiration time), sub (subject), aud (audience)。还有一些其他的，比如：nbf (Not Before)、iat (Issued At)、jti (JWT ID)。<br><strong>iss（issuer）</strong>：声明标识发行该证书的委托人。<br>**exp (expiration time)**：声明标识了过期时间或之后不得接受 JWT 进行处理<br>**sub (subject)**：JWT 的主题。 JWT 中的声明通常是声明，关于主题。主题值必须要么被限定为在发行人的上下文中是本地唯一的，或者是全球唯一的。<br>**aud (audience)**：声明标识了 JWT 的接收者。</li>\n<li>Public claims（公共）：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在 <a href=\"https://www.iana.org/assignments/jwt/jwt.xhtml\">IANA JSON Web Token Registry</a> 中定义，或者定义为包含抗冲突命名空间的 URI。</li>\n<li>Private claims（私有）：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明，这些声明既不是注册声明也不是公开声明。此声明的处理通常是<strong>特定于应用程序</strong>的。</li>\n</ul>\n<p><strong>然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第二部分。</strong><br><strong>这里，header 与 payload 都是可以直接通过 base64url 解码获得其 json 数据的。</strong> 3. signature：签名，这是 jwt 最核心的部分，就是包含 base64 编码的 header,payload,以及 secret，最后再将整个使用加密算法进行加密。其中的 secret 就是服务端发放的私钥。</p>\n<blockquote>\n<p>形如：<br>HMACSHA256(<br>base64UrlEncode(header) + “.” +<br>base64UrlEncode(payload),<br>secret<br>)</p>\n</blockquote>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>每当用户想要访问受保护的路由或资源时，用户代理应发送 JWT，通常在使用 Bearer 模式的 Authorization 标头中。标题的内容应如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果令牌在 Authorization 标头中发送，则跨源资源共享 (CORS) 不会成为问题，因为它不使用 cookie（cookie 是不能跨域的）。这一点就非常适合单点登录。</p>\n<h4 id=\"安全性-2\"><a href=\"#安全性-2\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p>因为在 jwt 签发的时候，密钥是服务端生成的，所以来说是比较安全的，当 payload 的数据修改后，发送给服务端，服务端会采用相同的加密算法生成一个 token 副本与之前签发的进行对比，显然，修改后的数据再次加密后与之前的 token 对比肯定不同。<br>在 payload 中，因为是 base64url 编码的，所以很容易解码获取信息，因此不宜在里面放一些比较重要的信息。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clf2kmzx20001g8v7h7e1bwxs","category_id":"clf2kmzxc0004g8v75jq64qpg","_id":"clf2kmzxs000eg8v7heyz5hmp"},{"post_id":"clf2kmzx90003g8v7hr73fg2c","category_id":"clf2kmzxc0004g8v75jq64qpg","_id":"clf2kmzxu000gg8v7erss3efk"},{"post_id":"clf2kmzxf0006g8v78v8m9irn","category_id":"clf2kmzxr000dg8v7cequ3534","_id":"clf2kmzxu000ig8v766yta85b"},{"post_id":"clf2kmzyh000kg8v736633x2q","category_id":"clf2kmzyk000mg8v73crn4wdg","_id":"clf2kmzyv000vg8v78yiocuxz"},{"post_id":"clf2kmzyj000lg8v7d2bz2f2w","category_id":"clf2kmzyr000rg8v76l6751ge","_id":"clf2kmzyy000zg8v77vuchcaf"},{"post_id":"clf2kmzyw000xg8v7hatbgac0","category_id":"clf2kmzxr000dg8v7cequ3534","_id":"clf2kmzz10013g8v7fitpb160"},{"post_id":"clf2kmzyq000qg8v7hr310alk","category_id":"clf2kmzyv000wg8v74xis7exv","_id":"clf2kmzz20015g8v75mfm8qxa"},{"post_id":"clf2kmzyx000yg8v7heylfa28","category_id":"clf2kmzxr000dg8v7cequ3534","_id":"clf2kmzz30016g8v74fh991yi"},{"post_id":"clf2kmzyu000ug8v76knk4i2p","category_id":"clf2kmzyv000wg8v74xis7exv","_id":"clf2kmzz30018g8v7gbmh9e5o"},{"post_id":"clf2kmzyz0011g8v76ceech4h","category_id":"clf2kmzz20014g8v75nwja8mk","_id":"clf2kmzz30019g8v7c9ke9nbx"}],"PostTag":[{"post_id":"clf2kmzxf0006g8v78v8m9irn","tag_id":"clf2kmzxk0009g8v72rbc18sj","_id":"clf2kmzxt000fg8v7a0vq3w2v"},{"post_id":"clf2kmzxl000ag8v78ltt6vb2","tag_id":"clf2kmzxr000cg8v7d5zdaxu0","_id":"clf2kmzxu000hg8v7dq89cmoo"},{"post_id":"clf2kmzyh000kg8v736633x2q","tag_id":"clf2kmzyk000ng8v73utx1ji6","_id":"clf2kmzys000sg8v7cel39t1n"},{"post_id":"clf2kmzyx000yg8v7heylfa28","tag_id":"clf2kmzz10012g8v7ffl4fbzs","_id":"clf2kmzz30017g8v7eyj30uv8"}],"Tag":[{"name":"隐式转换","_id":"clf2kmzxk0009g8v72rbc18sj"},{"name":"deploy qingfuwu","_id":"clf2kmzxr000cg8v7d5zdaxu0"},{"name":"numpy","_id":"clf2kmzyk000ng8v73utx1ji6"},{"name":"Event","_id":"clf2kmzz10012g8v7ffl4fbzs"}]}}