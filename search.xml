<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年终总结</title>
    <url>/2021/12/31/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>感想： 时间过得真的很快，而需要学习的东西一直在变多，从大二到大三的，慢慢地就觉得自己接触的领域所渺小。而这一年里感受最深的总还是时间不够的样子。</p>
</blockquote>
<hr>
<span id="more"></span>

<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>在学习上，尽管不是所有课程安排得很妥当，但也有一些课程让我受益良多。记忆比较深刻得还是暑假前的 flutter 课程吧。那一次面临得挑战是未知、课程时间短。而最终的任务是使用 flutter 完成一个 APP。而我做的就是一个记笔记的 APP 了<a href="https://github.com/Jealh-h/lightNote">(https://github.com/Jealh-h/lightNote)</a>，尽管功能不是那么完善，但这次让我体验到了全栈开发的一些困难吧，得益于 eggjs 框架能让我一个不太懂后端的轻松一点…….。数据分析这门课也挺好的，至少让我在机器学习方面能够调库了，能训练模型了。特别是在最后的房价预测的项目上，从数据获取到数据分析再到模型预测，这一套下来让我觉得 python 更加强大了。其次就是数据可视化了，虽然说理论课着实有一点无聊，好在实验课还比较有趣，这次让我体验了一把 d3js,给我的感觉就是 jquery 的一个兄弟一样，只不过更加适合于绘制图形。最后说说编译原理吧，这门课就感觉比较神奇吧？！从词法分析到语法分析，再到语义分析等等。都感觉有很强的理论支撑。单就对于给定的 test 来说，做一个词法分析、语法分析的工作量就挺大的（求 NFA、DFA,改写 LL(1)文法等等），可见哪些语言之父是有多 🐂 了。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>在这一年里依然那么喜欢逛 bi 站,喜欢听音乐。印象最深的还是《双城之战》了,一方面是我喜欢的画风，但是呢这剧情确实有点虐了,这大概就是角色设定吧。<br><strong>qq 音乐年度报告</strong><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/qqmusic_2021.PNG" alt="qq音乐"></p>
<p><strong>bilibili 年度报告</strong><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bilibili_2021.PNG" alt="bilibili"></p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>在技术栈上，对于 react 的使用更加熟悉了，尽管自己想用 vue 写一个个人博客，但写到一半还是放弃了（可能那时候还不知道一些强大的 nodejs 框架吧）。所以还是 hexo 香啊，就这样发现了写博客是一件强化记忆的事情。在这一年里，虽然在知识广度上有了提升，但在深度上感觉还学提升。比较纠结的还是对于一些工具不知到是要会到什么层度吧，比如 webpack,vite 是会按照官方文档配置，还是能熟练地写出来。暑期在实验室期间，把原有的 oj3 由 webpack 构建改成了 vite,只能说 vite 真快。使用 react 重写了一个会议室管理系统端。而对于微信小程序那边，虽然没有获得奖，但也收获了一些开发经验吧。而对于一些其他知识，比如 rust、electron、wasm、以及游戏开发都是很想学的，但都会感觉自由的时间太少，而学习又需要耗费大量时间。所以还需要控制自己、让自己珍惜时间啊。</p>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>希望自己记忆力好一点。<br>每一天都要崭新的一点。<br>对渴望的事情执着一点。<br>让自己的想法丰富一点。</p>
<p><strong>就上面那么亿点就够了</strong></p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
  </entry>
  <entry>
    <title>2022 年终总结</title>
    <url>/2022/12/31/2022-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2022 年就要结束了，回想这一年可谓是五味杂陈啊。也是经历许多第一次的一年吧。</p>
<span id="more"></span>

<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在这学期开始，也就是大三下，然后开始找实习了。在找实习的过程中还算坎坷吧，经历了人生的第一次面试。其实投的公司一个手能数过来。然后就分别面了字节、网易、蚂蚁。其中字节面了两次，一次是国际化电商，另一次就是我下半年所实习的部门懂车帝了。</p>
<p>曲曲折折，这一年最美好的也就是下半年实习北漂的这一段时间了，跟我的实验室同学、室友、一开始不认识的同校同学（哈哈哈，这称呼感觉有点怪怪的）。</p>
<h3 id="租房篇"><a href="#租房篇" class="headerlink" title="租房篇"></a>租房篇</h3><p>去北京总得租房吧。是的，然后我们就被中介…(懂的都懂)。第一次租房是三个合租的，房租 8000 一月，首付一共 4 万多吧，三个月。当时还是挺震惊的，第一次拿出去这么多钱 😂。</p>
<p>总的来说，北京租房想事少的话还是走一些平台，比如自如什么的，虽然说有那么亿丢丢贵。但是会有一些服务之类的，比如打扫房间。好像就打扫房间有用 🤔。</p>
<h3 id="上班篇"><a href="#上班篇" class="headerlink" title="上班篇"></a>上班篇</h3><p><strong>团队聚餐</strong><br>手动补上 俊哥跟东阳哥 👍</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311521.JPG" alt="team"></p>
<ul>
<li><p>地点：北京市海淀区中城/中兴大厦</p>
</li>
<li><p>交通工具：开水团的自行车啊哈哈哈哈哈</p>
</li>
</ul>
<p>一个职场小白，初入职场，有很多东西需要学习，不论是专业的还是非专业的。从一个月开始的陌生到后来的轻车熟路。收获颇为丰厚，在这里必须要感谢下我的 mentor，真是非常的 nice。</p>
<p>收获满满的 gitlab</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311520.JPG" alt="gitlab commit"></p>
<p>很高兴能在这里实习，总的来说累并快乐着，遗憾就是未能留下继续前行 😅。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311502.png" alt="waka time"></p>
<h3 id="娱乐篇"><a href="#娱乐篇" class="headerlink" title="娱乐篇"></a>娱乐篇</h3><p>这波啊，虽然北京跟我想象的有点不一样，但还是可以的</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311522.PNG" alt="跟朋友们吃的美食"></p>
<p>第一次看见了“大裤衩”<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311739.JPG" alt="大裤衩"></p>
<p>和朋友们逛了一小会鸟巢<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202212311740.png" alt="鸟巢"></p>
<p><strong>回想起来真是回忆满满</strong></p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>这方面还是得多思考吧，也要学会 say no，同时要有自己得见解。</p>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul>
<li>坚持写作，输出质量文章</li>
<li>学习图形学，发展多领域</li>
<li>有机会发几个 b 站视频 🤔</li>
<li>positive</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2022 充满回忆的一年，感谢我身边的每一个人，他们教会了我许多，让我明白了许多。 Respect。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 的隐式转换</title>
    <url>/2023/03/09/JavaScript-%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>对于 JavaScript 中的一些运算符（如：==）来说是比较迷惑的。它们产生的结果有时会让我们变得混淆，那这一切的背后就是“隐式转换”在作祟了。</p>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="Number-强制转换"><a href="#Number-强制转换" class="headerlink" title="Number 强制转换"></a>Number 强制转换</h3><table>
<thead>
<tr>
<th align="center">target</th>
<th align="center">number</th>
</tr>
</thead>
<tbody><tr>
<td align="center">undefined</td>
<td align="center">NaN</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">true/false</td>
<td align="center">1/0</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">解析失败返回 NaN</td>
</tr>
<tr>
<td align="center">BigInt</td>
<td align="center">TypeError</td>
</tr>
<tr>
<td align="center">Symbol</td>
<td align="center">TypeError</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center"><a href="%22number%22">@@toPrimitive</a> → valueOf() → toString()</td>
</tr>
</tbody></table>
<p><strong>string 解析失败：</strong></p>
<ul>
<li>忽略前导与尾随的空格/行终止符</li>
<li>前导 0 不会识别为八进制文本</li>
<li>+和-允许在字符串开头，且只能出现一次，后面不能跟空格</li>
<li>Infinity 和 -Infinity 当作字面量</li>
<li>空串或全为空格解析成 0</li>
<li>不能含数字分割符</li>
</ul>
<span id="more"></span>

<h3 id="强制-boolean-转换"><a href="#强制-boolean-转换" class="headerlink" title="强制 boolean 转换"></a>强制 boolean 转换</h3><table>
<thead>
<tr>
<th align="center">target</th>
<th align="center">Boolean</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0 / -0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">undefined</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">Object / “anything but not empty”</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h3 id="复杂类型转换成原始类型"><a href="#复杂类型转换成原始类型" class="headerlink" title="复杂类型转换成原始类型"></a>复杂类型转换成原始类型</h3><p>复杂数据类型转换为原始类型有以下规则：</p>
<ul>
<li>强制原始值转换：<a href="%22default%22">@@toPrimitive</a> → valueOf() → toString()</li>
<li>强制数字类型转换、强制 number 类型转换、强制 BigInt 类型转换：<a href="%22number%22">@@toPrimitive</a> → valueOf() → toString()</li>
<li>强制字符串类型转换：<a href="%22string%22">@@toPrimitive</a> → toString() → valueOf()</li>
<li>Date 和 Symbol 对象是唯一重写 [@@toPrimitive] 方法的对象。Date.prototype[@@toPrimitive] 将 “default” hint 视为 “string”，而 Symbol.prototype[@@toPrimitive] 忽略 hint 并始终返回一个 symbol。</li>
</ul>
<p>其中 [@@toPrimitive] 为一个内置的 Symbol 属性，其部署方式为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#x27;default&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么当遇到原始类型转换时就相当于自定义转化了</span></span><br><span class="line"><span class="keyword">const</span> num = +obj;</span><br><span class="line"><span class="comment">// hint为 number, 结果： 10</span></span><br></pre></td></tr></table></figure>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>首当其冲的肯定是 ”==“， 想必其已经臭名昭著了。那么我们先来看看它的一些坑坑吧 😀。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == []</span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;str&quot;</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>首先，我们明确一下 == 的规则，那么就非常容易去判断结果了，其规则为：</p>
<ol>
<li><span id="same primitve">相同类型</span>：</li>
</ol>
<ul>
<li>Object 类型：比较引用地址</li>
<li>Number: 有 NaN 则返回 false, +0 与 -0 相等，操作数相等则返回 true。</li>
<li>String：只有当两个操作数具有相同的字符且顺序相同时才返回 true。</li>
<li>Boolean：仅当操作数都为 true 或都为 false 时返回 true。</li>
<li>BigInt：仅当两个操作数值相同时返回 true。</li>
<li>Symbol：仅当两个操作数引用相同的符号时返回 true。</li>
<li>null: 另一个数为 undefined 或 null 才返回 true。否则返回 false。</li>
<li>undefined: 另一个数为 undefined 或 null 才返回 true。否则返回 false。</li>
</ul>
<ol start="2">
<li><p>其中一个是对象，另一个是基本类型。会按照**<a href="#前置">前置</a>**的规则进行转换成基本类型。</p>
</li>
<li><p>这时都是<strong>基本类型</strong>了，那么有如下规则。</p>
</li>
</ol>
<ul>
<li>都是基本类型，按照<a href="#same primitve">规则 1</a>进行对比。</li>
<li>其中一个是 Symbol, 另一个不是，返回 false。</li>
<li>其中一个是 boolean, 另一个不是，则将 boolean 转换成数字。</li>
<li>Number 与 String 对比：使用与 <a href="#Number 强制转换">Number() 构造函数相同的算法</a>将字符串转换为数字。转换失败将导致 NaN，这将保证相等是 false。</li>
<li>Number 与 BigInt 对比：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。</li>
<li>String 与 BigInt 对比：使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 false。</li>
</ul>
<h4 id="回到上题"><a href="#回到上题" class="headerlink" title="回到上题"></a>回到上题</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == []</span><br><span class="line"><span class="comment">// 相同类型都是 Object, 比较引用地址，因此返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// null 与 undefined 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;str&quot;</span>) == <span class="literal">true</span></span><br><span class="line"><span class="comment">// 不同类型</span></span><br><span class="line"><span class="comment">// 先将 new String(&quot;str&quot;) 转换成基本类型（强制字符串类型转换）得到：</span></span><br><span class="line"><span class="comment">// &quot;str&quot; == true</span></span><br><span class="line"><span class="comment">//其中一个是 boolean 类型，转成 number</span></span><br><span class="line"><span class="comment">// &quot;str&quot; == 1</span></span><br><span class="line"><span class="comment">// 将 string 装换成 number</span></span><br><span class="line"><span class="comment">// NaN == 1</span></span><br><span class="line"><span class="comment">// 最后：false</span></span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="+"></a>+</h3><p><strong>在求值时，它首先将两个操作数强制转换为基本类型。然后，检查两个操作数的类型</strong>:</p>
<ul>
<li>多个值运算，进行相加操作，如果其中有一个是字符串，那么会将另一个数转换成字符串，进行字符串连接。</li>
<li>多个值运算，都是 BigInt, 执行 BigInt 加法，一方是 BigInt,另一个不是，抛出 TypeError。</li>
<li>多个值运算，没有 String、BigInt, 都转为数字。</li>
<li>单值运算，转换成数字</li>
</ul>
<h4 id="下面来看一下常见的运算-😏"><a href="#下面来看一下常见的运算-😏" class="headerlink" title="下面来看一下常见的运算 😏"></a>下面来看一下常见的运算 😏</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + [] + &#123;&#125; + []</span><br><span class="line"><span class="comment">// 这里有一个坑就是 &#123;&#125; 会识别为一个 block, 然后就成了下面这种情况</span></span><br><span class="line"><span class="comment">// + [] + &#123;&#125; + []</span></span><br><span class="line"><span class="comment">// 前部分就相当于单目运算，转换成数字类型 []--valueOf--&gt;[]--toString--&gt;&#x27;&#x27;--toNumber--&gt;0</span></span><br><span class="line"><span class="comment">// 0 + &#123;&#125; + []</span></span><br><span class="line"><span class="comment">// 先转换成基本类型</span></span><br><span class="line"><span class="comment">// 0 + &#x27;[object Object]&#x27; + []</span></span><br><span class="line"><span class="comment">// &#x27;0[object Object]&#x27; + []</span></span><br><span class="line"><span class="comment">// 转换成基本类型</span></span><br><span class="line"><span class="comment">// &#x27;0[object Object]&#x27; + &#x27;&#x27;</span></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line"><span class="comment">//&#x27;0[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> + <span class="number">1</span></span><br><span class="line"><span class="comment">// 已经都是基本类型了</span></span><br><span class="line"><span class="comment">// 没有 String、BigInt，都转换成数字</span></span><br><span class="line"><span class="comment">// 1 + 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> + <span class="number">1</span></span><br><span class="line"><span class="comment">// 已经都是基本类型了</span></span><br><span class="line"><span class="comment">// 没有 String、BigInt，都转换成数字</span></span><br><span class="line"><span class="comment">// NaN + 1</span></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line">[] + &#123;&#125;</span><br><span class="line"><span class="comment">// 装换成基本类型</span></span><br><span class="line"><span class="comment">// &#x27;&#x27; + &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; + []</span><br><span class="line"><span class="comment">// 同样的坑就是 &#123;&#125; 会识别为一个 block, 然后就成了下面这种情况</span></span><br><span class="line"><span class="comment">// + []</span></span><br><span class="line"><span class="comment">// 这里成了单目运算，将后面的转换为数值</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">（&#123;&#125;） + []</span><br><span class="line"><span class="comment">// 这种情况就与 [] + &#123;&#125; 类似了</span></span><br><span class="line"><span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125; + &#123;&#125;</span></span><br><span class="line"><span class="comment">// 前面识别为 block</span></span><br><span class="line"><span class="comment">// + &#123;&#125;</span></span><br><span class="line"><span class="comment">// 单目运算。转换成数字</span></span><br><span class="line"><span class="comment">// &#123;&#125; --valueOf--&gt;&#123;&#125;--toString--&gt;&#x27;[object Object]&#x27;--toNumber--&gt;NaN</span></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [] + []</span></span><br><span class="line"><span class="comment">// 转换成基本类型</span></span><br><span class="line"><span class="comment">// &#x27;&#x27; + &#x27;&#x27;</span></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line"><span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h3><ul>
<li>两个操作数：将两个操作数转换为数值，并根据两个操作数的类型执行数字减法或 BigInt 减法。如果类型不匹配，则抛出 TypeError。</li>
<li>一个操作数：数字则取反，否则转换成数字类型。</li>
</ul>
<h4 id="看看例题"><a href="#看看例题" class="headerlink" title="看看例题"></a>看看例题</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">[] - &#123;&#125;;</span><br><span class="line"><span class="comment">// 转成数字</span></span><br><span class="line"><span class="comment">// [] --valueOf--》 [] --toString--》 &quot;&quot; --toNumber--》 0</span></span><br><span class="line"><span class="comment">// &#123;&#125;--valueOf--》 &#123;&#125;--toString--》 &#x27;[object Object]&#x27;--toNumber--》 NaN</span></span><br><span class="line"><span class="comment">// 0 - NaN</span></span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title="!"></a>!</h3><ul>
<li>运算符将真值或假值转换为对应的相反值</li>
<li>当与非布尔值使用时，如果其操作数可以转化为 true，则返回 false，否则返回 true。</li>
</ul>
<h4 id="-4"><a href="#-4" class="headerlink" title="!!"></a>!!</h4><p>双非运算符，将运算值转换成相应的 boolean 类型。</p>
<h4 id="看看例题-1"><a href="#看看例题-1" class="headerlink" title="看看例题"></a>看看例题</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">![];</span><br><span class="line"><span class="comment">// 将 [] 转成 boolean, 根据强制Boolean转换(Object类型）：[] --&gt; true</span></span><br><span class="line"><span class="comment">// !true</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="gt-lt"><a href="#gt-lt" class="headerlink" title="&gt; / &lt;"></a>&gt; / &lt;</h3><p><strong>所有的比较操作符都是先强制转化左操作数再强制转化右操作数。</strong><br>首先，通过依次调用其 [@@toPrimitive]（以 “number” 作为提示）、valueOf() 和 toString() 方法，将对象转换为原始类型。左边的操作数总是在右边的操作数之前被强制转换。</p>
<ul>
<li>如果两个值都是字符串，则根据它们所包含的 Unicode 码位的值，将它们作为字符串进行比较。</li>
<li>否则，尝试将非数值类型转化为数值类型。</li>
<li>如果一个为 NaN, 返回 false。</li>
</ul>
<h4 id="看看例题-2"><a href="#看看例题-2" class="headerlink" title="看看例题"></a>看看例题</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 先将左边转化为数值类型</span></span><br><span class="line"><span class="comment">// NaN &lt; 3</span></span><br><span class="line"><span class="comment">// 有一个为NaN, 返回 false</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt; [];</span><br><span class="line"><span class="comment">// 左边为数字类型，将右边转换为数字类型</span></span><br><span class="line"><span class="comment">// [] --toString--&gt; &#x27;&#x27; --toNumber--&gt; 0</span></span><br><span class="line"><span class="comment">// 0 &lt; 0</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>隐式转换的规则非常多，但都是向基本类型转换，所以理解<a href="#复杂类型转换成原始类型">复杂类型转换成原始类型</a>比较重要，特别的还需要注意 {} 识别为一个 block 的情况。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2</a></li>
<li><a href="https://www.zhihu.com/question/45478070">https://www.zhihu.com/question/45478070</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github actions进行轻服务的页面部署</title>
    <url>/2021/10/22/actions%E8%BF%9B%E8%A1%8C%E8%BD%BB%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="使用-github-actions-进行轻服务的页面托管"><a href="#使用-github-actions-进行轻服务的页面托管" class="headerlink" title="使用 github actions 进行轻服务的页面托管"></a>使用 github actions 进行<a href="https://qingfuwu.cn/">轻服务</a>的页面托管</h1><h3 id="首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用-github-actions-的自动部署。只要会一点-github-actions-实现起来也比较简单。"><a href="#首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用-github-actions-的自动部署。只要会一点-github-actions-实现起来也比较简单。" class="headerlink" title="首先，轻服务官方文档给出了手动部署页面的教程页面托管。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。"></a>首先，轻服务官方文档给出了手动部署页面的教程<a href="https://qingfuwu.cn/docs/openapi/sdk/hosting.html#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1%E4%BF%A1%E6%81%AF">页面托管</a>。而我这里就简单地介绍一下使用 github actions 的自动部署。只要会一点 github actions,实现起来也比较简单。</h3><p><a href="https://qcjtoy.web.cloudendpoint.cn/">看看效果</a></p>
<h3 id="1-github-创建仓库，配置-github-workflow-yml-同时设置-secrets-变量-ACCESS-TOKEN-与-SERVICE-ID"><a href="#1-github-创建仓库，配置-github-workflow-yml-同时设置-secrets-变量-ACCESS-TOKEN-与-SERVICE-ID" class="headerlink" title="1.github 创建仓库，配置.github/workflow/*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID."></a>1.github 创建仓库，配置.github/workflow/*.yml,同时设置 secrets 变量 ACCESS_TOKEN 与 SERVICE_ID.</h3><ul>
<li><h4 id="配置-workflow-的-yml-文件。"><a href="#配置-workflow-的-yml-文件。" class="headerlink" title="配置 workflow 的 yml 文件。"></a>配置 workflow 的 yml 文件。</h4>直接复制里面的 Usage,<a href="https://github.com/marketplace/actions/deploy-to-byteinspire-hosting">Deploy to ByteInspire Hosting</a></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hosting</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build_and_deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="comment"># Add any build steps here. For example:</span></span><br><span class="line">      <span class="comment"># - run: npm ci &amp;&amp; npm run build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">byteinspire/hosting-deployer-action@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">service-id:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; secrets.SERVICE_ID &#125;&#125;</span>&quot;</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span>&quot;</span></span><br><span class="line">          <span class="comment"># Or you can use file param to directly specify the ziped file path</span></span><br><span class="line">          <span class="attr">directory:</span> <span class="string">./</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li><h4 id="配置-secrets-的变量-ACCESS-TOKEN-与-SERVICE-ID"><a href="#配置-secrets-的变量-ACCESS-TOKEN-与-SERVICE-ID" class="headerlink" title="配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID"></a>配置 secrets 的变量 ACCESS_TOKEN 与 SERVICE_ID</h4></li>
</ul>
<ol>
<li>ACCESS_TOKEN<br>官方已经写得很详细了<a href="https://qingfuwu.cn/docs/openapi/personaltoken.html#%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E8%AE%BF%E9%97%AE%E5%87%AD%E8%AF%81">创建和管理访问凭证</a><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221004.png"><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221006.png"></li>
<li>SERVICE_ID<br>登录轻服务后<a href="https://qingfuwu.cn/dashboard">https://qingfuwu.cn/dashboard</a>，在首页就能看见你创建的所有服务。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220950.png"><br>这里就选择 hello world 这个服务，点击进去，再进入到设置里面就可以看见 SERVICE_ID.当然这里你也可以直接点击页面托管，上传压缩文件手动部署。<img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220952.png"></li>
<li>添加变量到 secrets 里面，这里我已经添加上了。这里要注意的是设置 respository secret，因为最开始设置成 environment secret 而失败几次 😭<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110220955.png"></li>
</ol>
<h3 id="2-经过上面的步骤，大致就可以完成了。"><a href="#2-经过上面的步骤，大致就可以完成了。" class="headerlink" title="2. 经过上面的步骤，大致就可以完成了。"></a>2. 经过上面的步骤，大致就可以完成了。</h3><p>#####看看 actions 吧，忽略前几次 environment secret 的锅 😂<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221013.png"><br>进入页面托管，点击网站域名，就可以看见部署后的页面了。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221016.png"><br>最终效果：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110221025.png"></p>
]]></content>
      <tags>
        <tag>deploy qingfuwu</tag>
      </tags>
  </entry>
  <entry>
    <title>Scroll 开发小记</title>
    <url>/2022/09/11/Scroll-%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>背景：一次左滑加载更多的的交互开发</p>
</blockquote>
<h2 id="填坑开始"><a href="#填坑开始" class="headerlink" title="填坑开始"></a>填坑开始</h2><p>在最开始时，我得到了一个提示，左滑加载更多类似下拉刷新。想了想，好家伙，不就是把下拉刷新横过来嘛，碰巧下拉刷新还是前几天新增的一个组件，这回可以借鉴借鉴了 😍。OK 开干！</p>
<span id="more"></span>

<h2 id="下拉刷新组件的设计"><a href="#下拉刷新组件的设计" class="headerlink" title="下拉刷新组件的设计"></a>下拉刷新组件的设计</h2><p>在查看组件的源码后，发现下拉刷新组件的设计其实比较简单。这里使用了 @use-gesture/react 用在手势上的绑定，react-spring 用作动画的实现。下面就简单介绍下其设计思路。</p>
<p>首先抛出几个问题</p>
<ul>
<li>什么时候触发刷新 或者什么时候调用手势？</li>
<li>scroll 容器滚动时与手势冲突。</li>
<li>下拉的阈值、回弹动画</li>
</ul>
<ol>
<li><p>下拉刷新组件在设计时，采用的是浏览器原生滚动加上自定义用户手势事件。这样我们很容易判断什么时候触发手势事件了。其答案是：判断 dom 节点的 scrollTop，当 scrollTop 为 0 时，说明已经到顶了，然后在往下拉时，就开始触发手势，当手势下拉的距离超过某个阈值时，即变为了可刷新的状态，松手后，直接触发下拉回调。</p>
</li>
<li><p>从问题 1 的答案我们就可以很合理地规避原生滚动与手势下拉的冲突，及 scrollTop 不为 0 时，不会触发手势事件。</p>
</li>
<li><p>通过 use-gesture/react 中的 rubberbandIfOutOfBounds 函数创建一个弹簧效果，回弹动画呢，这个组件采用的是设置 loading 的 height 来实现，虽然可以，但我理解这种动态高度不是太适合这种滚动场景。因此后面经过各种实验（踩坑）后，丢弃了这种改变高度（宽度）的方式展示 loading。</p>
</li>
</ol>
<blockquote>
<p>大概的一个框架图</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-01%2018.42.03.png" alt="img_1"></p>
<h2 id="横滑实践"><a href="#横滑实践" class="headerlink" title="横滑实践"></a>横滑实践</h2><p>横滑多简单呢，把竖着的横过来就是了 😊。哈哈，确实是这样的。</p>
<h3 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h3><p>基本套路：</p>
<ul>
<li>overflow：hidden</li>
<li>transform：translate3d<br>基于以上套路，第一版没有采用浏览器的原生滚动，然后全程触发手势事件，通过手势事件控制 react-spring 的动画参数，实现模拟滚动。显然，模拟滚动的效果不是太好，其原因在于滚动速率变化、滚动惯性等比较难控制（实际原因：🥬 🐶）。<br>下面来看一下初版效果:</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-01-2022%2019-11-16.gif" alt="img_2"></p>
<p>目测效果还行，但是在真机调试上就比较拉胯了，在真机上，实际移动的距离是手指一动的距离，所以是非常的慢并且每一次滚动的距离、速度这些比较受限。</p>
<h3 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h3><p>参考 picker 组件，做一个滚动惯性。这种滚动对应的是每一次移动，终点位置都是一个整数位置（最终移动坐标是： index * itemWidth 或者 itemHeight）。</p>
<h3 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h3><p>思路：原生滚动结合手势，这款设计比较合理，原生滚动改善了速度问题，横向长列表在滚动时，只有到滚动到最右边时才触发整体容器的移动，然后露出 load。<br>注意：原生滚动采用 overflow：auto。在滚动到最右边时，触发手势，需要设置 overflow：hidden，不然就会发生滚动重叠（原生的在滚动、手势也在移动）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-09-02%2020.17.02.png" alt="img_3"></p>
<p>看似可用了，然而 ios 有个坑点，原生滚动具有惯性回弹，所以，当你拇指快速左滑时，会出现一个滚动回弹。这个回弹不会将 load 露出来，反而露出的是一个白底。</p>
<h2 id="能用待改善"><a href="#能用待改善" class="headerlink" title="能用待改善"></a>能用待改善</h2><p>如标题所说，最终版只是一个能用的版本。各种原因，选择将 load 放在了原生 scroll 里面了（里外差别不大 😅）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/Sep-02-2022%2021-05-15.gif" alt="img_3"></p>
<p>待优化的点</p>
<ul>
<li>原生滚动不能有回弹效果，如果需要增加回弹效果，需要手动模拟滚动，然后再添加回弹。(ios特定的边界弹簧效果不能禁止)</li>
<li>边界 drag 不流畅，有待改进。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>numpy条件选择</title>
    <url>/2021/10/13/numpy%E6%9D%A1%E4%BB%B6%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="numpy-的条件筛选"><a href="#numpy-的条件筛选" class="headerlink" title="numpy 的条件筛选"></a>numpy 的条件筛选</h2><h3 id="筛选基础"><a href="#筛选基础" class="headerlink" title="筛选基础"></a>筛选基础</h3><h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><p>我们一般都知道 python 的 [ ] 操作符可以进行切片操作,举例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">#切片操作参数介绍：[起始位置下标（默认最开始）:结束位置下标(默认最后):步长(默认为一)]</span></span><br><span class="line">arr[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># [1,2]</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># [1,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当步长为-1时，能够逆置数组</span></span><br><span class="line">arr[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># [3,2,1]</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="下面是-ndarray-二维数组的例子"><a href="#下面是-ndarray-二维数组的例子" class="headerlink" title="下面是 ndarray 二维数组的例子"></a>下面是 ndarray 二维数组的例子</h4><h5 id="单列-行筛选"><a href="#单列-行筛选" class="headerlink" title="单列/行筛选"></a>单列/行筛选</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line">arr = np.array(arr)</span><br><span class="line"><span class="comment"># 单列筛选</span></span><br><span class="line"><span class="comment"># 列筛选，第一个冒号不能省略</span></span><br><span class="line">arr[:,<span class="number">0</span>] <span class="comment"># 选择下标为0的列</span></span><br><span class="line"><span class="comment"># [1,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行筛选</span></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment"># 选择下标为0的行，就像普通的二维数组访问第一个一维数组一样</span></span><br><span class="line"><span class="comment"># [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<h5 id="多行-列筛选"><a href="#多行-列筛选" class="headerlink" title="多行/列筛选"></a>多行/列筛选</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line">arr = np.array(arr)</span><br><span class="line"><span class="comment"># 多列筛选</span></span><br><span class="line">	<span class="comment"># 选择某个下标区间的列</span></span><br><span class="line">arr[:,<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment"># [1,2],</span></span><br><span class="line"><span class="comment"># [4,5]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line">	<span class="comment"># 选择某些列</span></span><br><span class="line">arr[:,[<span class="number">0</span>,<span class="number">3</span>]] <span class="comment"># 选择下标为 0，3的列</span></span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment"># [1,4],</span></span><br><span class="line"><span class="comment"># [4,7]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line">	<span class="comment"># bool选择</span></span><br><span class="line">	<span class="comment"># bool数组的  长度  必须要与列的  维数相同</span></span><br><span class="line">arr[:,[<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>,<span class="literal">False</span>]]</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment"># [1],</span></span><br><span class="line"><span class="comment"># [4]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行筛选</span></span><br><span class="line"><span class="comment"># 与多列筛选类似</span></span><br><span class="line">arr = np.array([</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],</span><br><span class="line">[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">])</span><br><span class="line">	<span class="comment"># 选择某些行</span></span><br><span class="line">arr[[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># [[</span></span><br><span class="line"><span class="comment"># [1,2,3,4],</span></span><br><span class="line"><span class="comment"># [4,5,6,7]</span></span><br><span class="line"><span class="comment"># ]]</span></span><br><span class="line">	<span class="comment"># 其余就不在赘述，可以字行测试</span></span><br></pre></td></tr></table></figure>

<h3 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h3><p>通过上面的一些基本的筛选规则，可以大致了解了 numpy 的筛选原则了，那么下面就看一 numpy 比较强大的条件筛选吧。而条件筛选就是依赖 bool 筛选实现的。</p>
<h4 id="条件筛选行"><a href="#条件筛选行" class="headerlink" title="条件筛选行"></a>条件筛选行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],</span><br><span class="line">[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：选择第一个元素为偶数的行</span></span><br><span class="line">arr[arr[:,<span class="number">0</span>]%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment"># [[ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#  [ 8,  9, 10, 11]]</span></span><br></pre></td></tr></table></figure>

<p>我们可以看一下上面发生了什么。<br>首先: arr[:,0]x 选择除了二维数组的第一列—–[1,4,8]<br>然后: arr[:,0]%2==0 得到了一个 bool 数组—–[False,True,True]<br>最后 arr[[False,True,True]],这个样子是不是有点熟悉了，也就是上面的 bool 筛选。</p>
<h4 id="条件筛选列"><a href="#条件筛选列" class="headerlink" title="条件筛选列"></a>条件筛选列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与行筛选类似</span></span><br><span class="line">arr[:,arr[<span class="number">1</span>]&gt;<span class="number">5</span>] <span class="comment"># 选择第二行中大于5的列</span></span><br><span class="line"><span class="comment"># [[ 3,  4],</span></span><br><span class="line"><span class="comment">#  [ 6,  7],</span></span><br><span class="line"><span class="comment">#  [10, 11]]</span></span><br></pre></td></tr></table></figure>

<h4 id="行列一起选择"><a href="#行列一起选择" class="headerlink" title="行列一起选择"></a>行列一起选择</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[arr&gt;<span class="number">5</span>] <span class="comment"># 选择arr中，大于5的元素</span></span><br><span class="line"><span class="comment"># 其中arr&gt;5得到一个二维的bool数组</span></span><br><span class="line"><span class="comment"># [[False, False, False, False],</span></span><br><span class="line"><span class="comment">#  [False, False,  True,  True],</span></span><br><span class="line"><span class="comment">#  [ True,  True,  True,  True]]</span></span><br><span class="line"><span class="comment"># 最终结果是一个一维数组</span></span><br><span class="line"><span class="comment"># [ 6,  7,  8,  9, 10, 11]</span></span><br></pre></td></tr></table></figure>

<h5 id="注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列-int，第二列是-str，这样再用-arr-gt-5-就会出现错误。"><a href="#注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列-int，第二列是-str，这样再用-arr-gt-5-就会出现错误。" class="headerlink" title="注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr&gt;5 就会出现错误。"></a>注意：在进行行列一起选择时，可能会有元素类型不一致的情况，如第一列 int，第二列是 str，这样再用 arr&gt;5 就会出现错误。</h5><h4 id="多条件选择"><a href="#多条件选择" class="headerlink" title="多条件选择"></a>多条件选择</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[(arr&gt;<span class="number">5</span>) &amp; (arr%<span class="number">2</span>==<span class="number">0</span>)] <span class="comment"># 选择大于5且为偶数的元素</span></span><br><span class="line"><span class="comment"># [ 6,  8, 10]</span></span><br></pre></td></tr></table></figure>

<h5 id="注意：多条件要用（）括起每一个条件，逻辑关系用-或者-amp-，不能用-and-or-这样。"><a href="#注意：多条件要用（）括起每一个条件，逻辑关系用-或者-amp-，不能用-and-or-这样。" class="headerlink" title="注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &amp;，不能用 and,or 这样。"></a>注意：多条件要用（）括起每一个条件，逻辑关系用 | 或者 &amp;，不能用 and,or 这样。</h5>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>koa源码阅读</title>
    <url>/2023/04/10/koa%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>前言：koa 作为一个轻量版的 node 服务端框架，其独特的洋葱圈模型是值得一探究竟的。这篇 blog 就来学习一下其中的奥妙吧。</p>
</blockquote>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先，我们可以从其使用方式开始。通过引入 koa, 创建一个 app 实例，通过 use 方法，拦截请求。然后 listen 端口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>打开源码可以发现，默认导出的是一个 Application 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Application-对象"><a href="#Application-对象" class="headerlink" title="Application 对象"></a>Application 对象</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>在构造函数中，主要做的就是创建 middleware 数组，内置 context、request、response 对象。同时可以传入如下 option</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title">constructor</span> <span class="title">options</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: string, <span class="comment">// Environment</span></span><br><span class="line">  <span class="attr">keys</span>: string[], <span class="comment">// Signed cookie keys</span></span><br><span class="line">  <span class="attr">proxy</span>: boolean, <span class="comment">// Trust proxy headers</span></span><br><span class="line">  <span class="attr">subdomainOffset</span>: number, <span class="comment">// Subdomain offset</span></span><br><span class="line">  <span class="attr">proxyIpHeader</span>: string, <span class="comment">// Proxy IP header,defaults to X-Forwarded-For</span></span><br><span class="line">  <span class="attr">maxIpsCount</span>: number, <span class="comment">// Max IPs read from proxy IPheader, default to 0 (means infinity)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持动态设定参数。因为在构造函数中会把 option 的属性赋值到属性上 <code>this.proxy = options.proxy || false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa(&#123; <span class="attr">proxy</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">app.proxy = <span class="literal">false</span>; <span class="comment">// 动态设置参数</span></span><br></pre></td></tr></table></figure>

<p>设置完一些配置后，会设置内置的 middleware、context、response、request 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.middleware = [];</span><br><span class="line"><span class="comment">// context request response 为 koa的内置对象，分别在context.js request.js response.js 文件中</span></span><br><span class="line"><span class="built_in">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line"><span class="built_in">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line"><span class="built_in">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br></pre></td></tr></table></figure>

<h4 id="use"><a href="#use" class="headerlink" title="use"></a>use</h4><p>use 方法是将提供的 middleware 添加到 <code>this.middleware</code> 里面，需要注意的是，use 接受的参数必须是函数。</p>
<p>在最上边，我们添加了一个 middleware。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>listen 是 <code>http.createServer(app.callback()).listen(3000)</code> 的语法糖。所以，其内部就是创建一个 http.Server, 然后调用调用 listen 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">listen (...args) &#123;</span><br><span class="line">  debug(<span class="string">&#x27;listen&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> server = http.createServer(<span class="built_in">this</span>.callback())</span><br><span class="line">  <span class="keyword">return</span> server.listen(...args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>这个方法在 listen 方法中调用。返回一个 handleRequest 函数，这个函数的参数就是 createServer 里的 <code>http.IncomingMessage</code>, <code>http.ServerResponse</code>对象。通过这两个对象， koa 会创建自己的 context 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">callback () &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="built_in">this</span>.middleware)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.handleRequest(ctx, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compose 这个方法使用的是 koa-compose 包，其内部有一丢丢复杂。我们可以先看 handleRequest</p>
<h4 id="handleRequest"><a href="#handleRequest" class="headerlink" title="handleRequest"></a>handleRequest</h4><p>这是实际处理请求的函数。传入的是 context, 以及 compose 函数返回的一个 fnMiddleware。<br>函数里面就通过 context 获取原始的 <code>http.IncomingMessage</code> 对象，然后先设置<br>statusCode = 404,(这里显式地设置 404，想想后面在哪设置 200 呢？提示：getter/setter) 最后通过 respond 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleRequest (ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.res</span><br><span class="line">  res.statusCode = <span class="number">404</span></span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err)</span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function">() =&gt;</span> respond(ctx)</span><br><span class="line">  onFinished(res, onerror)</span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到 compose 函数返回的是一个函数，并且会接受 context 参数。</p>
<h5 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h5><p>从上面，我们知道了 compose 返回的是一个函数，并且会接受 context 参数，那下面就来一睹全貌吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Middleware stack must be an array!&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Middleware must be composed of functions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   * 这里会接受 context,而且还可以接受一个 next</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;next() called multiple times&quot;</span>));</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>光看代码是有点抽象的，最好的方法就是模拟一遍，我们就以最开始的代码为例。</p>
<ol>
<li>首先 middleware 数组是这样的,只有一个元素，那我们开始执行 compose。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>compose 单单只是返回一个函数 <code>function (context, next) &#123;...&#125;</code>，只有在 handleRequest 中才会执行。并且这里只传入了 context, next = undefined。<br>即是：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 fnMiddleware 函数里，会执行 <code>dispatch(0)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">    <span class="comment">// i = 0, index = -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;next() called multiple times&quot;</span>));</span><br><span class="line">  index = i;</span><br><span class="line">  <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">  <span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line">  <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会执行, 也就是我们自己的中间件，从上面可以看到，我们自己写的中间件函数会默认传入两个参数 <code>fn(context, dispatch.bind(null, i + 1))</code>, context 与 dispatch.bind(null, i+1)。这里的 dispatch 就是我们中间件里面的 next。</p>
<p>从这里我们可以看到，如果在我们写的中间件里面不执行 next 的话，那就只会执行第一次 use 添加的函数了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>再来看看多个 middleware 的情况。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    ctx.body = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>还是执行到 <code>fn(context, dispatch.bind(null, i + 1))</code>，这里 fn 就是第一个中间件，在第一个中间件里，我们执行了 next, 也就是 <code>dispatch(1)</code>。在 <code>dispatch(1)</code> 里，我们又会执行到 <code>fn(context, dispatch.bind(null, i + 1))</code> 这里，只不过，这里的 fn 是 middleware[1], 也就是 console.log(“2”)这个中间件。</p>
<p>在第二个中间件里我们没有执行 next 函数了，这样就回溯到了第一个中间件 <code>ctx.body = &quot;hello world&quot;</code> 这里了, 这里执行完后，就会来到 <a href="#handlerequest">handleRequest</a> 函数 <code>fnMiddleware(ctx).then(handleResponse)</code> 然后执行 handleResponse -&gt; respond。</p>
<p>如果我们在第二个中间件中继续执行 next 呢。这里也就是 dispatch(2), 会进入 <code>if (i === middleware.length) fn = next;</code> 这里，这里的 next 是最开始 <code>fnMiddleware(ctx)</code> 传入的，显然是 undefined, 然后走 <code>if (!fn) return Promise.resolve();</code> 这个逻辑，结束递归。</p>
<h5 id="compose-的限制"><a href="#compose-的限制" class="headerlink" title="compose 的限制"></a>compose 的限制</h5><p>从上面的例子在扩展下，如果我们执行到 dispatch(2) 再去执行一下 next, 会怎样呢？</p>
<p>别忘了，我们还有一个分支没有走到呢！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;next() called multiple times&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在 dispatch(2) 后，再去执行一次 next, 相当于再执行一次 dispatch(2)。为什么这么说呢，因为在最后一个中间件里面，我们的 next 函数就是 fnMiddleware 里的第二个参数，即 undefined 了，这里走的逻辑是 <code>if (!fn) return Promise.resolve();</code>, 直接 resolve 掉了。并没有执行 <code>dispatch.bind(null, i + 1)</code> 这里。然而不同的是 compose 函数里面的闭包 index。index 的含义其实是上一次的 i。</p>
<p>当我们在最后一个中间件中执行两次 next 时，第二次 next 就满足了 <code>i &lt;= index</code> 这个条件,抛出 <code>&quot;next() called multiple times&quot;</code> 错误。</p>
<p>因此，这也就限制了 next 的执行次数，其实可想而知，肯定不会让你执行超过 middleware 长度的 next 了啊</p>
<h4 id="respond"><a href="#respond" class="headerlink" title="respond"></a>respond</h4><p>回到 handleRequest 里面，执行完所有的 middleware 后，就会开始执行 handleResponse 了，也就是 <code>respond(ctx)</code> 了。</p>
<p>在这个函数里面，如果设置 <code>ctx.respond = false</code>, 就代表要我们自己处理响应数据。一般来说都是 koa 来处理，官方也不建议自己去处理<a href="https://koajs.com/#ctx-respond">https://koajs.com/#ctx-respond</a>。</p>
<p>然后就是处理一些比如：</p>
<ul>
<li>响应 body 需要为空的状态码（304 缓存、204 无内容）就清空 body</li>
<li>HEAD 请求响应标头未发送时并且 response 拥有 Content-Length 时设置 ctx 的 length 属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// allow bypassing koa</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.respond === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.writable) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">  <span class="keyword">const</span> code = ctx.status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore body</span></span><br><span class="line">  <span class="keyword">if</span> (statuses.empty[code]) &#123;</span><br><span class="line">    <span class="comment">// strip headers</span></span><br><span class="line">    ctx.body = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.method === <span class="string">&quot;HEAD&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent &amp;&amp; !ctx.response.has(<span class="string">&quot;Content-Length&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; length &#125; = ctx.response;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(length)) ctx.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status body</span></span><br><span class="line">  <span class="keyword">if</span> (body == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.response._explicitNullBody) &#123;</span><br><span class="line">      ctx.response.remove(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">      ctx.response.remove(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">      ctx.length = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> res.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ctx.req.httpVersionMajor &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      body = <span class="built_in">String</span>(code);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      body = ctx.message || <span class="built_in">String</span>(code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = <span class="string">&quot;text&quot;</span>;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// responses</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">&quot;string&quot;</span>) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// body: json</span></span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到此，一条经过中间件的请求响应过程就结束了，依赖中间件，可以实现其他强大的功能，如：路由。下面就介绍下 koa 中的内置对象吧。</p>
</blockquote>
<h3 id="Context-对象"><a href="#Context-对象" class="headerlink" title="Context 对象"></a>Context 对象</h3><p>context 是一个比较重要的对象，可以说是贯穿全文的，其创建实例位于 <a href="#handlerequest">handleRequest</a> 中调用 <code>createContext(req,res)</code>。其实就是存储一些上下文信息，比如 node 原始的 <code>http.IncomingMessage</code>, <code>http.ServerResponse</code> 对象，koa 内置的 <code>Application.BaseRequest</code>, <code>Application.BaseResponse</code> 对象等等。</p>
<p>先看一下大体结构</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">app</span>: Application,</span><br><span class="line">  <span class="attr">req</span>: IncomingMessage,</span><br><span class="line">  <span class="attr">res</span>: ServerResponse,</span><br><span class="line">  <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">originalUrl</span>:IncomingMessage.url,</span><br><span class="line">  <span class="attr">request</span>: &#123;</span><br><span class="line">    <span class="attr">prototype</span>: Application.BaseRequest</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">response</span>: &#123;</span><br><span class="line">    <span class="attr">prototype</span>: Application.BaseResponse</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">prototype</span>: &#123;</span><br><span class="line">    <span class="attr">prototype</span>: &#123;</span><br><span class="line">      <span class="attr">inspect</span>: <span class="built_in">Function</span>,</span><br><span class="line">      <span class="attr">toJSON</span>: <span class="built_in">Function</span>,</span><br><span class="line">      <span class="attr">assert</span>: httpAssert,</span><br><span class="line">      <span class="attr">throw</span>: <span class="built_in">Function</span>,</span><br><span class="line">      <span class="attr">onerror</span>: <span class="built_in">Function</span>,</span><br><span class="line">      get cookie: <span class="built_in">Function</span>,</span><br><span class="line">      set cookie: <span class="built_in">Function</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及通过 <a href="https://www.npmjs.com/package/delegates">delegates</a>, 一个代理属性的库 代理的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Response delegation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">delegate(proto, <span class="string">&quot;response&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;attachment&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;redirect&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;remove&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;vary&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;has&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;append&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;flushHeaders&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;status&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;body&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;length&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;type&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;lastModified&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;etag&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;headerSent&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;writable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request delegation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">delegate(proto, <span class="string">&quot;request&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;acceptsLanguages&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;acceptsEncodings&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;acceptsCharsets&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;accepts&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">  .method(<span class="string">&quot;is&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;querystring&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;idempotent&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;socket&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;search&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;method&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;query&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">  .access(<span class="string">&quot;accept&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;origin&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;href&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;subdomains&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;protocol&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;hostname&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;URL&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;header&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;headers&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;secure&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;stale&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;fresh&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;ips&quot;</span>)</span><br><span class="line">  .getter(<span class="string">&quot;ip&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>之前 statusCode = 404， 而后面返回的确实 200，这其实是在 ctx.body = xxx, 时设置了状态码，而 ctx.body 是在 Application.BaseResponse 对象中设置的 getter, setter 属性。</p>
<h3 id="Application-BaseResponse-对象"><a href="#Application-BaseResponse-对象" class="headerlink" title="Application.BaseResponse 对象"></a>Application.BaseResponse 对象</h3><p>通过对原生 http.ServerResponse 进行代理，设置响应相关的配置。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">prototype</span>: &#123;</span><br><span class="line">    get socket: http.ServerResponse.socket,</span><br><span class="line">    get header: http.ServerResponse.getHeaders | http.IncomingMessage._headers,</span><br><span class="line">    get headers: <span class="built_in">this</span>.header,</span><br><span class="line">    get status: http.IncomingMessage.statusCode,</span><br><span class="line">    set status: <span class="built_in">Function</span>, <span class="comment">// 1. 根据状态码设置 body 2. 设置http.IncomingMessage.statusCode</span></span><br><span class="line">    get message: http.IncomingMessage.statusMessage | statuses[<span class="built_in">this</span>.status],</span><br><span class="line">    set message: <span class="built_in">Function</span>, <span class="comment">// 设置 http.IncomingMessage.statusMessage</span></span><br><span class="line">    get body: <span class="built_in">this</span>._body,</span><br><span class="line">    set body: <span class="built_in">Function</span>,<span class="comment">// 设置 _body 有 stream、string、json等,以及一些响应头</span></span><br><span class="line">    get length: http.ServerResponse.getHeader(<span class="string">&#x27;Content-Length&#x27;</span>) | Buffer.byteLength(<span class="built_in">JSON</span>.stringify(body)),</span><br><span class="line">    set length: http.ServerResponse.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>),</span><br><span class="line">    get headerSent: http.ServerResponse.headersSent, <span class="comment">// 标记响应头是否已发送</span></span><br><span class="line">    <span class="attr">vary</span>: <span class="built_in">Function</span>, <span class="comment">// 设置 vary header</span></span><br><span class="line">    <span class="attr">redirect</span>: <span class="built_in">Function</span>, <span class="comment">// 设置重定向相关的如302， Location 头</span></span><br><span class="line">    <span class="attr">attachment</span>: <span class="built_in">Function</span>, <span class="comment">// Content-Disposition 文件下载相关</span></span><br><span class="line">    set <span class="keyword">type</span>: <span class="built_in">Function</span>, <span class="comment">// Content-type</span></span><br><span class="line">    get <span class="keyword">type</span>: <span class="built_in">Function</span>,</span><br><span class="line">    set lastModified: <span class="built_in">Function</span>, <span class="comment">// Last-Modified</span></span><br><span class="line">    get etag: <span class="built_in">Function</span>,</span><br><span class="line">    set etag: <span class="built_in">Function</span>,</span><br><span class="line">    <span class="attr">has</span>: <span class="built_in">Function</span>, <span class="comment">// 判断响应头是否有指定字段</span></span><br><span class="line">    <span class="attr">set</span>: <span class="built_in">Function</span>, <span class="comment">// 设置响应头是指定字段</span></span><br><span class="line">    <span class="attr">append</span>: <span class="built_in">Function</span>, <span class="comment">// 追加响应头某个字段</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="built_in">Function</span>, <span class="comment">// 一处某个响应头字段</span></span><br><span class="line">    <span class="attr">writable</span>: http.ServerResponse.socket.writable | http.ServerResponse.writableEnded/finished,</span><br><span class="line">    <span class="attr">toJSON</span>: <span class="built_in">Function</span>,</span><br><span class="line">    <span class="attr">flushHeaders</span>: http.ServerResponse.flushHeaders,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Application-BaseRequest-对象"><a href="#Application-BaseRequest-对象" class="headerlink" title="Application.BaseRequest 对象"></a>Application.BaseRequest 对象</h3><p>与 BaseResponse 对象类似，这里是对 http.IncomingMessage 进行的一个中间代理。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">prototype</span>: &#123;</span><br><span class="line">    get header: http.IncomingMessage.headers,</span><br><span class="line">    set header: http.IncomingMessage.headers,</span><br><span class="line">    get headers: http.IncomingMessage.headers,</span><br><span class="line">    set headers: http.IncomingMessage.headers,</span><br><span class="line">    get url: http.IncomingMessage.url,</span><br><span class="line">    set url: http.IncomingMessage.url,</span><br><span class="line">    get origin: <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.protocol&#125;</span>://<span class="subst">$&#123;<span class="built_in">this</span>.host&#125;</span>`</span>,</span><br><span class="line">    get href: <span class="built_in">this</span>.originalUrl | <span class="built_in">this</span>.origin + <span class="built_in">this</span>.originalUrl,</span><br><span class="line">    get method: http.IncomingMessage.method,</span><br><span class="line">    set method: http.IncomingMessage.method,</span><br><span class="line">    get path: http.IncomingMessage.pathname,</span><br><span class="line">    set path: http.IncomingMessage.url,</span><br><span class="line">    get query: <span class="built_in">String</span>, <span class="comment">// 返回 queryString</span></span><br><span class="line">    set query: <span class="built_in">String</span>, <span class="comment">// 设置 this.querystring</span></span><br><span class="line">    get querystring: <span class="built_in">Function</span>, <span class="comment">// 返回 http.IncomingMessage.query || &#x27;&#x27;</span></span><br><span class="line">    set querystring: <span class="built_in">Function</span>, <span class="comment">// 设置 this.url</span></span><br><span class="line">    get search: <span class="string">`?<span class="subst">$&#123;<span class="built_in">this</span>.querystring&#125;</span>`</span>,</span><br><span class="line">    set search: <span class="built_in">this</span>.querystring = str,</span><br><span class="line">    get host: <span class="built_in">String</span>, <span class="comment">// 请求头的 host， 支持 x-Forwarded-Host</span></span><br><span class="line">    get hostname:  <span class="built_in">String</span>, <span class="comment">// host 不带端口</span></span><br><span class="line">    get URL: URL,</span><br><span class="line">    get fresh: <span class="built_in">Function</span>, <span class="comment">// 判断客户端是否过期</span></span><br><span class="line">    get stale: !<span class="built_in">this</span>.fresh,</span><br><span class="line">    get idempotent: <span class="comment">// 检查请求是否是幂等的</span></span><br><span class="line">    get socket: http.IncomingMessage.socket,</span><br><span class="line">    get charset: <span class="built_in">String</span>, <span class="comment">// 获取 content-type 中的 charset</span></span><br><span class="line">    get length: Content-Length,</span><br><span class="line">    get protocol: <span class="built_in">String</span>, <span class="comment">// 返回协议字符串“http”或“https”</span></span><br><span class="line">    get secure: <span class="built_in">Boolean</span>, <span class="comment">// this.protocol === &quot;https&quot;</span></span><br><span class="line">    get ips: <span class="built_in">Array</span>, <span class="comment">// 含有 app.proxy = true 时</span></span><br><span class="line">    get ip: <span class="built_in">String</span>, <span class="comment">// this.socket.remoteAddress || this.ips[0]</span></span><br><span class="line">    get subdomains: <span class="built_in">String</span>[], <span class="comment">// 返回子域[]</span></span><br><span class="line">    get accept: <span class="built_in">Object</span>, <span class="comment">// Get accept object.</span></span><br><span class="line">    set accept: <span class="built_in">Function</span>, <span class="comment">// Set this._accept</span></span><br><span class="line">    <span class="attr">accepts</span>: <span class="built_in">Function</span>,</span><br><span class="line">    <span class="attr">acceptsEncodings</span>: <span class="built_in">Function</span>, <span class="comment">// Return accepted encodings or best fit based on `encodings`</span></span><br><span class="line">    <span class="attr">acceptsCharsets</span>: <span class="built_in">Function</span>, <span class="comment">// Return accepted charsets or best fit based on `charsets`</span></span><br><span class="line">    <span class="attr">acceptsLanguages</span>: <span class="built_in">Function</span>, <span class="comment">// Return accepted languages or best fit based on `langs`</span></span><br><span class="line">    <span class="attr">is</span>: <span class="built_in">Function</span>, <span class="comment">// 检查传入请求是否包含“Content Type”标头字段，以及是否包含任何给定的mime“Type”。如果没有请求正文，则返回“null”。如果没有内容类型，则返回“false”。否则，它将返回第一个匹配的“类型”。</span></span><br><span class="line">    get <span class="keyword">type</span>: <span class="built_in">String</span>, <span class="comment">// Content-type</span></span><br><span class="line">    <span class="attr">get</span>: <span class="built_in">Function</span>, <span class="comment">// 获取请求头的某个字段</span></span><br><span class="line">    <span class="attr">toJSON</span>: <span class="built_in">Function</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.npmjs.com/package/statuses">https://www.npmjs.com/package/statuses</a><br><a href="https://www.npmjs.com/package/vary">https://www.npmjs.com/package/vary</a><br><a href="https://www.npmjs.com/package/delegates">https://www.npmjs.com/package/delegates</a><br><a href="https://www.npmjs.com/package/content-type">https://www.npmjs.com/package/content-type</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
  </entry>
  <entry>
    <title>react事件系统</title>
    <url>/2022/05/01/react%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="开始注册事件"><a href="#开始注册事件" class="headerlink" title="开始注册事件"></a>开始注册事件</h2><ul>
<li>这里只是简单的设置一些变量值，见下面代码</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="comment">// DOMPluginEventSystem.ts</span></span><br><span class="line">SimpleEventPlugin.registerEvents();</span><br><span class="line">EnterLeaveEventPlugin.registerEvents();</span><br><span class="line">ChangeEventPlugin.registerEvents();</span><br><span class="line">SelectEventPlugin.registerEvents();</span><br><span class="line">BeforeInputEventPlugin.registerEvents();</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">allNativeEvent</span>:<span class="built_in">Set</span>&lt;DOMEventName&gt; = &#123;<span class="string">&#x27;click&#x27;</span>,<span class="string">&#x27;keyup&#x27;</span>,<span class="string">&#x27;keydown&#x27;</span>,...&#125;;</span><br><span class="line"></span><br><span class="line">registrationNameDependencies[<span class="string">&quot;onClick&quot;</span>] = [<span class="string">&quot;click&quot;</span>];</span><br><span class="line">registrationNameDependencies[<span class="string">&#x27;onMouseEnter&#x27;</span>] = [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>]; <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">topLevelEventsToReactNames:<span class="built_in">Map</span>&lt;DOMEventName,<span class="built_in">string</span>|<span class="literal">null</span>&gt; = &#123;<span class="string">&quot;click&quot;</span>:<span class="string">&quot;onClick&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202205062357.png" alt="flowchart"></p>
<h2 id="listenToAllSupportedEvent"><a href="#listenToAllSupportedEvent" class="headerlink" title="listenToAllSupportedEvent"></a>listenToAllSupportedEvent</h2><ul>
<li>接下来是让root容器监听所有支持的事件</li>
</ul>
<p>非委托事件只有捕获阶段。<br>而委托事件捕获冒泡都会绑定。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">allNativeEvents.forEach(<span class="function"><span class="params">domEventName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我们单独处理selectionchange更改，因为它不会冒泡，需要出现在document上</span></span><br><span class="line">  <span class="keyword">if</span> (domEventName !== <span class="string">&#x27;selectionchange&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nonDelegatedEvents.has(domEventName)) &#123;</span><br><span class="line">      <span class="comment">// 不捕获</span></span><br><span class="line">      listenToNativeEvent(domEventName, <span class="literal">false</span>, rootContainerElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nonDelegatedEvents事件是是捕获阶段监听器</span></span><br><span class="line">    <span class="comment">// delegatedEvents是冒泡捕获都有</span></span><br><span class="line">    listenToNativeEvent(domEventName, <span class="literal">true</span>, rootContainerElement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>**<em>注意：</em>**selectionChange事件是监听在document上的，因为它不会冒泡。</p>
<h2 id="绑定react的listener到root-document上"><a href="#绑定react的listener到root-document上" class="headerlink" title="绑定react的listener到root || document上"></a>绑定react的listener到root || document上</h2><p>listenToNativeEvent <strong>–&gt;</strong> addTrappedEventListener <strong>–&gt;</strong> listener = createEventListenerWrapperWithPriority</p>
<h2 id="createEventListenerWrapperWithPriority"><a href="#createEventListenerWrapperWithPriority" class="headerlink" title="createEventListenerWrapperWithPriority"></a>createEventListenerWrapperWithPriority</h2><p>这里进行创建listener,listener有如下几种：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEventListenerWrapperWithPriority</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="params"><span class="function">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="params"><span class="function">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> eventPriority = getEventPriority(domEventName);</span><br><span class="line">  <span class="keyword">let</span> listenerWrapper;</span><br><span class="line">  <span class="keyword">switch</span> (eventPriority) &#123;</span><br><span class="line">    <span class="comment">// 一般事件都是DiscreteEventPriority</span></span><br><span class="line">    <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">      listenerWrapper = dispatchDiscreteEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">      listenerWrapper = dispatchContinuousEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DefaultEventPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      listenerWrapper = dispatchEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> listenerWrapper.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    domEventName,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">    targetContainer,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种listener存在一个优先级的差别。<br>最终都会调用dispatchEvent.</p>
<h2 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h2><ul>
<li>这是react进行触发事件监听函数的地方，这里的listener是绑定到组件props上的事件处理函数。</li>
</ul>
<p>首先判断是否是allowReplay事件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allowReplay = (eventSystemFlags &amp; IS_CAPTURE_PHASE) === <span class="number">0</span>;</span><br><span class="line"><span class="comment">// eventSystemFlags capture时等于4,bubble时等于0</span></span><br><span class="line"><span class="comment">// capture &amp; 4 = 4; bubble &amp; 4 = 0</span></span><br><span class="line"><span class="comment">// IS_CAPTURE_PHASE = 4</span></span><br></pre></td></tr></table></figure>

<p>然后是先去尝试调度事件,判定是否会blockOn：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> blockedOn = attemptToDispatchEvent(</span><br><span class="line">  domEventName,</span><br><span class="line">  eventSystemFlags,</span><br><span class="line">  targetContainer,</span><br><span class="line">  nativeEvent,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="attemptToDispatchEvent"><a href="#attemptToDispatchEvent" class="headerlink" title="attemptToDispatchEvent"></a>attemptToDispatchEvent</h2><ol>
<li>先是获取真正的事件触发元素：e.targe，这里称为nativeEventTarget</li>
<li>获取nativeEventTarget上的Fiber,即”__reactFiber${Random…}”属性。这里是targetInst.</li>
<li>处理让targetInst为null的情况。<ol>
<li>节点被unmounted,即不能通过return属性到达根节点。</li>
<li>如果最近的mounted是SuspenseCompnent | HostRoot | 最近的mountedFiber  !== targetInst</li>
</ol>
</li>
</ol>
<p>接下来进入真正的事件调度函数。</p>
<h2 id="dispatchEventForPluginEventSystem"><a href="#dispatchEventForPluginEventSystem" class="headerlink" title="dispatchEventForPluginEventSystem"></a>dispatchEventForPluginEventSystem</h2><ul>
<li>在这里面，会有一个mainLoop,去寻找一个root节点，因为在root节点上，会绑定一些事件。</li>
<li>遍历的方式是从当前节点一直往上（return）.</li>
<li>最后batchedEventUpdates —&gt; dispatchEventsForPlugins</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOMPluginEventSystem</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="params"><span class="function">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="params"><span class="function">  targetInst: <span class="literal">null</span> | Fiber, <span class="comment">// 触发事件的Fiber</span></span></span></span><br><span class="line"><span class="params"><span class="function">  targetContainer: EventTarget, <span class="comment">// root</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ancestorInst = targetInst;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (eventSystemFlags &amp; IS_EVENT_HANDLE_NON_MANAGED_NODE) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">    (eventSystemFlags &amp; IS_NON_DELEGATED) === <span class="number">0</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> targetContainerNode = targetContainer <span class="keyword">as</span> Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetInst !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> node = targetInst;</span><br><span class="line">      mainLoop: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// ...搜索root container</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  batchedEventUpdates(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="comment">// 进入合成事件系统</span></span><br><span class="line">    dispatchEventsForPlugins(</span><br><span class="line">      domEventName,</span><br><span class="line">      eventSystemFlags,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      ancestorInst,</span><br><span class="line">      targetContainer,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatchEventsForPlugins"><a href="#dispatchEventsForPlugins" class="headerlink" title="dispatchEventsForPlugins"></a>dispatchEventsForPlugins</h2><ul>
<li>将nativeEvent转换成synthesizeEvent,并加入dispatchQueue，最终processDispatchQueue。</li>
</ul>
<p><em>extractEvents:</em></p>
<blockquote>
<p>创建DispatchEntry:{event:listeners}，并添加到dispatchQueue</p>
</blockquote>
<ol>
<li>工厂模式确定SyntheticEventCtor</li>
<li>accumulateSinglePhaseListeners从target到root遍历，获取绑定到props的事件处理函数，添加用户自己添加的事件处理函数到listeners数组里并返回。</li>
<li>dispatchQueue.push({event,listeners})<br>这里event也就是synthesizeEvent对象，即在事件绑定后的回调函数的默认参数event.</li>
</ol>
<p><em>processDispatchQueue:</em></p>
<blockquote>
<p>遍历dispatchQueue,处理每个事件的listeners数组</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用processDispatchQueueItemsInOrder，执行事件处理函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&lt;&#123;</span></span></span></span><br><span class="line"><span class="type"><span class="doctag"><span class="comment"> * event: ReactSyntheticEvent,</span></span></span></span><br><span class="line"><span class="type"><span class="doctag"><span class="comment"> * listeners: Array&lt;&#123;</span></span></span></span><br><span class="line"><span class="type"><span class="doctag"><span class="comment"> * instance: null | Fiber,</span></span></span></span><br><span class="line"><span class="type"><span class="doctag"><span class="comment"> * listener: Function,</span></span></span></span><br><span class="line"><span class="type"><span class="doctag"><span class="comment"> * currentTarget: EventTarget,</span></span></span></span><br><span class="line"><span class="type"><span class="doctag"><span class="comment"> * &#125;</span></span>&gt;&#125;&#125; dispatchQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;EventSystemFlags&#125;</span> <span class="variable">eventSystemFlags</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processDispatchQueue</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  dispatchQueue: DispatchQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchQueue.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123; event: ReactSyntheticEvent,listeners: Array &lt; DispatchListener &gt;&#125;;</span></span><br><span class="line">    <span class="keyword">const</span> &#123; event, listeners &#125; = dispatchQueue[i];</span><br><span class="line"></span><br><span class="line">    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);</span><br><span class="line">    <span class="comment">//  event system doesn&#x27;t use pooling.</span></span><br><span class="line">    <span class="comment">// 事件系统不使用池。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// This would be a good time to rethrow if any of the event handlers threw.</span></span><br><span class="line">  rethrowCaughtError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>processDispatchQueueItemsInOrder</li>
</ul>
<blockquote>
<p>根据inCapturePhase判定是capture还是bubble,</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行事件队列，根据是否捕获确定事件的执行顺序</span></span><br><span class="line"><span class="comment"> * []dispatchListeners</span></span><br><span class="line"><span class="comment"> * 捕获：重最后一个到第一个</span></span><br><span class="line"><span class="comment"> * 冒泡：重0到最后一个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ReactSyntheticEvent&#125;</span> <span class="variable">event</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&lt;DispatchListener&gt;&#125;</span> <span class="variable">dispatchListeners</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;boolean&#125;</span> <span class="variable">inCapturePhase</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processDispatchQueueItemsInOrder</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  event: ReactSyntheticEvent,</span></span></span><br><span class="line"><span class="params"><span class="function">  dispatchListeners: <span class="built_in">Array</span>&lt;DispatchListener&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  inCapturePhase: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previousInstance;</span><br><span class="line">  <span class="comment">// 捕获</span></span><br><span class="line">  <span class="comment">// 因为添加dispatcher时是从当前然后return到null,所以捕获是倒过来的运行</span></span><br><span class="line">  <span class="keyword">if</span> (inCapturePhase) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = dispatchListeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// &#123; instance: null | Fiber,listener: Function,currentTarget: EventTarget&#125;;</span></span><br><span class="line">      <span class="keyword">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 阻止冒泡stopPropagation</span></span><br><span class="line">      <span class="keyword">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      executeDispatch(event, listener, currentTarget);</span><br><span class="line">      previousInstance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];</span><br><span class="line">      <span class="keyword">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      executeDispatch(event, listener, currentTarget);</span><br><span class="line">      previousInstance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="executeDispatch"><a href="#executeDispatch" class="headerlink" title="executeDispatch"></a>executeDispatch</h2><ul>
<li>最终调用用户的处理函数,其中包含一些react的invoke函数，以及一些在开发环境下的createEvent事件。</li>
</ul>
<blockquote>
<p>本文还有许多细节没有提到，只是大致说明了事件系统的一个流程</p>
</blockquote>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>【译】Inside Fiber：深入概述 React 中的新协调算法</title>
    <url>/2023/03/26/%E3%80%90%E8%AF%91%E3%80%91Inside%20Fiber%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%A6%82%E8%BF%B0%20React%20%E4%B8%AD%E7%9A%84%E6%96%B0%E5%8D%8F%E8%B0%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>原文链接：<a href="https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react">https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react</a></p>
<blockquote>
<p>深入研究 React 的名为 Fiber 的新架构，了解新协调算法的两个主要阶段。我们将详细了解 React 如何更新 state 和 props 以及处理 children。</p>
</blockquote>
<span id="more"></span>

<p>React 是一个用于构建用户界面的 JavaScript 库。其核心是跟踪组件状态变化并将更新后的状态投射到屏幕的机制。在 React 中，我们将此过程称为协调。我们调用 setState 方法，框架检查状态或道具是否已更改并在 UI 上重新呈现组件。</p>
<p>React 的文档很好地概括了该机制：React 元素的作用、生命周期方法和渲染方法，以及应用于组件子组件的差异算法。从 render 方法返回的不可变 React 元素树通常被称为“虚拟 DOM”。该术语有助于早期向人们解释 React，但它也引起了混淆，并且不再在 React 文档中使用。在本文中，我将坚持称其为 React 元素树。</p>
<p>除了 React 元素树之外，框架始终有一个内部实例树（组件、DOM 节点等）用于保持状态。从版本 16 开始，React 推出了该内部实例树和算法的新实现管理它的代号为 Fiber。要了解 Fiber 架构带来的优势，请查看<a href="https://indepth.dev/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree">React 在 Fiber 中使用链表的方式和原因。</a></p>
<p>这是本系列的第一篇文章，旨在向您介绍 React 的内部架构。在本文中，我想深入概述与算法相关的重要概念和数据结构。一旦我们有了足够的背景知识，我们将探索用于遍历和处理 fiber 树的算法和主要函数。本系列的下一篇文章将演示 React 如何使用该算法来执行初始渲染和处理状态以及道具更新。从那里我们将继续讨论调度程序的细节、子协调过程和构建效果列表的机制。</p>
<p>我要在这里给你一些非常高级的知识？我鼓励您阅读它以了解 Concurrent React 内部工作原理背后的魔力。如果您打算开始为 React 做贡献，本系列文章也将为您提供很好的指导。我坚信逆向工程，因此会有很多链接指向最新版本 16.6.0 的源代码。</p>
<p>要吸收的东西肯定很多，所以如果您不能立即理解某些内容，请不要感到压力。一切都值得花时间。请注意，您无需了解任何内容即可使用 React。这篇文章是关于 React 内部如何工作的。</p>
<h2 id="Setting-the-background"><a href="#Setting-the-background" class="headerlink" title="Setting the background"></a>Setting the background</h2><p>这是一个简单的应用程序，我将在整个系列中使用。我们有一个按钮，可以简单地增加屏幕上呈现的数字：</p>
<p><img src="https://images.indepth.dev/images/2019/07/tmp1.gif" alt="https://images.indepth.dev/images/2019/07/tmp1.gif"></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Update counter</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>,</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在 <a href="https://stackblitz.com/edit/react-t4rdmh?file=index.js">这里</a> 玩。如您所见，它是一个简单的组件，从 render 方法返回两个子元素 button 和 span。只要单击按钮，组件的状态就会在处理程序中更新。这反过来会导致 span 元素的文本更新。</p>
<p>React 在 <strong>reconciliation</strong> 期间执行各种活动。例如，在我们的简单应用程序中，这是 React 在第一次渲染期间和状态更新之后执行的高级操作：</p>
<ul>
<li>更新 ClickCounter 状态下的计数属性</li>
<li>检索并比较 ClickCounter 的子项及其道具</li>
<li>更新 span 元素的 props</li>
</ul>
<p>在<strong>reconciliation</strong>期间执行其他活动，例如调用生命周期方法或更新引用。所有这些活动在 Fiber 架构中统称为“work”。work 类型通常取决于 React 元素的类型。例如，对于类组件，React 需要创建一个实例，而对于功能组件则不需要。如你所知，我们在 React 中有很多种元素，例如类和功能组件、宿主组件（DOM 节点）、portals 等。React 元素的类型由 createElement 函数的第一个参数定义。这个函数一般用在 render 方法中创建一个元素。</p>
<p>在我们开始探索 Activity 和主要的 Fiber 算法之前，让我们先熟悉一下 React 内部使用的数据结构。</p>
<h2 id="From-React-Elements-to-Fiber-nodes"><a href="#From-React-Elements-to-Fiber-nodes" class="headerlink" title="From React Elements to Fiber nodes"></a>From React Elements to Fiber nodes</h2><p>React 中的每个组件都有一个 UI 表示，我们可以调用视图或从 render 方法返回的模板。这是我们的 ClickCounter 组件的模板：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;button key=<span class="string">&quot;1&quot;</span> onClick=&#123;<span class="built_in">this</span>.onClick&#125;&gt;Update counter&lt;/button&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="React-Elements"><a href="#React-Elements" class="headerlink" title="React Elements"></a>React Elements</h2><p>一旦模板通过 JSX 编译器，你最终会得到一堆 React element。这是 React 组件的 render 方法真正返回的内容，而不是 HTML。因为我们不需要使用 JSX，所以我们的 ClickCounter 组件的 render 方法可以这样重写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                    <span class="attr">onClick</span>: <span class="built_in">this</span>.onClick</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;Update counter&#x27;</span></span><br><span class="line">            ),</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">key</span>: <span class="string">&#x27;2&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="built_in">this</span>.state.count</span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 render 方法中调用 React.createElement 将创建两个数据结构，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">$$typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">children</span>: <span class="string">&#x27;Update counter&#x27;</span>,</span><br><span class="line">            <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">$$typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">children</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>你可以看到 React 为这些对象添加了属性 $$typeof 以将它们唯一标识为 React 元素。然后我们有描述元素的属性 type、key 和 props。这些值取自您传递给 React.createElement 函数的内容。请注意 React 如何将文本内容表示为 span 和 button 节点的子节点。以及点击处理程序如何成为按钮元素道具的一部分。 React 元素上还有其他字段，例如 ref 字段，超出了本文的范围。</p>
<p>ClickCounter 的 React 元素没有任何属性或键：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    <span class="attr">key</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">ref</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">type</span>: ClickCounter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fiber-nodes"><a href="#Fiber-nodes" class="headerlink" title="Fiber nodes"></a>Fiber nodes</h2><p>在<strong>reconciliation</strong>期间，从 render 方法返回的每个 React 元素的数据被合并到 fiber 节点树中。每个 React 元素都有一个对应的 fiber 节点。与 React 元素不同，fiber 不会在每次渲染时重新创建。这些是可变数据结构，用于保存组件状态和 DOM。</p>
<p>我们之前讨论过，根据 React 元素的类型，框架需要执行不同的活动。在我们的示例应用程序中，对于类组件 ClickCounter，它调用生命周期方法和渲染方法，而对于 span 宿主组件（DOM 节点），它执行 DOM 变异。所以每个 React 元素都被转换成对应类型的 Fiber 节点，描述需要完成的工作。</p>
<p><strong>您可以将 fiber 视为一种数据结构，它代表一些要做的工作，或者换句话说，一个工作单元。 Fiber 的架构还提供了一种方便的方式来跟踪、安排、暂停和中止工作。</strong></p>
<p>当 React 元素第一次被转换为 fiber 节点时，React 使用元素中的数据在 createFiberFromTypeAndProps 函数中创建一个 fiber。在随后的更新中，React 重用了 fiber 节点，并仅使用来自相应 React 元素的数据更新了必要的属性。如果相应的 React 元素不再从 render 方法返回，React 可能还需要根据 key prop 移动层次结构中的节点或将其删除。</p>
<blockquote>
<p>查看 ChildReconciler 函数以查看 React 为现有 fiber 节点执行的所有活动和相应函数的列表。</p>
</blockquote>
<p>因为 React 为每个 React 元素创建了一个 fiber，并且由于我们有一棵包含这些元素的树，所以我们将有一棵 fiber 节点树。在我们的示例应用程序中，它看起来像这样：</p>
<p><img src="https://images.indepth.dev/images/2019/07/image-51.png" alt="https://images.indepth.dev/images/2019/07/image-51.png"></p>
<p>所有 fiber 节点都通过链表连接，使用 fiber 节点上的以下属性：child、sibling 和 return。有关它为何以这种方式工作的更多详细信息，请查看我的文章 The how and why on React’s usage of linked list in Fiber 如果您还没有阅读过它。</p>
<h2 id="Current-and-work-in-progress-trees"><a href="#Current-and-work-in-progress-trees" class="headerlink" title="Current and work in progress trees"></a>Current and work in progress trees</h2><p>在第一次渲染之后，React 最终得到一个 fiber 树，它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 current。当 React 开始处理更新时，它会构建一个所谓的 workInProgress 树，它反映了要刷新到屏幕的未来状态。</p>
<p>所有工作都在 workInProgress 树中的 fiber 上执行。当 React 遍历当前树时，它会为每个现有的 fiber 节点创建一个替代节点，该节点构成 workInProgress 树。该节点是使用 render 方法返回的 React 元素的数据创建的。一旦处理完更新并完成所有相关工作，React 将准备好备用树以刷新到屏幕上。一旦这个 workInProgress 树呈现在屏幕上，它就成为 current。</p>
<p>React 的核心原则之一是一致性。 React 总是一口气更新 DOM - 它不会显示部分结果。 WorkInprogress 树是用户看不到的“草稿”，因此 React 可以首先处理所有组件，然后将其更改冲洗到屏幕上。</p>
<p>在源代码中，您会看到许多函数从当前树和 workInProgress 树中获取 fiber 节点。这是一个这样的函数的签名：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>每个 fiber 节点都在 alternate 字段中保存对另一棵树的对应项的引用。当前树中的节点指向 workInProgress 树中的节点，反之亦然。</p>
<h2 id="side-effects"><a href="#side-effects" class="headerlink" title="side effects"></a>side effects</h2><p>我们可以将 React 中的组件视为使用 state 和 props 来计算 UI 表示的函数。每个其他活动，如改变 DOM 或调用生命周期方法，都应被视为副作用，或者简称为效果。文档中还提到了效果：</p>
<blockquote>
<p>您之前可能已经从 React 组件执行过数据获取、订阅或手动更改 DOM。我们称这些操作为“side effects”（或简称为“effect”），因为它们会影响其他组件并且无法在渲染期间完成。</p>
</blockquote>
<p>您可以看到大多数状态和道具更新将如何导致副作用。由于应用效果是一种工作，因此 fiber 节点是一种除了更新之外还可以跟踪 effect 的便捷机制。每个 fiber 节点都可以有与之关联的 effect。它们在 <code>effectTag</code> 字段中编码。</p>
<p>因此，Fiber 中的 effect 基本上定义了处理更新后实例需要完成的工作。对于宿主组件（DOM 元素），工作包括添加、更新或删除元素。对于类组件，React 可能需要更新 refs 并调用 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 生命周期方法。也有对应于其他类型 fiber 的其他作用。</p>
<h2 id="effects-list"><a href="#effects-list" class="headerlink" title="effects list"></a>effects list</h2><p>React 处理更新非常快，为了达到这种性能水平，它采用了一些有趣的技术。其中之一是构建具有快速迭代效果的 fiber 节点线性列表。迭代线性列表比树快得多，并且无需在没有副作用的节点上花费时间。</p>
<p>此列表的目标是标记具有 DOM 更新或与其关联的其他效果的节点。此列表是 <code>finishedWork</code> 树的子集，并使用 <code>nextEffect</code> 属性而不是 <code>current</code> 和 <code>workInProgress</code> 树中使用的子属性进行链接。</p>
<p>Dan Abramov 为 effect list 提供了一个类比。他喜欢把它想象成一棵圣诞树，用“圣诞灯”将所有有效节点捆绑在一起。为了形象化这一点，让我们想象一下下面的 fiber 节点树，其中突出显示的节点有一些工作要做。例如，我们的更新导致 c2 被插入 DOM，d2 和 c1 改变属性，b2 触发生命周期方法。效果列表会将它们链接在一起，以便 React 稍后可以跳过其他节点：</p>
<p><img src="https://images.indepth.dev/images/2019/07/image-52.png" alt="https://images.indepth.dev/images/2019/07/image-52.png"></p>
<p>您可以看到具有 effects 的节点是如何链接在一起的。当遍历节点时，React 使用 firstEffect 指针来确定列表的开始位置。所以上图可以表示为这样的线性列表：</p>
<p><img src="https://images.indepth.dev/images/2019/07/image-53.png" alt="https://images.indepth.dev/images/2019/07/image-53.png"></p>
<h2 id="Root-of-the-fiber-tree"><a href="#Root-of-the-fiber-tree" class="headerlink" title="Root of the fiber tree"></a>Root of the fiber tree</h2><p>每个 React 应用程序都有一个或多个充当容器的 DOM 元素。在我们的例子中，它是带有 ID 容器的 div 元素。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(React.createElement(ClickCounter), domContainer);</span><br></pre></td></tr></table></figure>

<p>React 为每个 <code>container</code> (root 节点) 创建一个 fiber root 对象。您可以使用对 DOM 元素的引用来访问它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberRoot = query(<span class="string">&quot;#container&quot;</span>)._reactRootContainer._internalRoot;</span><br></pre></td></tr></table></figure>

<p>这个 fiber root 是 React 保存对 fiber tree 的引用的地方。它存储在 fiber root 的当前属性中：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hostRootFiberNode = fiberRoot.current;</span><br></pre></td></tr></table></figure>

<p>fiber 树以一种特殊类型的 fiber 节点开始，即 HostRoot。它是在内部创建的，并充当最顶层组件的父级。通过 stateNode 属性从 HostRoot fiber 节点返回到 FiberRoot 有一个链接：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">fiberRoot.current.stateNode === fiberRoot; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>您可以通过 fiber root 访问最顶层的 HostRoot fiber 节点来探索 fiber 树。或者您可以像这样从组件实例中获取单个 fiber 节点：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">compInstance._reactInternalFiber;</span><br></pre></td></tr></table></figure>

<h2 id="Fiber-node-structure"><a href="#Fiber-node-structure" class="headerlink" title="Fiber node structure"></a>Fiber node structure</h2><p>现在让我们看一下为 ClickCounter 组件创建的 fiber 节点的结构：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">stateNode</span>: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">    <span class="attr">type</span>: ClickCounter,</span><br><span class="line">    <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">updateQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">memoizedState</span>: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="attr">pendingProps</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">memoizedProps</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">tag</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effectTag</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">nextEffect</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>span DOM 元素：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">stateNode</span>: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">    <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">updateQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">pendingProps</span>: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="attr">memoizedProps</span>: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="attr">tag</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">effectTag</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">nextEffect</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fiber 节点上有相当多的字段。我在前面的部分中描述了字段 alternate、effectTag 和 nextEffect 的用途。现在让我们看看为什么我们需要其他人。</p>
<h2 id="stateNode"><a href="#stateNode" class="headerlink" title="stateNode"></a>stateNode</h2><p>持有对组件类实例、DOM 节点或与 Fiber 节点关联的其他 React 元素类型的引用。一般来说，我们可以说这个属性用于保存与 fiber 相关的局部状态。</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>定义与此 fiber 关联的函数或类。对于类组件，它指向构造函数，对于 DOM 元素，它指定 HTML 标记。我经常使用这个字段来了解 fiber 节点与什么元素相关。</p>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>定义 fiber 的类型。它在协调算法中用于确定需要完成的工作。如前所述，工作因 React 元素的类型而异。函数 createFiberFromTypeAndProps 将 React 元素映射到相应的 fiber 节点类型。在我们的应用程序中，ClickCounter 组件的属性标记为 <code>1</code>，表示一个 <code>ClassComponent</code>，对于 <code>span</code> 元素，它的属性标记为<code>5</code>，表示一个 <code>HostComponent</code>。</p>
<h2 id="updateQueue"><a href="#updateQueue" class="headerlink" title="updateQueue"></a>updateQueue</h2><p>状态更新、回调和 DOM 更新队列。(A queue of state updates, callbacks and DOM updates.)</p>
<h2 id="memoizedState"><a href="#memoizedState" class="headerlink" title="memoizedState"></a>memoizedState</h2><p>用于创建输出的 fiber 的状态。在处理更新时，它会反映当前在屏幕上呈现的状态。</p>
<h2 id="memoizedProps"><a href="#memoizedProps" class="headerlink" title="memoizedProps"></a>memoizedProps</h2><p>在上一次渲染期间用于创建输出的 fiber 的 props。</p>
<h2 id="pendingProps"><a href="#pendingProps" class="headerlink" title="pendingProps"></a>pendingProps</h2><p>已从 React 元素中的新数据更新并需要应用于子组件或 DOM 元素的道具。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>带有一组孩子的唯一标识符，以帮助 React 确定哪些项目已更改，已添加或从列表中删除。它与此处描述的 React 的“列表和键”功能有关。<br>您可以在此处找到 fiber 节点的完整结构。我在上面的解释中省略了一堆字段。特别是，我跳过了构成我在上一篇文章中描述的树数据结构的指针 <code>child</code>、<code>sibling</code> 和 <code>return</code>。还有一类字段，如 <code>expirationTime</code>、<code>childExpirationTime</code> 和特定于 <code>Scheduler</code> 的模式。</p>
<h2 id="General-algorithm"><a href="#General-algorithm" class="headerlink" title="General algorithm"></a>General algorithm</h2><p>React 在两个主要阶段执行工作： <strong>render</strong> 和 <strong>commit</strong>。</p>
<p>在第一个 <code>render</code> 阶段，React 将更新应用到通过 setState 或 React.render 安排的组件，并确定 UI 中需要更新的内容。如果是初始渲染，React 会为从渲染方法返回的每个元素创建一个新的 fiber 节点。在接下来的更新中，现有 React 元素的 fiber 被重新使用和更新。<strong>该阶段的结果是标有副作用的 fiber 节点树。效果描述了在接下来的提交阶段需要完成的工作。</strong>在此阶段，React 获取标记有效果的 fiber 树并将它们应用于实例。它遍历效果列表并执行 DOM 更新和用户可见的其他更改。</p>
<p><strong>重要的是要了解第一个 render 阶段的工作可以异步执行。</strong> React 可以根据可用时间处理一个或多个 fiber 节点，然后停止以存储完成的工作并 yield 于某个事件。然后它从停止的地方继续。但有时，它可能需要放弃已完成的工作并重新从头开始。这些暂停之所以成为可能，是因为在此阶段执行的工作不会导致任何用户可见的更改，例如 DOM 更新。相反，接下来的 <code>commit</code> 阶段总是同步的。<strong>这是因为在此阶段执行的工作会导致用户可见的更改</strong>，例如 DOM 更新。这就是为什么 React 需要一次完成它们。</p>
<p>调用生命周期方法是 React 执行的一种工作。一些方法在 render 阶段调用，其他方法在 commit 阶段调用。这是在第一个渲染阶段工作时调用的生命周期列表：</p>
<ul>
<li>[UNSAFE_]componentWillMount (deprecated)</li>
<li>[UNSAFE_]componentWillReceiveProps (deprecated)</li>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>[UNSAFE_]componentWillUpdate (deprecated)</li>
<li>render</li>
</ul>
<p>如您所见，从 16.3 版本开始，一些在渲染阶段执行的遗留生命周期方法被标记为不安全。它们现在在文档中称为遗留生命周期。它们将在未来的 16.x 版本中被弃用，没有 UNSAFE 前缀的对应版本将在 17.0 中删除。您可以在此处阅读有关这些更改和建议的迁移路径的更多信息。</p>
<p>你好奇这是什么原因吗？</p>
<p>好吧，我们刚刚了解到，由于 render 阶段不会产生像 DOM 更新那样的副作用，因此 React 可以异步处理对组件的异步更新（甚至可能在多个线程中进行）。但是，标有 UNSAFE 的生命周期经常有被误解和巧妙地误用。<strong>开发人员倾向于将带有副作用的代码放在这些方法中，这可能会导致新的异步渲染方法出现问题。</strong>尽管只有没有 UNSAFE 前缀的对应项会被删除，但它们仍然可能会在即将到来的并发模式（您可以选择退出）中引起问题。</p>
<p>下面是在第二个提交阶段执行的生命周期方法列表：</p>
<ul>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因为这些方法在同步 <code>commit</code> 阶段执行，所以它们可能包含副作用并触及 DOM。</p>
<p>好的，现在我们了解了用于遍历树和执行工作的通用算法的背景知识。让我们开始吧。</p>
<h2 id="Render-Phase"><a href="#Render-Phase" class="headerlink" title="Render Phase"></a>Render Phase</h2><p>协调算法始终使用 renderRoot 函数从最顶层的 HostRoot fiber 节点开始。但是，React 会跳出（跳过）已经处理过的 fiber 节点，直到它找到未完成工作的节点。例如，如果您在组件树深处调用 setState，React 将从顶部开始但会快速跳过父节点，直到它找到到调用了 setState 方法的组件。</p>
<h2 id="Main-steps-of-the-work-loop"><a href="#Main-steps-of-the-work-loop" class="headerlink" title="Main steps of the work loop"></a>Main steps of the work loop</h2><p>所有 fiber 节点都在工作循环中处理。下面是循环同步部分的实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYield</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，nextUnitOfWork 持有对来自 workInProgress 树的 fiber 节点的引用，它有一些工作要做。当 React 遍历 Fibers 树时，它使用这个变量来了解是否有任何其他 fiber 节点有未完成的工作。当前 fiber 处理完成后，该变量将包含对树中下一个 fiber 节点的引用或空值。在这种情况下，React 退出工作循环并准备好提交更改。</p>
<p>有 4 个主要函数用于遍历树并启动或完成工作：</p>
<ul>
<li>performUnitOfWork</li>
<li>beginWork</li>
<li>completeUnitOfWork</li>
<li>completeWork</li>
</ul>
<p>为了演示如何使用它们，请看下面遍历 fiber 树的动画。我在演示中使用了这些功能的简化实现。每个函数都需要一个 fiber 节点来处理，随着 React 沿着树向下移动，您可以看到当前活动的 fiber 节点发生变化。您可以在视频中清楚地看到算法如何从一个分支转到另一个分支。它首先完成孩子的工作，然后再移交给父母。</p>
<p><img src="https://images.indepth.dev/images/2019/08/tmp2.gif" alt="https://images.indepth.dev/images/2019/08/tmp2.gif"></p>
<blockquote>
<p>请注意，笔直的垂直连接表示兄弟姐妹，而弯曲的连接表示孩子，例如 b1 没有孩子，而 b2 有一个孩子 c1。</p>
</blockquote>
<p>这是视频的链接，您可以在其中暂停播放并检查当前节点和功能状态。从概念上讲，您可以将“开始”视为“步入”一个组件，将“完成”视为“走出”它。当我解释这些函数的作用时，您还可以尝试此处的示例和实现。</p>
<p>让我们从前两个函数 performUnitOfWork 和 beginWork 开始：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitWork</span>(<span class="params">workInprogree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;work performed for &quot;</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>performUnitOfWork</code> 从 <code>WorkInProgress</code> 树接收一个 fiber 节点，并通过调用 <code>BeginWork</code> 函数开始工作。这是启动所有需要为 fiber 执行的活动的功能。出于此演示的目的，我们简单地记录了 fiber 的名称，以表示工作已经完成。函数 <code>beginWork</code> 开始工作总是将指针返回下一个孩子以在循环或 null 中进行处理。</p>
<p>如果有下一个孩子，它将被分配给 <code>workLoop</code> 函数中的变量 <code>nextUnitOfWork</code> 。然而，如果没有子节点，React 知道它到达了分支的末尾，因此它可以完成当前节点。<strong>一旦节点完成，它将需要为兄弟姐妹执行工作，然后回溯到父节点</strong>。这是在 <code>completeUnitOfWork</code> 函数中完成的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there is a sibling, return it</span></span><br><span class="line">      <span class="comment">// to perform work for this sibling</span></span><br><span class="line">      <span class="keyword">return</span> siblingFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there&#x27;s no more work in this returnFiber,</span></span><br><span class="line">      <span class="comment">// continue the loop to complete the parent.</span></span><br><span class="line">      workInProgress = returnFiber;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve reached the root.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;work completed for &quot;</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以看到该函数的要点是一个大的 while 循环。当 <code>workInProgress</code> 节点没有子节点时，React 会进入此函数。完成当前 fiber 的工作后，它会检查是否有兄弟节点。如果找到，React 退出该函数并返回指向 <code>sibling</code> 的指针。它将被分配给 <code>nextUnitOfWork</code> 变量，React 将执行从这个兄弟开始的分支的工作。<strong>重要的是要明白，此时 React 只完成了前面兄弟姐妹的工作。它尚未完成父节点的工作。只有从子节点开始的所有分支都完成后，它才完成父节点和回溯的工作。</strong></p>
<p>从实现中可以看出，<code>completeUnitOfWork</code> 主要用于迭代目的，而主要活动发生在 <code>beginWork</code> 和 <code>completeWork</code> 函数中。在本系列的后续文章中，我们将了解当 React 进入 <code>beginWork</code> 和 <code>completeWork</code> 函数时，ClickCounter 组件和 span 节点会发生什么。</p>
<h2 id="Commit-Phase"><a href="#Commit-Phase" class="headerlink" title="Commit Phase"></a>Commit Phase</h2><p>该阶段从函数 <code>completeRoot</code> 开始。这是 React 更新 DOM 并调用突变前后生命周期方法的地方。</p>
<p>当 React 进入这个阶段时，它有 2 棵树和 effect 列表。第一棵树表示当前在屏幕上呈现的状态。然后在渲染阶段构建了一个 alternate 树。它在源代码中称为 <code>finishedWork</code> 或 <code>workInProgress</code> ，代表需要反映在屏幕上的状态。这个备用树通过 <code>child</code> 指针和 <code>sibling</code> 指针与当前树类似地链接。</p>
<p>然后，有一个 effect 列表 - 通过 <code>nextEffect</code> 指针链接的 <code>finishedWork</code> 的一个节点子集。请记住，效果列表是运行渲染阶段的结果。<strong>渲染的全部要点是确定需要插入，更新或删除哪些节点，哪些组件需要调用其生命周期方法</strong>。这就是 effect list 告诉我们的。正是在 <code>commit</code> 阶段迭代的一组节点。</p>
<blockquote>
<p>出于调试目的，可以通过 fiber root 的当前属性访问 <code>cuurent</code> 树。可以通过当前树中 <code>HostFiber</code> 节点的 <code>alternate</code> 属性访问 <code>finishedWork</code> 树。</p>
</blockquote>
<p>在 commit<br>阶段运行的主要函数是 commitRoot。基本上，它执行以下操作：</p>
<ul>
<li>Calls the <code>getSnapshotBeforeUpdate</code> lifecycle method on nodes tagged with the Snapshot effect</li>
<li>Calls the <code>componentWillUnmount</code> lifecycle method on nodes tagged with the Deletion effect</li>
<li>Performs all the DOM insertions, updates and deletions<br>Sets the <code>finishedWork</code> tree as current</li>
<li>Calls <code>componentDidMount</code> lifecycle method on nodes tagged with the Placement effect</li>
<li>Calls <code>componentDidUpdate</code> lifecycle method on nodes tagged with the Update effect</li>
</ul>
<p>在调用 pre-mutation 方法 <code>getSnapshotBeforeUpdate</code> 之后，React 将所有副作用提交到树中。它分两次完成。第一遍执行所有 DOM（主机）插入、更新、删除和引用卸载。然后 React 将 <code>finishedWork</code> 树分配给 FiberRoot，将 <code>workInProgress</code> 树标记为当前树。这是在提交阶段的第一遍之后完成的，因此前一棵树在 <code>componentWillUnmount</code> 期间仍然是当前的，但在第二遍之前，因此完成的工作在 componentDidMount/Update 期间是当前的。在第二遍中，React 调用所有其他生命周期方法和 ref 回调。这些方法作为单独的传递执行，因此整个树中的所有放置、更新和删除都已被调用。</p>
<p>这是运行上述步骤的功能的要旨：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">  commitBeforeMutationLifecycles();</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line">  commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些子函数中的每一个都实现了一个循环，该循环遍历 effect 列表并检查效果的类型。当它找到与函数目的相关的效果时，它就会应用它。</p>
<h2 id="Pre-mutation-lifecycle-methods"><a href="#Pre-mutation-lifecycle-methods" class="headerlink" title="Pre-mutation lifecycle methods"></a>Pre-mutation lifecycle methods</h2><p>例如，下面是遍历 effect 树并检查节点是否具有 <code>Snapshot</code> effect 的代码：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类组件，这种效果意味着调用 getSnapshotBeforeUpdate 生命周期方法。</p>
<h2 id="DOM-updates"><a href="#DOM-updates" class="headerlink" title="DOM updates"></a>DOM updates</h2><p><code>commitAllHostEffects</code> 是 React 执行 DOM 更新的函数。该函数基本上定义了需要为节点完成的操作类型并执行它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">        <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Update: &#123;</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">            commitDeletion(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是，React 在 <code>commitDeletion</code> 函数中调用 <code>componentWillUnmount</code> 方法作为删除过程的一部分。</p>
<h2 id="Post-mutation-lifecycle-methods"><a href="#Post-mutation-lifecycle-methods" class="headerlink" title="Post-mutation lifecycle methods"></a>Post-mutation lifecycle methods</h2><p>commitAllLifecycles 是 React 调用所有剩余生命周期方法 <code>componentDidUpdate</code> 和 <code>componentDidMount</code> 的函数。</p>
<p>我们终于完成了。让我知道您对这篇文章的看法或在评论中提问。查看系列中的下一篇文章深入解释 React 中的状态和道具更新。我还有很多文章在为调度程序、子协调过程以及如何构建效果列表提供深入的解释。我还计划制作一个视频，展示如何以本文为基础调试应用程序。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
  </entry>
  <entry>
    <title>一封阿里云的喝茶邮件</title>
    <url>/2022/02/08/%E4%B8%80%E5%B0%81%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%96%9D%E8%8C%B6%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>事情是这样的，就在今天早上，收到了一封来自阿里云的【喝茶（核查）通知】。一看邮件，很明显就是域名没有解析到内地节点的服务器上面呢。回想一下自己的解析，它说的对！。。。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081154.png" alt="why"></p>
<span id="more"></span>

<h2 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h2><p>在老早以前了，我用 hexo 部署 blog 在 GitHub Page 上面，然后解析了自己的域名在 gh-page 上，显然，GitHub Page 的服务器不在内地。我为了访问速度能快那么一丁点，就继续使用了 cloudflare 的 cdn 加速，因此也在上面设置了 DNS，但是我在 DNS 上也解析了一个二级域名到了阿里云的服务器上啊。按照网上的说法，设置一个二级域名解析到内地服务器就行了呢，然后点击复查连接后还是检查有问题。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>通过原由的分析，我这次将问题放在了 cloudflare 上面，看了一下 DNS 设置。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081207.png" alt="dns setting"><br>看到上面的代理状态了吗，我就开始怀疑是这个的问题，ok,查查什么意思。看到了下面的一个问题。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081210.png" alt="Q&amp;A proxy"><br>按照上面的说法，显然 proxy 就是一个代理，访问域名时，如果设置了代理，那么就会走代理，而不是直接走解析地址。<br>那我们来 ping 一下看看。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081213.png" alt="ping res"><br>上面的两个域名其实是同一个 ip,但是 ping 出来响应的不一样，因此，确实是有代理的存在。<br>我自己的服务器 ip 是 47 开始的，上面的 ping 结果一个是 cloudflare 代理的服务器，一个是 gh-page 的服务器。<br>那么关闭代理就可以了吗？<br>是的，可以了。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081229.jpg" alt="pre|left|350*0"><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081231.png" alt="|right|250*0"><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202202081217.png" alt="result"></p>
]]></content>
      <categories>
        <category>一些趣事的🌟</category>
      </categories>
  </entry>
  <entry>
    <title>svg基础</title>
    <url>/2022/07/21/svg%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>svg（Scalable Vector Graphics）可缩放的矢量图形，是 W3C XML 的分支语言之一，用于标记可缩放的矢量图形。</p>
<span id="more"></span>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>定义的命名空间可以把通配、元素、属性选择器限制在指定命名空间里的元素。</p>
<h3 id="声明命名空间"><a href="#声明命名空间" class="headerlink" title="声明命名空间"></a>声明命名空间</h3><p>使用xmlns属性进行命名空间的声明，下面的声明意味着svg以及它的子节点都属于“<a href="http://www.w3.org/2000/svg%E2%80%9D%E8%BF%99%E4%B8%AAsvg%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%82">http://www.w3.org/2000/svg”这个svg命名空间。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SVG-元素"><a href="#SVG-元素" class="headerlink" title="SVG 元素"></a>SVG 元素</h2><p>See more：<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element#svg_%E5%85%83%E7%B4%A0%EF%BC%88%E6%8C%89%E7%B1%BB%E5%88%AB%E5%88%86%E7%B1%BB%EF%BC%89">mdn-svg元素参考</a></p>
<blockquote>
<p>上面列出了一些常见以及常用的svg元素，下面我们可以来看看它们是什么样子的以及怎么改变它们的属性。</p>
</blockquote>
<h2 id="图形元素"><a href="#图形元素" class="headerlink" title="图形元素"></a>图形元素</h2><h3 id="基础图形元素"><a href="#基础图形元素" class="headerlink" title="基础图形元素"></a>基础图形元素</h3><iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/RwMVwNE?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/RwMVwNE"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h3 id="线段属性"><a href="#线段属性" class="headerlink" title="线段属性"></a>线段属性</h3><p>对于stroke填充的线段来说，stroke-dasharray与stroke-dashoffset是两个比较有用的属性。</p>
<ul>
<li>  stroke-dasharray：控制用控制线段实线与虚线的单元长度。</li>
</ul>
<!---->

<ul>
<li>  stroke-dasharray：控制虚线的偏移</li>
</ul>
<blockquote>
<p>stroke-dasharray结合animate的例子</p>
</blockquote>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/ZExoMmN?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/ZExoMmN"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<blockquote>
<p>使用stroke-dashoffset与animateTransform、animate绘制加载动画</p>
</blockquote>
<p>用animate控制stroke-dashoffset虚线部分的偏移，同时animateTransform控制整个圆环的自转。</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/ExELqMa?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/ExELqMa"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<blockquote>
<p>心电图</p>
</blockquote>
<p>这里主要思路就是使用polyline绘制折线图，使用stroke-dasharray绘制虚线，stroke-dashoffset控制虚线空白处的偏移，然后用animate控制stroke-dashoffset的值，就能看见这种线段移动的效果了🫥</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/qBoYyxL?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/qBoYyxL"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h3 id="强大的path元素"><a href="#强大的path元素" class="headerlink" title="强大的path元素"></a>强大的path元素</h3><p>上面的基本图形都是可以用path来创建的，而path的功能远远不止上面这些图形😏。path元素的形状通过属性d来定义，属性d的值是一个“命令+参数”的序列。下面就列出了一些常用的命令。</p>
<h4 id="直线命令"><a href="#直线命令" class="headerlink" title="直线命令"></a>直线命令</h4><ol>
<li><p>Moveto</p>
<ul>
<li> <code>M x,y</code> 在这里x和y是绝对坐标，分别代表水平坐标和垂直坐标。</li>
<li> <code>m dx,dy</code> 在这里dx和dy是相对于当前点的距离，分别是向右和向下的距离。</li>
</ul>
</li>
</ol>
<!---->

<ol start="2">
<li><p>Lineto<br><code>Lineto</code>指令将绘制一条直线段。这个直线段从当前位置移到指定位置</p>
<ul>
<li>  <code>Lx,y</code> x与y是绝对坐标，分别代表水平坐标和垂直坐标</li>
<li>  <code>ldx,dy</code> dx和dy是相对于当前点的距离，分别是向右和向下的距离</li>
<li>  <code>Hx</code> 绝对坐标，水平移动</li>
<li>  <code>Vy</code> 绝对坐标，垂直移动</li>
<li>  <code>hdx</code> 水平移动相对距离</li>
<li>  <code>vdy</code> 垂直移动相对距离</li>
</ul>
</li>
<li><p> Z or z：闭合路径</p>
</li>
</ol>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/NWYjyxL?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/NWYjyxL"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h4 id="曲线命令"><a href="#曲线命令" class="headerlink" title="曲线命令"></a>曲线命令</h4><p>小写的指令意义同上，都是跟相对的距离</p>
<ol>
<li> Curveto</li>
</ol>
<ul>
<li>   C命令创建一个三次贝塞尔曲线，其中 (x1,y1) (x2,y2)为控制点，x,y为曲线终点</li>
<li> <code>C x1 y1, x2 y2, x y </code>or <code>c dx1 dy1, dx2 dy2, dx dy</code></li>
</ul>
<!---->

<ol start="2">
<li> Smooth Curveto</li>
</ol>
<ul>
<li>   S命令可以用来创建于与前面一样的贝塞尔曲线，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或者S命令，那当前点将作为第一个控制点。最大的作用就是光滑地连接两条曲线</li>
<li> <code>S x2 y2,x y</code> or <code>s dx2 dy2, dx dy</code></li>
</ul>
<blockquote>
<p>C、S命令例子</p>
</blockquote>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/rNdmJma?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/rNdmJma"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<ol start="3">
<li> Quadratic Bézier curveto</li>
</ol>
<ul>
<li>  Q命令用来创建一条二次贝塞尔曲线，只需要一个控制点</li>
<li>  <code>Q x1 y1,x y</code> or <code>q dx1 dx2,dx dy</code></li>
</ul>
<ol start="4">
<li> Smooth quadratic Bézier curveto</li>
</ol>
<ul>
<li> T命令类似S命令，用于平滑链接二次贝塞尔曲线</li>
<li> <code>T x1 y1 </code>or <code>t dx dy</code></li>
</ul>
<blockquote>
<p>Q、T命令例子</p>
</blockquote>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/PoRJaqN?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/PoRJaqN"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<ol start="5">
<li> Arc</li>
</ol>
<ul>
<li>A命令也可以用于绘制曲线<ul>
<li>  <code>A rx ry x-axis-rotation large-arc-flag sweep-flag x y</code> <code>a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</code></li>
<li>    参数说明：</li>
<li>    rx ry: x、y轴半径</li>
<li>    X-axis-rotation: 绕x轴旋转角度</li>
<li>    large-arc-flag：0-弧小于180度、1-弧大于180度</li>
<li>    sweep-flag：0-逆时针画弧、1-顺时针画弧</li>
<li>    x y：终点坐标</li>
</ul>
</li>
</ul>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><blockquote>
<p>放入形状元素内部，在指定的时间段里，设置相关属性的开始与结束值，变化曲线等。</p>
</blockquote>
<h3 id="动画元素"><a href="#动画元素" class="headerlink" title="动画元素"></a>动画元素</h3><ul>
<li>  animate：用来定义一个元素的某个属性在相应时间的变化</li>
<li>  animateTransform：改变目标元素上的一个变形属性，控制旋转、缩放、平移、斜切变换</li>
<li>  animateMotion：定义目标元素如何沿一个路径运动</li>
<li>  discard：指定在何时丢弃特定元素，从而减少 SVG 用户代理所需的资源。</li>
<li>  mpath：配合animateMotion，可代替animateMotion的path属性，用于引用一个外部的path</li>
<li>  set：可以用来设定一个属性值，并为该值赋予一个持续时间。它支持所有的属性类型， 包括那些原理上不能插值的， 例如值为字符串和布尔类型的属性。 set 元素是非叠加的。无法在其上使用 additive 属性或 accumulate 属性，即使声明了这些属性也会自动被忽略。</li>
</ul>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/wvmrYLy?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/wvmrYLy"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><p>这里大致可以分为三类：</p>
<ol>
<li> 取值属性：控制要动画的属性（如x坐标，width等属性）的值</li>
</ol>
<pre><code>-  **calcMode：** 设置动画的变化曲线（discrete | linear | paced | spline），除了animateMotion默认是paced外，其他是默认linear，当一些不支持线性变化的属性值（string类型的）就会变为discrete。

-  **values：** 定义动画过程中的值序列（一个或多个值的分号分隔列表）的值。 如果指定了此属性，则将忽略在元素上设置的任何 `from`, `to`, 和 `by` 属性值。

-  **keyTimes：** 以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与`values`中的值一一对应，定义了`values`中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在 [0-1] 之间的浮点数，表示动画的完成时间。每一个连续的时间值必须大于等于前一个时间值。

    -   对于 linear 和 spline动画，列表中的第一个时间值必须为 0，列表的最后一个时间值必须为 1。与每个 value 关联的时间值定义了何时设置该 value，该 value 在 keyTimes 的时间 值的中间插值。
    -   对于 discrete动画，列表中的第一个值必须为 0。与每个 value 关联的时间值定义了何时设置该 value，动画函数使用该 value，直到 keyTimes 中定义的下一个时间值。
    -   如果插值模式是 paced动画，keyTimes 属性被忽略。

-  **keySplines：** 定义了一组与 keyTimes 列表关联的 Bézier 曲线控制点，定义了一个控制间隔（keyTimes的值列表长度减1即为间隔数）的三次 Bézier 函数。只有spline动画才会有效。

-  **from：** 指定属性的开始值

-  **by：** 指定将在动画期间修改的属性的相对偏移值

-  **to：** 表示将在动画期间修改的属性的最终值
</code></pre>
<blockquote>
<p>取值属性例子</p>
</blockquote>
  <iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/WNzdXNZ?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
    See the Pen <a href="https://codepen.io/l-jour/pen/WNzdXNZ"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
    on <a href="https://codepen.io">CodePen</a>.
  </iframe>

<ol start="2">
<li> 时间属性：控制动画如何开始，何时开始、重复次数等</li>
</ol>
<pre><code>-  **begin：** 动画开始时间

-  **end：** 动画结束时间

-  **dur：** 动画持续时间

-  **min/max：** 限制动画的最小/大持续时间

-  **restart：** 控制动画是否可以重新开始

    -   `always` ：任何时候都可重新开始
    -   `whenNotActive` ：非动画时可重新开始
    -   `never` ：任何时候都不能重新开始

-  **repeatCount：** 指定动画重复的次数、值必须大于 0。

-  **repeatDur：** 指定动画的重复时间

-  **fill：** 控制动画结束时的状态。有两个值可选

    -   remove：在动画的激活持续时间结束后，动画效果会移除（不再应用）。在动画的激活结束后，动画不再对目标元素有影响（除非动画重新开始）。
    -   freeze：在动画激活持续时间结束后，文档持续时间的剩余时间里（或者直到动画重新开始）动画效果会“冻结”着。（保持动画终态）
</code></pre>
<ol start="3">
<li> 目标属性：控制要动画的属性</li>
</ol>
<pre><code>-  **ttributeType：** 当attributeType=&quot;XML&quot;时，attributeName被认为是XML的属性；当attributeType=&quot;CSS&quot;时，attributeName被认为是css的属性；不指定attributeType时，默认为&quot;auto&quot;，会先将attributeName作为css的属性，如果无效，再将attributeName作为XML的属性。
-  **attributeName：** 要动画的属性名
</code></pre>
<!---->

<ol start="4">
<li> 其他属性：additive、accumulate</li>
</ol>
<pre><code>-  **additive：** 控制动画属性是否是附加的。
-  **accumulate：** 在原来的结果的基础上重复动画的时候每一次循环都累加。这个属性告诉动画是否是每次循环，前一个动画属性值要加上去。需要设置from与to属性。
</code></pre>
<blockquote>
<p>additive、accumulate例子</p>
</blockquote>
  <iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/PoREOjj?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
    See the Pen <a href="https://codepen.io/l-jour/pen/PoREOjj"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
    on <a href="https://codepen.io">CodePen</a>.
  </iframe>

<h2 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h2><blockquote>
<p>结构元素关注的是复用</p>
</blockquote>
<ul>
<li>  <strong>defs：</strong> 定义一个复用的图形。在<code>defs</code>元素中定义的图形元素不会直接呈现。 你可以在你的视口的任意地方利用 <code>use</code>元素呈现这些元素。</li>
</ul>
<!---->

<ul>
<li>  <strong>g：</strong> 组合子元素的容器，g元素的属性会被其所有的子元素继承 。与<code>defs</code>相比，g定义的除了复用外，在定义时会进行渲染。</li>
</ul>
<!---->

<ul>
<li>  <strong>symbol：</strong> 定义一个图形模版对象，使用<code>use</code>元素实例化。<code>symbol</code>元素对图形的作用是在同一文档中多次使用，添加结构和语义。symbol通过<code>use</code>调用时，<code> &lt;use  ``/``&gt;</code>可以设置height、width控制实际绘制的大小。</li>
</ul>
<!---->

<ul>
<li>  <strong>svg</strong> <strong>：</strong> 如果 <code>svg</code> 不是根元素，<code>svg</code> 元素可以用于在当前文档（比如说，一个 HTML 文档）内嵌套一个独立的 svg 片段 。 这个独立片段拥有独立的视口和坐标系统。</li>
</ul>
<!---->

<ul>
<li><p><strong>marker：</strong> 定义了在特定的path元素、line元素、polyline元素或者polygon元素上绘制箭头或者多边形标记图形。</p>
<ul>
<li>  refx：定义元素参考点的x坐标 (默认是0)</li>
<li>  refy：定义元素参考点的y坐标 (默认是0)</li>
<li>  markerWidth：表示根据 viewBox 和 preserveAspectRatio 属性渲染 <code>&lt;marker&gt;</code> 时要适合的视口宽度</li>
<li>  markerHeight：表示根据 viewBox 和 preserveAspectRatio 属性渲染 <code>&lt;marker&gt; </code>时要适合的视口高度</li>
<li>  markerUnits：指示标记放置在形状上的位置时如何旋转</li>
</ul>
</li>
</ul>
<!---->

<ul>
<li>  mask</li>
</ul>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/GRxmgEN?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/GRxmgEN"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h2 id="滤镜元素"><a href="#滤镜元素" class="headerlink" title="滤镜元素"></a>滤镜元素</h2><h3 id="相关标签"><a href="#相关标签" class="headerlink" title="相关标签"></a>相关标签</h3><blockquote>
<p>滤镜通过<code>&lt;filter&gt;</code>在<code>&lt;defs&gt;</code>中进行定义，在filter标签中提供一系列图元，使用滤镜只需为svg元素设置filter属性即可。</p>
</blockquote>
<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><p>  in：标识输入的原语</p>
<pre><code>-   SourceGraphic：该关键词表示图形元素自身将作为`&lt;filter&gt;`原语的原始输入
-   SourceAlpha：该关键词表示图形元素自身将作为`&lt;filter&gt;`原语的原始输入. SourceAlpha 与 SourceGraphic 具有相同的规则除了 SourceAlpha 只使用元素的透明度。
-   BackgroundImage：该关键词表示 filter 元素当前底下的区域的图形快照将被调用。
-   BackgroundAlpha：BackgroundImage 相同除了只使用透明度。
-   FillPaint：此关键字表示过滤效果的目标元素上的`fill`属性值。在许多情况下，FillPaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。
-   StrokePaint：此关键字表示滤镜效果的目标元素上的笔画属性的值。在许多情况下，StrokePaint 在任何地方都是不透明的，但如果形状是使用渐变或图案绘制的，它本身包括透明或半透明部分，则情况可能并非如此。
</code></pre>
<!---->

<p>  in2：in2 属性标识给定filter原语的第二个输入。它的工作原理与 in 属性完全相同。</p>
<blockquote>
<p>colorMatrix颜色矩阵变换</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* R G B A 1 颜色矩阵计算 */</span></span><br><span class="line"> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">// R = 1*R + 0*G + 0*B + 0*A + 0 </span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">// G = 0*R + 1*G + 0*B + 0*A + 0 </span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">// B = 0*R + 0*G + 1*B + 0*A + 0 </span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="comment">// A = 0*R + 0*G + 0*B + 1*A + 0</span></span><br></pre></td></tr></table></figure>

<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/xxWzjde?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/xxWzjde"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>


<blockquote>
<p>使用feGaussianBlur、feColorMatrix、feBlend实现粘稠效果</p>
</blockquote>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/JjLZbQO?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/JjLZbQO"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>


<blockquote>
<p>使用feComposite并设置operator为in，控制显示图像的一部分。</p>
</blockquote>
<p>关于feComposite，更多可以看这里：<a href="https://apike.ca/prog_svg_filter_feComposite.html">feComposite</a></p>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/wvmXOwZ?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/wvmXOwZ"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>


<blockquote>
<p>feDisplacementMap、feTurbulence</p>
</blockquote>
<p>feDisplacementMap推荐看这篇：<a href="https://www.zhangxinxu.com/wordpress/2017/12/understand-svg-fedisplacementmap-filter/">深入理解SVG feDisplacementMap滤镜及实际应用</a></p>
<p>feTurbulence推荐看这篇：<a href="https://zhuanlan.zhihu.com/p/366438535">说说SVG的feTurbulence滤镜</a></p>
<p>位置转换公式：</p>
<p><code>P&#39;(x,y) ← P(x + scale * (XC(x,y) - 0.5), y + scale * (YC(x,y) - 0.5))</code></p>
<iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/OJvwJqV?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/OJvwJqV"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h2 id="渐变元素"><a href="#渐变元素" class="headerlink" title="渐变元素"></a>渐变元素</h2><h3 id="linearGradient：线性渐变"><a href="#linearGradient：线性渐变" class="headerlink" title="linearGradient：线性渐变"></a>linearGradient：线性渐变</h3><ul>
<li>  gradientUnits: 控制渐变坐标的单位</li>
<li>  gradientTransform: 对渐变坐标系进行变换（translate、skew、rotate。。。）</li>
<li>  x1：线性渐变起点x坐标-   y1：线性渐变起点y坐标</li>
<li>  x2：线性渐变终点x坐标-   y2：线性渐变终点y坐标</li>
<li>  spreadMethod：定义如何在渐变之外填充    -   pad：用渐变终点颜色去填充额外区域    -   repeat：按照开始的渐变顺序重复    -   reflect：按照开始的渐变相反顺序重复</li>
</ul>
  <iframe height="300" style="width: 100%;" scrolling="no" title="feDisplacementMap" src="https://codepen.io/l-jour/embed/JjLMMjR?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
    See the Pen <a href="https://codepen.io/l-jour/pen/JjLMMjR"></a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
    on <a href="https://codepen.io">CodePen</a>.
  </iframe>

<h3 id="radialGradient：径向渐变"><a href="#radialGradient：径向渐变" class="headerlink" title="radialGradient：径向渐变"></a>radialGradient：径向渐变</h3><ul>
<li>  gradientUnits：控制渐变坐标的单位</li>
<li>  gradientTransform：对渐变坐标系进行变换（translate、skew、rotate。。。）</li>
<li>  cx: 用来定义径向渐变终止圆的 x 轴坐标(默认50%)。</li>
<li>  cy：用来定义径向渐变终止圆的 y 轴坐标。</li>
<li>  r：用来定义径向渐变终止圆的半径。</li>
<li>  fx：用来定义径向渐变的焦点的 x 轴坐标</li>
<li>  fy：用来定义径向渐变的焦点的 y 轴坐标</li>
<li>  spreadMethod：确定如何在渐变的定义边缘之外填充形状。    -   pad：用渐变终点颜色去填充额外区域    -   repeat：按照开始的渐变顺序重复    -   reflect：按照开始的渐变相反顺序重复</li>
<li>  stop：渐变的颜色坡度</li>
</ul>
<iframe height="300" style="width: 100%;" scrolling="no" title="svg-radialgradient" src="https://codepen.io/l-jour/embed/zYWWLBa?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/l-jour/pen/zYWWLBa">
  svg-radialgradient</a> by L-jour (<a href="https://codepen.io/l-jour">@l-jour</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h2 id="关于svg与canvas"><a href="#关于svg与canvas" class="headerlink" title="关于svg与canvas"></a>关于svg与canvas</h2><p>  可以看看msdn的文章<a href="https://docs.microsoft.com/zh-cn/previous-versions/msdn10/Hh377884(v=MSDN.10)">如何为您的网站在Canvas和SVG之间做出选择</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  svg的世界非常丰富，并且很多属性可以作用不同的元素、拥有不同的效果。元素直接有可以搭配使用，如多个动画，多个滤镜等等，滤镜元素还涉及更多领域知识。总之，元素种类、元素属性非常多，还是需要得慢慢地学习、阅读相关的案例并操作一下才能有所掌握。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>  <a href="https://apike.ca/prog_svg_filter_feComposite.html">feComposite</a></li>
<li>  <a href="https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A">贝塞尔曲线-wiki</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【译】Javascript 中的 CJS、AMD、UMD 和 ESM 到底是什么？</title>
    <url>/2023/02/10/%E3%80%90%E8%AF%91%E3%80%91Javascript%20%E4%B8%AD%E7%9A%84%20CJS%E3%80%81AMD%E3%80%81UMD%20%E5%92%8C%20ESM%20%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>原文：<a href="https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm">https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm</a></p>
<p>一开始，Javascript 没有导入/导出模块的方法。这是个问题。想象一下只在一个文件中编写您的应用程序——那将是一场噩梦！</p>
<p>然后，比我聪明得多的人试图为 Javascript 添加模块化。其中一些是 CJS、AMD、UMD 和 ESM。您可能听说过其中一些方法（还有其他方法，但这些都是大玩家）。</p>
<span id="more"></span>

<h2 id="CJS"><a href="#CJS" class="headerlink" title="CJS"></a>CJS</h2><p>CJS 是 CommonJS 的缩写。这是它的样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//importing</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="built_in">require</span>(<span class="string">&quot;./doSomething.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//exporting</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>你们中的一些人可能立即会认为 CJS 语法来自于 nodejs。那是因为 nodejs 使用 CJS 模块格式。</li>
<li>CJS 同步导入模块。</li>
<li>您可以从库 node_modules 或本地目录导入。通过 <code>const myLocalModule = require(&#39;./some/local/file.js&#39;)</code> 或 <code>var React = require(&#39;react&#39;);</code></li>
<li>当 CJS 导入时，它会给你一个导入对象的副本。相当于一个引用地址。</li>
<li>CJS 将在浏览器中不起作用。它必须被 transpiled and bundled。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ============ foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;from foo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============ bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;./foo.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">foo.foo = foo.foo + <span class="string">&quot; and from bar&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============ index.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;./foo.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;before require bar:&quot;</span>, foo); <span class="comment">// &#123;foo: &#x27;from foo&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&quot;./bar.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after require bar:&quot;</span>, foo); <span class="comment">// &#123;foo: &#x27;from foo and from bar&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;definitely same memory address:&quot;</span>, bar === foo); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 代表异步模块定义。这是一个示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;dep1&quot;</span>, <span class="string">&quot;dep2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Define the module value by returning a value.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;simplified CommonJS wrapping&quot; https://requirejs.org/docs/whyamd.html</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">&quot;dep1&quot;</span>),</span><br><span class="line">    dep2 = <span class="built_in">require</span>(<span class="string">&quot;dep2&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>AMD 异步导入模块（因此得名）。</li>
<li>AMD 是为前端而生的（当它被提议时）（而 CJS 是后端）。</li>
<li>AMD 语法不如 CJS 直观。我认为 AMD 与 CJS 完全相反.</li>
</ul>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>UMD 代表通用模块定义.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">&quot;jquery&quot;</span>, <span class="string">&quot;underscore&quot;</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>), <span class="built_in">require</span>(<span class="string">&quot;underscore&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.Requester = factory(root.$, root._);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$, _</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this is where I defined my module implementation</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Requester = &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Requester;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ul>
<li>适用于前端和后端（因此得名 universal）。</li>
<li>与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。在<a href="https://github.com/umdjs/umd/">此处</a>查看更多模式。</li>
<li>在使用 Rollup/Webpack 等打包器时，UMD 通常用作后备模块</li>
</ul>
<h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><p>ESM 代表 ES 模块。实现标准的模块系统是 Javascript 的提议。相信很多人都看过这个：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./myLib&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your Function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="function"><span class="title">function1</span>(<span class="params"></span>)</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="function"><span class="title">function2</span>(<span class="params"></span>)</span> &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>适用于许多现代浏览器</li>
<li>它兼具两全其美：类似 CJS 的简单语法和 AMD 的异步</li>
<li>Tree-shakeable，由于 ES6 的静态模块结构</li>
<li>ESM 允许像 Rollup 这样的打包器删除不必要的代码，允许站点发送更少的代码以获得更快的加载。</li>
<li>可以在 HTML 中调用，只需执行以下操作：(script 标签标注 type=’module’)，node 环境下可以在<code>package.json</code>中添加<code>type=&#39;module&#39;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; func1 &#125; <span class="keyword">from</span> <span class="string">&quot;my-lib&quot;</span>;</span></span><br><span class="line"><span class="javascript">  func1();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器兼容性：</p>
<ul>
<li>Safari 10.1.</li>
<li>Chrome 61.</li>
<li>Firefox 60.</li>
<li>Edge 16.</li>
</ul>
<h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== foo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;from foo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== bar.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">foo.foo = foo.foo + <span class="string">&quot; and from bar.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== index.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&quot;./bar.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出（import bar from &#x27;./bar.js 提前了）</span></span><br><span class="line"><span class="comment">// bar: &#123; foo: &#x27;from foo and from bar.js&#x27; &#125;</span></span><br><span class="line"><span class="comment">// index: &#123; foo: &#x27;from foo and from bar.js&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ESM 是最好的模块格式，这要归功于其简单的语法、异步特性和 tree-shakeability。</li>
<li>UMD 无处不在，通常用作 ESM 不起作用时的后备方案。</li>
<li>CJS 是同步的，适合后端。</li>
<li>AMD 是异步的，适合前端。<br>感谢阅读，开发者！以后打算把每个模块都写的很深入，尤其是 ESM，因为里面有很多牛逼。敬请关注！<br>如果您发现任何错误，请告诉我。</li>
</ul>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
  </entry>
  <entry>
    <title>【译】优化长任务 Optimize long tasks</title>
    <url>/2022/10/11/%E3%80%90%E8%AF%91%E3%80%91%E4%BC%98%E5%8C%96%E9%95%BF%E4%BB%BB%E5%8A%A1-Optimize-long-tasks/</url>
    <content><![CDATA[<p>原文：<a href="https://web.dev/optimize-long-tasks/">https://web.dev/optimize-long-tasks/</a></p>
<blockquote>
<p>你曾被告诉过，不要阻塞主线程并且分解你的长任务，但是有想过这样做的意义吗？</p>
</blockquote>
<p>如果你读了很多关于网站性能的资料, 保持 JavasScript 应用程序快速运行的建议往往涉及以下的建议：</p>
<ul>
<li>不要阻塞主线程</li>
<li>分解你的长任务</li>
</ul>
<p>那这些意味着什么？减少 JavaScript 是好的，但这是否自动等同在整个页面生命周期中更快速的用户界面？也许是，也许不是.</p>
<span id="more"></span>

<h2 id="一个-task-是什么样的？"><a href="#一个-task-是什么样的？" class="headerlink" title="一个 task 是什么样的？"></a>一个 task 是什么样的？</h2><p>一个 task 是浏览器所做的任何离散的工作，task 包括解析 HTML 和 CSS, 运行 JavaScript 代码, 以及一些你不能直接控制的事情。对于所有的这些，你所编写的并且部署到服务器的 JavaScript 是主要的任务来源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.23.12.png" alt="img_1"></p>
<p>Tasks 以多种方式影响性能。例如，当浏览器在启动时下载 js 文件时，浏览器将任务进行排队并且编译 js 以让其能被执行。然后在页面的生命周期中，（例如通过事件处理程序驱动交互、JavaScript 驱动的动画和后台活动（例如分析收集））启动任务。所有的这些东西，除了 web worker 和类似的 API 都发生在主线程上。</p>
<h2 id="主线程是什么-？"><a href="#主线程是什么-？" class="headerlink" title="主线程是什么 ？"></a>主线程是什么 ？</h2><p>主线程是大多数任务在浏览器中运行的地方。它被称为主线程的原因是：它是您编写的几乎所有 JavaScript 都在这个线程中工作。</p>
<p>主线程一次只能处理一个任务。当任务超出某个确定的点（准确来说是 50ms ）时,它们被归类为长任务。如果用户在长时间的任务运行时尝试与页面交互 — 或者如果需要进行重要的渲染更新 — 浏览器将延迟处理该工作。这会导致交互或渲染延迟。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/2022-10-11%2019.42.24.png" alt="img_2"></p>
<p><em style="font-size:12px">Chrome 浏览器的性能分析器中描述的长任务。长任务的角落里有一个红色的三角形，任务的阻塞部分用对角线的红色条纹填充</em></p>
<p>你需要分解任务。这意味着将一个长任务划分为较小的任务，这些任务单独运行所需的时间更少。</p>
<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/8Bhl9Ilki4tM0aC1nfn8.png?auto=format&w=1600" alt="img_3"></p>
<p><em style="font-size:12px">单个长任务与同一任务分解为五个较短任务的可视化</em></p>
<p>这很重要，因为当任务被分解时，浏览器有更多机会响应更高优先级的工作——包括用户交互。</p>
<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0yV0ynwW7FujIwvCbCxQ.png?auto=format&w=1600" alt="img_3"></p>
<p><em style="font-size:12px">当任务太长，浏览器不能对互动做出足够快的反应时，与将较长的任务分解成较小的任务时相比，互动会发生什么样的情况，这是一个可视化的结果</em></p>
<p>如上图的上半部分所述，由用户交互排队的事件处理程序必须等待一个长任务才能运行。这延迟了交互的发生。在下半部分，事件处理程序有机会更快地运行。因为事件处理程序有机会在较小的任务之间运行。它运行得比它必须等待一个很长的任务完成要快。在上半部分中，用户可能已经感受到了延迟，在下半部分，交互可能是即时的。</p>
<p>然而，问题在于 “分解你的长任务” 和 “不要阻塞主线程”的建议不够具体,除非你已经知道如何做这些事情，这就是本指南将要解释的内容。</p>
<h2 id="任务管理策略"><a href="#任务管理策略" class="headerlink" title="任务管理策略"></a>任务管理策略</h2><p>在软件架构中，一个常见建议是将您的工作分解更小的功能。这为您提供了更好的代码可读性和项目可维护性的好处。这使得测试更容易编写。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  validateForm();</span><br><span class="line">  showSpinner();</span><br><span class="line">  saveToDatabase();</span><br><span class="line">  updateUI();</span><br><span class="line">  sendAnalytics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，这里的 saveSettings 函数，在它调用时，它调用了其他五个函数。从概念上讲，这是很好的架构，如果你需要调试这些函数中的一个，你可以便利项目树以弄清每个函数的作用。</p>
<p>然而，问题在于 JavaScript 不会将这些函数中的每一个作为单独的任务运行，因为它们是在 savaSettings 函数中执行的。<strong>这意味着所有五个功能都作为单独任务运行。</strong></p>
<blockquote>
<p>JavaScript 以这种方式工作是因为它使用任务执行的运行到完成模型。这意味着每个任务将一直运行到完成，无论它阻塞主线程多长时间。</p>
</blockquote>
<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/0c61l5DCix9y0GBa3pFj.png?auto=format&w=1600" alt="img_4"></p>
<p><em style="font-size:12px">调用五个函数的单个函数 saveSettings()。这项工作是作为一项长期的整体任务的一部分运行的</em></p>
<p>在最好的情况下，即使只是这些功能中的一个，也可以为任务的总长度贡献 50 毫秒或更多。在最坏的情况下，更多的这些任务可以运行相当长的时间–特别是在资源有限的设备上。下面是一套策略，你可以用来分解和优先处理任务。</p>
<h2 id="手动延迟代码执行"><a href="#手动延迟代码执行" class="headerlink" title="手动延迟代码执行"></a>手动延迟代码执行</h2><p>开发人员使用的一种将任务分解成小任务的方法涉及到 setTimeout(). 使用这种技术，你把函数传给 setTimeout 这将回调的执行推迟到一个单独的任务中，即时你指定的时间为 0。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 完成用户可见的关键工作:</span></span><br><span class="line">  validateForm();</span><br><span class="line">  showSpinner();</span><br><span class="line">  updateUI();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将用户不可见的工作推迟到单独的任务:</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    saveToDatabase();</span><br><span class="line">    sendAnalytics();</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您有一系列需要按顺序运行的函数，这很有效，但您的代码可能并不总是以这种方式组织。例如，您可能有大量数据需要循环处理，如果您有数百万个项目，该任务可能需要很长时间。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> largeDataArray) &#123;</span><br><span class="line">    <span class="comment">// Process the individual item here.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 setTimeout 是存在问题的, 因为它的人机工程学（这是什么意思 🤔，原文：ergonomics）使其难以实现，并且整个数据数组可能需要很长时间处理，即使每个项目都可以非常快速地处理。这一切加起来，setTimeout 不是合适的工具，至少在这样使用时不是。</p>
<p>除了 setTimeout 之外，还有一些其他 API 允许您将代码执行推迟到后续任务。 一种方法是使用 postMessage 来加快超时。您也可以使用 requestIdleCallback() 来分解工作。 但是要注意 – requestIdleCallback() 以尽可能低的优先级安排任务，而且只在浏览器空闲时间内进行。当主线程拥挤时,用 requestIdleCallback() 安排的任务可能永远无法运行。</p>
<h2 id="使用-async-await-yield-points"><a href="#使用-async-await-yield-points" class="headerlink" title="使用 async/await yield points"></a>使用 async/await yield points</h2><p>在本指南的其余部分，你会看到一个短语是 “yield to the main thread”，但是，这意味着什么？为什么你要这么做？你什么时候该这样做？</p>
<blockquote>
<p>当你 yield to the main thread，你会给它一个机会来处理比当前排队的任务更重要的任务。理想情况下（ideally），当你有一些关键的面向用户的工作，需要比 yield 更早地执行时，你应该 yield main thread，yield main thread 可以为关键工作创造机会，使其更快地运行。</p>
</blockquote>
<p>当任务被分解时，其他任务可以通过浏览器内部优先级方案更好地进行优先级排序。yield main thread 的方法涉及到使用一个 Promise 的组合，该组合与对 setTimeout() 进行的调用进行解析。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yieldToMain</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然这个代码实例返回了一个在调用 setTimeout 后解析的 Promise, 但负责在新任务中运行奇遇代码的并不是这个 Promise，而是 setTimeout 调用。Promise 回调作为微任务而不是任务运行，因此不会 yield main thread</p>
</blockquote>
<p>在 saveSettings() 函数中，如果在每次函数调用后 await yieldToMain() 函数，则可以在每次工作后 yield to the main</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create an array of functions to run:</span></span><br><span class="line">  <span class="keyword">const</span> tasks = [</span><br><span class="line">    validateForm,</span><br><span class="line">    showSpinner,</span><br><span class="line">    saveToDatabase,</span><br><span class="line">    updateUI,</span><br><span class="line">    sendAnalytics,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop over the tasks:</span></span><br><span class="line">  <span class="keyword">while</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Shift the first task off the tasks array:</span></span><br><span class="line">    <span class="keyword">const</span> task = tasks.shift();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the task:</span></span><br><span class="line">    task();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Yield to the main thread:</span></span><br><span class="line">    <span class="keyword">await</span> yieldToMain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你不必在每次函数调用后都 yield。例如，如果你运行的两个函数会导致用户界面的关键性更新，你可能不想在它们之间 yield。如果可以的话，让这些 tast 先运行，然后考虑在那些不那么关键的或用户看不到的后台工作的函数之间进行 yield。</p>
</blockquote>
<p>结果是曾经单一的任务现在被分解为单独的任务</p>
<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/wg0FW6S29CzOCbbwk9kK.png?auto=format&w=1600" alt="img_5"></p>
<p><em style="font-size:12px">saveSettings() 函数现在将其子函数作为单独的任务执行。</em></p>
<p>使用基于 Promise 的方法来产生而不是手动使用 setTimeout() 的好处是更好的人体工程学。屈服点成为声明性的，因此更容易编写、阅读和理解。</p>
<h2 id="仅在必要时-yield"><a href="#仅在必要时-yield" class="headerlink" title="仅在必要时 yield"></a>仅在必要时 yield</h2><p>如果您有一堆任务，但您只想在用户尝试与页面交互时让步怎么办？这就是 isInputPending() 的用途。</p>
<p>isInputPending() 是一个您可以随时运行以确定用户是否正在尝试与页面元素交互的函数：对 isInputPending() 的调用将返回 true。否则返回 false。</p>
<p>假设您可有一个需要运行的任务队列，但您不想妨碍任何输入。这段代码 — 它同时使用了 isInputPending() 函数 — 确保在用户尝试与页面交互时输入不会被延迟。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A task queue of functions</span></span><br><span class="line">  <span class="keyword">const</span> tasks = [</span><br><span class="line">    validateForm,</span><br><span class="line">    showSpinner,</span><br><span class="line">    saveToDatabase,</span><br><span class="line">    updateUI,</span><br><span class="line">    sendAnalytics,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Yield to a pending user input:</span></span><br><span class="line">    <span class="keyword">if</span> (navigator.scheduling.isInputPending()) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s a pending user input. Yield here:</span></span><br><span class="line">      <span class="keyword">await</span> yieldToMain();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Shift the the task out of the queue:</span></span><br><span class="line">      <span class="keyword">const</span> task = tasks.shift();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Run the task:</span></span><br><span class="line">      task();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 saveSettings() 运行时，它将遍历队列中的任务。如果 isInputPending() 在循环期间返回 true，则 saveSettings() 将调用 yieldToMain() 以便处理用户输入。否则，它将把下一个任务移出队列的前面并继续运行它。它将执行此操作，直到没有其他任务为止。</p>
<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/snMl3kRlWyJjdbL0qsqM.png?auto=format&w=1600" alt="img_5"></p>
<p><em style="font-size:12px">saveSettings()运行一个有五个任务的任务队列，但在第二个工作项运行时，用户已经点击打开了一个菜单。 isInputPending()让位于主线程来处理这个交互，并恢复运行其余的任务。</em></p>
<blockquote>
<p>isInputPending()不一定在用户输入后立即返回 true。这是因为操作系统需要时间来告诉浏览器发生了交互。这意味着其他代码可能已经开始执行了（正如你在上面的截图中看到的 saveToDatabase()函数）。即使你使用 isInputPending()，你仍然要限制每个函数的工作量，这是至关重要的。</p>
</blockquote>
<p>将 isInputPending() 与让步机制结合使用是让浏览器停止其正在处理的任何任务以响应关键的面向用户的交互的好方法。这可以帮助提高您的页面在许多任务正在进行时在许多情况下响应用户的能力。</p>
<p>另一种使用 isInputPending()的方法–特别是如果你担心为不支持它的浏览器提供退路–是使用基于时间的方法与 可选链操作符 （?.）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A task queue of functions</span></span><br><span class="line">  <span class="keyword">const</span> tasks = [</span><br><span class="line">    validateForm,</span><br><span class="line">    showSpinner,</span><br><span class="line">    saveToDatabase,</span><br><span class="line">    updateUI,</span><br><span class="line">    sendAnalytics,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> deadline = performance.now() + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Optional chaining operator used here helps to avoid</span></span><br><span class="line">    <span class="comment">// errors in browsers that don&#x27;t support `isInputPending`:</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      navigator.scheduling?.isInputPending() ||</span><br><span class="line">      performance.now() &gt;= deadline</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s a pending user input, or the</span></span><br><span class="line">      <span class="comment">// deadline has been reached. Yield here:</span></span><br><span class="line">      <span class="keyword">await</span> yieldToMain();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Extend the deadline:</span></span><br><span class="line">      deadline += <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Stop the execution of the current loop and</span></span><br><span class="line">      <span class="comment">// move onto the next iteration:</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shift the the task out of the queue:</span></span><br><span class="line">    <span class="keyword">const</span> task = tasks.shift();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the task:</span></span><br><span class="line">    task();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方法，你可以为不支持 isInputPending()的浏览器提供一个后备方案，即使用（并调整）一个截止日期，以便在必要时将工作分开，无论是通过屈服于用户输入，还是在某个时间点之前。</p>
<h2 id="当前-api-的差异"><a href="#当前-api-的差异" class="headerlink" title="当前 api 的差异"></a>当前 api 的差异</h2><p>到目前为止提到的 API 可以帮助你分解任务，但它们有一个显著的缺点：当你通过推迟代码在后续任务中运行而屈服于主线程时，该代码会被添加到任务队列的最末端。</p>
<p>如果你控制了你页面上的所有代码，就有可能创建你自己的 scheduler （参考 react 吗，😯），并能对任务进行优先排序，但第三方脚本不会使用你的调度器。实际上，在这样的环境中，你并不能真正地对工作进行优先排序。你只能把它分成几块，或者明确地屈从于用户的互动。</p>
<p>幸运的是，目前有一个专门的调度器 API 正在开发中，可以解决这些问题。</p>
<h2 id="一个专门的调度程序-API"><a href="#一个专门的调度程序-API" class="headerlink" title="一个专门的调度程序 API"></a>一个专门的调度程序 API</h2><p>调度器 API 目前提供了 postTask()函数，在撰写本文时，该函数在 Chromium 浏览器和 Firefox 的一个标志后面可用。 postTask()允许对任务进行更精细的调度，是帮助浏览器确定工作优先级的一种方法，这样低优先级的任务就会让位于主线程。 postTask()使用 Promise，并接受一个优先级设置。</p>
<p>postTask() API 具有三个可以使用的 priorities</p>
<ul>
<li>‘background’ : 最低优先级任务。</li>
<li>‘user-visible’ : 中等优先级任务，“用户可见”，如果没有设置优先级，这是默认设置。</li>
<li>‘user-blocking’: 用于需要高优先级运行的关键任务。</li>
</ul>
<p>以下面的代码为例，postTask()API 被用来以尽可能高的优先级运行三个任务，并以尽可能低的优先级运行其余两个任务。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Validate the form at high priority</span></span><br><span class="line">  scheduler.postTask(validateForm, &#123; <span class="attr">priority</span>: <span class="string">&quot;user-blocking&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Show the spinner at high priority:</span></span><br><span class="line">  scheduler.postTask(showSpinner, &#123; <span class="attr">priority</span>: <span class="string">&quot;user-blocking&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the database in the background:</span></span><br><span class="line">  scheduler.postTask(saveToDatabase, &#123; <span class="attr">priority</span>: <span class="string">&quot;background&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the user interface at high priority:</span></span><br><span class="line">  scheduler.postTask(updateUI, &#123; <span class="attr">priority</span>: <span class="string">&quot;user-blocking&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send analytics data in the background:</span></span><br><span class="line">  scheduler.postTask(sendAnalytics, &#123; <span class="attr">priority</span>: <span class="string">&quot;background&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，任务的优先级以浏览器优先级任务（例如用户交互）可以正常工作的方式安排。</p>
<div style="color:red">子任务执行顺序差异</div>

<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/ttvI1HqusI02CAdqhjWP.png?auto=format&w=1600" alt="img_6"></p>
<p><em style="font-size:12px">当 saveSettings()运行时，该函数使用 postTask()对各个函数进行调度。面向用户的关键工作被安排在高优先级，而用户不知道的工作被安排在后台运行。这使得用户交互的执行速度更快，因为工作被分割开来并被适当地安排了优先次序。</em></p>
<p>这是一个如何使用 postTask() 的简单示例。可以实例化不同的 TaskController 对象，这些对象可以在任务之间共享优先级，包括根据需要更改不同 TaskController 实例的优先级的能力。</p>
<blockquote>
<p>并非所有浏览器都支持 postTask()。您可以使用特征检测来查看它是否可用，或者考虑使用 polyfill</p>
</blockquote>
<h2 id="内置的-yield"><a href="#内置的-yield" class="headerlink" title="内置的 yield"></a>内置的 yield</h2><p>调度器 API 的一个拟议的部分，目前没有在任何浏览器中实现，就是一个内置的 yield 机制。它的使用类似于本文前面演示的 yieldToMain() 函数。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">saveSettings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create an array of functions to run:</span></span><br><span class="line">  <span class="keyword">const</span> tasks = [</span><br><span class="line">    validateForm,</span><br><span class="line">    showSpinner,</span><br><span class="line">    saveToDatabase,</span><br><span class="line">    updateUI,</span><br><span class="line">    sendAnalytics,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop over the tasks:</span></span><br><span class="line">  <span class="keyword">while</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Shift the first task off the tasks array:</span></span><br><span class="line">    <span class="keyword">const</span> task = tasks.shift();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the task:</span></span><br><span class="line">    task();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Yield to the main thread with the scheduler</span></span><br><span class="line">    <span class="comment">// API&#x27;s own yielding mechanism:</span></span><br><span class="line">    <span class="keyword">await</span> scheduler.yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您会注意到，上面的代码非常熟悉，但是您没有使用 yieldToMain()，而是调用并等待 scheduler.yield()。</p>
<p><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/fyuvJqAV0mLxfZDM9tAm.png?auto=format&w=1294" alt="img_7"></p>
<p><em style="font-size:12px">一个没有 yield、yield、yield 和 continuation 的任务执行的可视化图。当使用 scheduler.yield()时，任务的执行甚至在屈服点之后还能继续执行。</em></p>
<p>scheduler.yield() 的好处是 continuation，这意味着如果你在一组任务中间 yield，其他的计划任务会在 yield 点之后以同样的顺序继续执行。这可以避免第三方脚本中的代码篡夺您的代码执行顺序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>管理任务是具有挑战性的，但这样做有助于你的页面对用户的互动作出更快速的反应。在管理和确定任务的优先次序方面，没有单一的建议。相反，它是一些不同的技术。重申一下，这些是你在管理任务时要考虑的主要事项。</p>
<ul>
<li><p>让给主线程以完成关键的、面向用户的任务。</p>
</li>
<li><p>当用户尝试与页面交互时，使用 isInputPending() 让步给主线程。</p>
</li>
<li><p>使用 postTask() 对任务进行优先级排序。</p>
</li>
<li><p>最后，在你的函数中做尽可能少的工作。</p>
</li>
</ul>
<p>有了这些工具中的一个或多个，你应该能够在你的应用程序中构造工作，使其优先考虑用户的需求，同时确保不太关键的工作仍然能够完成。这将创造一个更好的用户体验，它的响应速度更快，使用起来更愉快。</p>
<p>Special thanks to Philip Walton for his technical vetting of this article.</p>
<p>Hero image sourced from Unsplash, courtesy of Amirali Mirhashemian.</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
  </entry>
  <entry>
    <title>一次base64指令的powershell</title>
    <url>/2021/11/18/%E4%B8%80%E6%AC%A1base64%E6%8C%87%E4%BB%A4%E7%9A%84powershell/</url>
    <content><![CDATA[<p><strong>事情发生是在一个月黑风高的晚上。。。。不好意思搞错了 😬。</strong><br><strong>事情是这样的，今天在使用 webpack-dev-middleware 构建开发环境的时候，想要使用 node 启动浏览器并自动打开相关的本地网址。于是就发生了下面的一幕。</strong><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/u=1178727920,923148390&fm=26&fmt=auto.webp"></p>
<span id="more"></span>

<h1 id="关于-open-这个-node-module"><a href="#关于-open-这个-node-module" class="headerlink" title="关于 open 这个 node_module"></a>关于 open 这个 node_module</h1><p><strong>这是一个 node 的依赖包，使用其提供的相关 api 可以用浏览器打开具体的网址。具体用法如下</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> open = <span class="built_in">require</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Opens the image in the default image viewer and waits for the opened app to quit.</span></span><br><span class="line"><span class="keyword">await</span> open(<span class="string">&quot;unicorn.png&quot;</span>, &#123; <span class="attr">wait</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;The image viewer app quit&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Opens the URL in the default browser.</span></span><br><span class="line"><span class="keyword">await</span> open(<span class="string">&quot;https://sindresorhus.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Opens the URL in a specified browser.</span></span><br><span class="line"><span class="keyword">await</span> open(<span class="string">&quot;https://sindresorhus.com&quot;</span>, &#123; <span class="attr">app</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;firefox&quot;</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify app arguments.</span></span><br><span class="line"><span class="keyword">await</span> open(<span class="string">&quot;https://sindresorhus.com&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">app</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;google chrome&quot;</span>, <span class="attr">arguments</span>: [<span class="string">&quot;--incognito&quot;</span>] &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open an app</span></span><br><span class="line"><span class="keyword">await</span> open.openApp(<span class="string">&quot;xcode&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open an app with arguments</span></span><br><span class="line"><span class="keyword">await</span> open.openApp(open.apps.chrome, &#123; <span class="attr">arguments</span>: [<span class="string">&quot;--incognito&quot;</span>] &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>为了一探究竟，它是怎样打开浏览器的，所以我就开始了查看源代码之旅。然后就出现了 powershell 执行 base64 编码的命令这个有趣的事情了。</strong></p>
<h1 id="在-powershell-中使用-base64-编码的指令"><a href="#在-powershell-中使用-base64-编码的指令" class="headerlink" title="在 powershell 中使用 base64 编码的指令"></a>在 powershell 中使用 base64 编码的指令</h1><p><strong>在 open 的源码中，有个 encodeArguments 的数组，大概是这个样子[‘start’, ‘http://….’ ]，其打开浏览的的主要命令就是</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span> (application) &lt;网址&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而它在传递 powershell 命令时有这样一行代码代码,通过注释我们可以明白这是一个使用 base64 编码的 powershell 命令。于是乎我就开始了我的实验性探究了了</strong>🥳。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using Base64-encoded command, accepted by PowerShell, to allow special characters.</span></span><br><span class="line">target = Buffer.from(encodedArguments.join(<span class="string">&quot; &quot;</span>), <span class="string">&quot;utf16le&quot;</span>).to;</span><br></pre></td></tr></table></figure>

<p><strong>果不其然，在微软的文档里确实查到了 😃,不过需要注意的是需要 utf-16le 的编码。</strong><br><strong><em>铛铛铛铛！！</em></strong><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/encodedCommand.png"></p>
<h1 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h1><p><strong>下面我就以 node 打开浏览器为例子，进行 base64 编码命令的测试。</strong><br><strong>node 打开浏览器的代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取base64编码的指令</span></span><br><span class="line"><span class="keyword">let</span> command = Buffer.from(&lt;目标指令&gt; <span class="string">&#x27;utf16le&#x27;</span>).toString(<span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subprocess = cp.spawn(<span class="string">`<span class="subst">$&#123;process.env.SYSTEMROOT&#125;</span>\\System32\\WindowsPowerShell\\v1.0\\powershell`</span>, [</span><br><span class="line">    <span class="string">&quot;-EncodedCommand&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;cwB0AGEAcgB0ACAAaAB0AHQAcAA6AC8ALwBiAGEAaQBkAHUALgBjAG8AbQA=&#x27;</span></span><br><span class="line">    <span class="comment">// &#x27;start http://baidu.com&#x27; 上面是这一行命令的编码</span></span><br><span class="line">], &#123;</span><br><span class="line">    <span class="attr">windowsVerbatimArguments</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>下面是效果图</strong><br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/20211191146.gif"><br><strong>奇怪的知识又增加了 🌟</strong></p>
]]></content>
      <categories>
        <category>一些趣事的🌟</category>
      </categories>
  </entry>
  <entry>
    <title>对javaScript事件冒泡与事件捕获的再学习</title>
    <url>/2021/10/21/%E5%AF%B9javaScript%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%86%8D%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="对-javaScript-事件冒泡与事件捕获的再学习"><a href="#对-javaScript-事件冒泡与事件捕获的再学习" class="headerlink" title="对 javaScript 事件冒泡与事件捕获的再学习"></a>对 javaScript 事件冒泡与事件捕获的再学习</h1><h2 id="DOM-树结构"><a href="#DOM-树结构" class="headerlink" title="DOM 树结构"></a>DOM 树结构</h2><p>我们在浏览器上会看见一颗 dom 树，这样的树状结构决定了事件的冒泡与捕获。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello Github Action<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out-A&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out-B&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out-C&quot;</span>&gt;</span>hello, I&#x27;am C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="事件捕获与事件冒泡流程"><a href="#事件捕获与事件冒泡流程" class="headerlink" title="事件捕获与事件冒泡流程"></a>事件捕获与事件冒泡流程</h2><p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/bubbling-capturing.png" alt="事件冒泡与捕获"></p>
<h4 id="首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了-onclick-点击事件。"><a href="#首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了-onclick-点击事件。" class="headerlink" title="首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。"></a>首先，事件冒泡捕获建立在父子节点绑定了相同类型的事件。比如：都绑定了 onclick 点击事件。</h4><h5 id="1-当我们点击最里面的-div-标签时，"><a href="#1-当我们点击最里面的-div-标签时，" class="headerlink" title="1.当我们点击最里面的 div 标签时，"></a>1.当我们点击最里面的 div 标签时，</h5><p>会先沿着 window-&gt;document-&gt;parentNodes-&gt;EventTarget 路线进行事件捕获，在捕获时会进行对每个 html 对象询问是否绑定了该事件的 listener,如果有则执行它。而事件冒泡则与上面路线相反，但询问行为相同。 ######一般我们给 html 元素添加事件时，会使用 HTMLElement.addEventListener(type, listener, useCapture)给其添加事件处理函数，这里的参数详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener</a>。需要特别说明的是第三个参数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useCapture:boolean</span><br><span class="line"></span><br><span class="line">OR</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">capture</span>:boolean,</span><br><span class="line">	<span class="attr">once</span>:boolean,</span><br><span class="line">	<span class="attr">passive</span>:boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 useCapture 以及 capture 就是设置该事件 listener 是否会在捕获阶段触发，默认为 false。</p>
<h5 id="2-我们以如下例子为例："><a href="#2-我们以如下例子为例：" class="headerlink" title="2.我们以如下例子为例："></a>2.我们以如下例子为例：</h5><h6 id="这里绘制一个三层嵌套的-div，并给它们添加点击事件。"><a href="#这里绘制一个三层嵌套的-div，并给它们添加点击事件。" class="headerlink" title="这里绘制一个三层嵌套的 div，并给它们添加点击事件。"></a>这里绘制一个三层嵌套的 div，并给它们添加点击事件。</h6><p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/div.png" alt="div"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> diva = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.out-A&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> divb = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.out-B&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> divc = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.out-C&quot;</span>);</span><br><span class="line">diva.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">divb.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">divc.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后我们点击 C,出现如下结果：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/output.png" alt="output"><br>可以看见点击 C 后出现了 C-&gt;B-&gt;A 的输出顺序，为什么会出现 CBA 的输出顺序呢，因为我们在添加事件时，使用了 capture 的默认值 false,即在事件捕获阶段不会触发事件处理函数。</p>
<h6 id="将-capture-的值设置为-true"><a href="#将-capture-的值设置为-true" class="headerlink" title="将 capture 的值设置为 true"></a>将 capture 的值设置为 true</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">diva.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">divb.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">divc.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202333.png"><br>这里可以看见输出结果变为了 ABC，这就是从父节点到 EventTarget 节点的捕获。同时我们也可以发现，如果只给节点添加一个事件处理，这样只会进行捕获或者冒泡。所以下面我们给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.</p>
<h6 id="给一个节点添加两个-click-事件，并且把其中一个的-capture-设置为-true-另一个为-false"><a href="#给一个节点添加两个-click-事件，并且把其中一个的-capture-设置为-true-另一个为-false" class="headerlink" title="给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false."></a>给一个节点添加两个 click 事件，并且把其中一个的 capture 设置为 true,另一个为 false.</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">diva.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;A:capture=true&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">divb.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;B:capture=true&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">divc.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;C:capture=true&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//   默认false</span></span><br><span class="line">diva.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A:capture=false&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">divb.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;B:capture=false&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">divc.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;C:capture=false&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们再次点击 C,输出结果如下：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202341.png"><br>看看，这里的结果表示同时出现了事件捕获与事件冒泡。<br><font color="green">到了这里，想必大家对于事件的捕获与冒泡流程有了一定的了解吧。</font>下面我们再来聊聊 Event.stopPropagation()与 Event.preventDefault()</p>
<h2 id="Event-stopPropagation-与-Event-preventDefault"><a href="#Event-stopPropagation-与-Event-preventDefault" class="headerlink" title="Event.stopPropagation()与 Event.preventDefault()"></a>Event.stopPropagation()与 Event.preventDefault()</h2><h4 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h4><h6 id="同样是上面的例子。我们给-A-capture-true（捕获阶段）的那个事件处理加上-stopPropagation-看看下面的输出："><a href="#同样是上面的例子。我们给-A-capture-true（捕获阶段）的那个事件处理加上-stopPropagation-看看下面的输出：" class="headerlink" title="同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出："></a>同样是上面的例子。我们给 A:capture=true（捕获阶段）的那个事件处理加上 stopPropagation().看看下面的输出：</h6><p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202353.png"></p>
<h6 id="只输出了捕获阶段的-A-处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加-stopPropagation-到-C-的冒泡处理函数里，即在-C-capture-false-里面。下面是输出结果："><a href="#只输出了捕获阶段的-A-处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加-stopPropagation-到-C-的冒泡处理函数里，即在-C-capture-false-里面。下面是输出结果：" class="headerlink" title="只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果："></a>只输出了捕获阶段的 A 处理函数，后面子节点的事件函数都没有触发。那我们在冒泡阶段添加这一行又会发生什么呢？下面将添加 stopPropagation 到 C 的冒泡处理函数里，即在 C:capture=false 里面。下面是输出结果：</h6><p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110210005.png"></p>
<h6 id="同样的，事件捕获与事件冒泡流程被截断了。"><a href="#同样的，事件捕获与事件冒泡流程被截断了。" class="headerlink" title="同样的，事件捕获与事件冒泡流程被截断了。"></a>同样的，事件捕获与事件冒泡流程被截断了。</h6><h5 id="看到这里，想必明白了吧，stopPropagation-就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。"><a href="#看到这里，想必明白了吧，stopPropagation-就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。" class="headerlink" title="看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。"></a>看到这里，想必明白了吧，stopPropagation 就好比一把‘刀’，你把它添加到什么阶段，那么这个阶段后面的就会被截去。</h5><ul>
<li>而整个流程是：</li>
</ul>
<h6 id="事件捕获到事件冒泡"><a href="#事件捕获到事件冒泡" class="headerlink" title="事件捕获到事件冒泡"></a>事件捕获到事件冒泡</h6><h6 id="父节点到-EventTarget-节点再到父节点"><a href="#父节点到-EventTarget-节点再到父节点" class="headerlink" title="父节点到 EventTarget 节点再到父节点"></a>父节点到 EventTarget 节点再到父节点</h6><h4 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h4><p>那把上面的改成 preventDefault 又会是怎样的结果呢？那就试试看咯：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202110202356.png"><br>没有影响！！！preventDefault 在没有对事件捕获产生影响，那冒泡阶段呢？也没有影响。所以 preventDefault 只是单纯的阻止了 html 元素的默认事件，比如一个 a 标签能够跳转链接，加上 preventDefault 后就不能跳转了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h6 id="我们可以看到，可以使用-stopPropagation-阻止事件的冒泡。通常我们在给-html-元素添加事件时，一般都会使用-capture-的默认值：false-这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在-capture-为-false-的情况下，给-EventTarget-元素添加-stopPropagation-就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发-EventTarget-的事件处理函数，从而减少不必要的副作用。"><a href="#我们可以看到，可以使用-stopPropagation-阻止事件的冒泡。通常我们在给-html-元素添加事件时，一般都会使用-capture-的默认值：false-这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在-capture-为-false-的情况下，给-EventTarget-元素添加-stopPropagation-就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发-EventTarget-的事件处理函数，从而减少不必要的副作用。" class="headerlink" title="我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。"></a>我们可以看到，可以使用 stopPropagation 阻止事件的冒泡。通常我们在给 html 元素添加事件时，一般都会使用 capture 的默认值：false,这样就只会在冒泡阶段触发事件处理函数，这样通常我们只需要在 capture 为 false 的情况下，给 EventTarget 元素添加 stopPropagation 就行了，这样，无论在捕获阶段还是在冒泡阶段都只会触发 EventTarget 的事件处理函数，从而减少不必要的副作用。</h6><p>参考：<a href="https://web.dev/eventing-deepdive/">JavaScript eventing deep dive</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈cookie、session与token(jwt)</title>
    <url>/2021/12/07/%E8%B0%88%E8%B0%88cookie%E3%80%81session%E4%B8%8Etoken-jwt/</url>
    <content><![CDATA[<p><strong>首先呢，网上关于它们的文章已经很多了，在这里我就只是来记录以下我的理解，其实也是看其他网上内容的一个总结吧。</strong></p>
<blockquote>
<p><strong>前言：由于 HTTP 协议无状态的缺陷。WEB 的设计者们提出了 Cookie 和 Session 两种解决机制。而 token,通常是 jwt(json web token)作为一种用户身份令牌，也常常用于记录 http 的状态存储，通常是在用户登录后，伴随每一次请求发送给给后端。下面就来聊聊它们。</strong></p>
</blockquote>
 <span id="more"></span>

<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Cookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。<br>包括：</p>
<ol>
<li>Name/Value：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌。</li>
<li>Expires 属性：设置 Cookie 的生存期。有两种存储类型的 Cookie：会话性与持久性。Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</li>
<li>Domain 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域（域名前缀不同）可以设置或获取其父域的 Cookie。</li>
<li>Secure 属性：指定是否使用 HTTPS 安全协议发送 Cookie。</li>
<li>Path 属性：定义了 Web 站点上可以访问该 Cookie 的目录。</li>
<li>HTTPOnly 属性 ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头。<br><strong>好了，以上内容是来自百度百科。简单地做个总结：cookie 是一种存储在客户端的小型文本数据，里面的类容有键值对、生存周期、访问域、是否使用 http,web 站点可访问 cookie 的目录以及是否允许客户端读取 cookie。</strong></li>
</ol>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p><strong>XSRF/CSRF（跨站请求伪造）</strong>：利用的是 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器,却不能保证请求本身是用户自愿发出的。这里有一些如 Firefox、Opera 等浏览器使用单进程机制，<strong>多个窗口或标签使用同一个进程，共享 Cookie 等会话数据</strong>。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用“CTRL+N” 或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行 IE 可执行程序打开窗口时，才会创建新的进程。<strong>Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。</strong>因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 CSRF 攻击篡夺用户的会话 Cookie 创造了条件。却不能保证请求本身是用户自愿发出的。其最典型的例子<strong>就是当 cookie 还没过期时，用户浏览的网站有与其没过期的网站的一些 api 请求，那么当用户浏览这个恶意网站时就可能会受到危害</strong>。<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202112161949.png"><br><strong>会话定置(Session Fixation)攻击</strong>是指，攻击者向受害者主机注入自己控制的认证 Cookie 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。注入 Cookie 的方法包括：使用跨站脚本或木马等恶意程序；或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过 HTTP 响应中的 Set-Cookie 头将攻击者拥有的该域 Cookie 发送给用户等。因为 sessionID 一般都会放在 cookie 中存储，所以会容易受到会话定制攻击。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>与 cookie 相比，session 就是存放在服务端了，它表示在客户端登录时，服务端会发放一个 sessionid 到客户端，它一般存在 cookie 中，所以客户端以后的请求就会在请求头的 cookies 字段中携带这个信息。这样服务端就可以通过这个数据判断客户端的登录状态。这就好比我们去点菜，点好了后商家给我们一个号码牌，等菜好了，就送往相应号码牌的位置。</p>
<h4 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h4><p>因为 session 是放在服务器上的，所以一般的安全性就考虑 sessionid 的伪造与截获。如果 sessionid 是放在 cookie 中的，那么 cookie 的时效就决定了 sessionid 即登录状态的时效。<br>需要注意的就是会话固定（session fixation)：意思是攻击者先自己获取一个 sessionid,然后假冒一个网站并将连接发给被攻击的人，当受害者登录后，攻击者就可以劫持受害人的会话。因为在攻击者登录获取 sessionid 后，网络服务器看到会话已经建立，无需创建新的会话。所以攻击者就成功地冒充了受害者，从而获取了受害者的信息。</p>
<h3 id="Token（JWT）"><a href="#Token（JWT）" class="headerlink" title="Token（JWT）"></a>Token（JWT）</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>JSON Web Token (JWT) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。由于此信息经过数字签名，因此可以验证和信任。 JWT 可以使用秘密（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。尽管 JWTs 可以被加密，以便在各方之间提供保密性，但我们将专注于签名的令牌。签名的令牌可以验证其中包含的索赔的完整性，而加密的令牌则对其他各方隐藏这些索赔。当令牌使用公钥/私钥对签名时，签名也证明了只有持有私钥的一方才是签名者。 - - - - <a href="https://jwt.io/introduction">https://jwt.io/introduction</a></p>
<h4 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h4><blockquote>
<p>形如：xxxxx.yyyyy.zzzzz</p>
</blockquote>
<ol>
<li>header：标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。<strong>然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第一部分。</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>payload：包含一些声明， 声明是关于实体（通常是用户）和附加数据的声明。共有三种类型的 claims：注册负载、公共负载和私人负载。</li>
</ol>
<ul>
<li>Registered claims（注册）: 通常有四个部分，iss(issuer)，exp (expiration time), sub (subject), aud (audience)。还有一些其他的，比如：nbf (Not Before)、iat (Issued At)、jti (JWT ID)。<br><strong>iss（issuer）</strong>：声明标识发行该证书的委托人。<br>**exp (expiration time)**：声明标识了过期时间或之后不得接受 JWT 进行处理<br>**sub (subject)**：JWT 的主题。 JWT 中的声明通常是声明，关于主题。主题值必须要么被限定为在发行人的上下文中是本地唯一的，或者是全球唯一的。<br>**aud (audience)**：声明标识了 JWT 的接收者。</li>
<li>Public claims（公共）：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在 <a href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registry</a> 中定义，或者定义为包含抗冲突命名空间的 URI。</li>
<li>Private claims（私有）：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明，这些声明既不是注册声明也不是公开声明。此声明的处理通常是<strong>特定于应用程序</strong>的。</li>
</ul>
<p><strong>然后，这个 JSON 被 Base64Url 编码以形成 JWT 的第二部分。</strong><br><strong>这里，header 与 payload 都是可以直接通过 base64url 解码获得其 json 数据的。</strong> 3. signature：签名，这是 jwt 最核心的部分，就是包含 base64 编码的 header,payload,以及 secret，最后再将整个使用加密算法进行加密。其中的 secret 就是服务端发放的私钥。</p>
<blockquote>
<p>形如：<br>HMACSHA256(<br>base64UrlEncode(header) + “.” +<br>base64UrlEncode(payload),<br>secret<br>)</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>每当用户想要访问受保护的路由或资源时，用户代理应发送 JWT，通常在使用 Bearer 模式的 Authorization 标头中。标题的内容应如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<p>如果令牌在 Authorization 标头中发送，则跨源资源共享 (CORS) 不会成为问题，因为它不使用 cookie（cookie 是不能跨域的）。这一点就非常适合单点登录。</p>
<h4 id="安全性-2"><a href="#安全性-2" class="headerlink" title="安全性"></a>安全性</h4><p>因为在 jwt 签发的时候，密钥是服务端生成的，所以来说是比较安全的，当 payload 的数据修改后，发送给服务端，服务端会采用相同的加密算法生成一个 token 副本与之前签发的进行对比，显然，修改后的数据再次加密后与之前的 token 对比肯定不同。<br>在 payload 中，因为是 base64url 编码的，所以很容易解码获取信息，因此不宜在里面放一些比较重要的信息。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>聊聊JavaScript事件循环</title>
    <url>/2022/01/12/%E8%81%8A%E8%81%8AJavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p><strong>事情还得从这么一道题开始：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTime&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>各位想想下面的输出顺序是什么吧？<br>我先说一下我的答案吧：</p>
<blockquote>
<p>end<br>p<br>setTime</p>
</blockquote>
<p>上面的输出是错误的 😥，我是怎么也不开心啊，于是我就开始翻遍各种资料，其中包括任务、微任务、JavaScript 事件循环、Promise 等等资料。下面就让我来细说吧。</p>
<span id="more"></span>

<p><strong>首先介绍几个重要的概念。</strong></p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="任务（宏任务）"><a href="#任务（宏任务）" class="headerlink" title="任务（宏任务）"></a>任务（宏任务）</h3><p>任务有以下三类：</p>
<ul>
<li>一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 &lt;script&gt; 元素中运行代码）。</li>
<li>触发了一个事件，将其<strong>回调函数</strong>添加到任务队列时。</li>
<li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的<strong>回调函数</strong>被添加到任务队列时。</li>
<li>setImmediate()回调（nodejs）</li>
<li>I/O</li>
<li>UI</li>
<li>postMessage</li>
<li>requestAnimationFrame</li>
</ul>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><ul>
<li>promise.then(callback)中的<strong>callback</strong>。</li>
<li>MutationObserver</li>
<li>process.nextTick(Node.js)</li>
</ul>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>函数的互相调用会让函数树形成一个调用栈，而函数的执行会按照这个栈来执行，即后进先执行。执行栈会占用 JavaScript 的 run time。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>JavaScript 在运行时，是运行在执行上下文中的，每一个上下文拥有自己的变量、对象，执行上下文有如下几类：</p>
<ul>
<li>全局上下文：在 JavaScript 开始执行时便创建，是最基础的上下文。</li>
<li>函数上下文（局部上下文）：在函数调用时会创建，一个函数的执行，伴随一个函数上下文的产生。</li>
<li>eval 上下文：使用 eval 函数所创建的上下文。</li>
</ul>
<h3 id="JavaScript-RunTime"><a href="#JavaScript-RunTime" class="headerlink" title="JavaScript RunTime"></a>JavaScript RunTime</h3><p>执行 js 代码时，运行时引擎拥有一系列的代理，每一个代理由一系列的执行上下文、执行栈、主线程、附加线程（worker）、任务队列、微任务队列。常见的 JavaScript run time 有 iframe、web worker、JavaScript 主线程。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。每一个 JavaScript run time 都会拥有自己的事件循环，RunTime 里面的代理由事件循环所驱动。<br><strong>事件循环分为三类：</strong></p>
<h4 id="window-event-loop"><a href="#window-event-loop" class="headerlink" title="window event loop"></a>window event loop</h4><p>驱动同源的窗口（Frame,Tab）的事件循环，来自相同 origin 的 window 可能共享同一个事件循环</p>
<h4 id="worker-event-loop"><a href="#worker-event-loop" class="headerlink" title="worker event loop"></a>worker event loop</h4><p>驱动 worker 执行（web workers、 shared workers、service workers）worker 拥有一个或多个与主程序不同的代理。</p>
<h4 id="worklet-event-loop"><a href="#worklet-event-loop" class="headerlink" title="worklet event loop"></a>worklet event loop</h4><p>驱动 worklet 代理的运行。worklet 的类型包括（Worklet、AudioWorklet、PaintWorklet）。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>一种异步 JavaScript 的解决方案，是对异步方法的返回值的一种描述，用于在将来某个时刻将异步结果返回给使用者，最重要的一点是通过 then 链式调用。</p>
<h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><p>在每一轮事件循环开始时，RunTime 会从任务队列里面取出任务来执行，如果任务里面又添加了新任务到队列里面，新任务不会再本轮事件循环里去执行。当一个任务执行完弹出任务队列时，并且执行栈位空时，这时会开始执行微任务队列，微任务不会像任务那样每次只执行一个，而是将微任务队列里的微任务执行完，即使是在执行微任务时有新的微任务加入到微任务队列，在下一个任务开始以及事件循环迭代结束之前依然会执行微任务。<br>OK，说到这儿，我们就可以来分析以下刚才的题了。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTime&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>最开始：</strong>将整体代码（一段新程序）加入任务队列。此时的 JavaScript RunTime 的情况如下图：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122218.png" alt="1"></p>
<p>此时任务队列里面仅有整体程序，而微任务队列里面什么也没有。整体程序将进入执行栈中执行。<br><strong>创建 promise 对象：</strong>在创建 promise 对象时，传入了可选参数即：</p>
<blockquote>
<p>(resolve,reject)=&gt;{<br>console.log(‘p’);<br>}</p>
</blockquote>
<p>而 Promise 构造器将会在返回新对象之前执行传入的函数参数。所以在执行栈中会执行 console.log(‘p’)，打印出 ‘p’。<br><strong>执行定时器：</strong>执行定时器，会在传入的延迟时间之后将回调函数加入队列，加入什么队列呢，这里加入的是任务队列，因为 settimeoout 的回调属于宏任务。之后，当前执行栈不为空，会继续执行。<br><strong>打印 end:<strong>在执行 console.log(‘end’)后，现在执行栈为空了，整体程序弹出任务队列。此时任务队列是</strong>不为空的</strong>（包含定时器的回调()=&gt;{console.log(‘setTime’)}）</p>
<p>此时的 JavaScript RunTime 的情况如下图：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122230.png" alt="2"><br>这时的任务队列包括定时器的回调，而微任务队列依然为空（这道题就没涉及到微任务。。。）。随后定时器回调将进入执行栈，打印出 setTime。所以最终的打印结果为：</p>
<blockquote>
<p>p<br>end<br>setTime</p>
</blockquote>
<p><strong>这里就注意 promise 的构建就行了，是立即执行，我错的是应为它会进入微任务队列。而 Promise 进入微任务的是 then 的回调函数。</strong></p>
<h2 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h2><p>上面的题没有涉及微任务，那我们改改原题目看看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p_2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p_2&quot;</span>);</span><br><span class="line">  <span class="comment">// 定时器1</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res(<span class="string">&quot;定时器1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// 定时器2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;定时器2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面新增的是在创建 Promise 对象时增加了一个定时器，以及增加了对 then 的回调。<br>依旧从整体程序开始，进入任务队列，当整体程序执行完时，这时的 RunTime 情况如下：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122252.png" alt="3"><br>此时输出为：</p>
<blockquote>
<p>p_2<br>end</p>
</blockquote>
<p>按照队列先进先出，定时器 1 先进入队列，所以其先于定时器 2 执行。此时定时器 1 的回调进入执行栈执行，执行 res(‘定时器 1’)改变 promise 的状态为 resolve,将 then 的回调加入微任务队列，此时 RunTime 的情况如下：<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122258.png" alt="4"></p>
<p>定时器 1 执行完毕弹出任务队列，一个任务执行完后，检索微任务队列，这时微任务队列存在一个 then 回调，所以将其加入执行栈。</p>
<p>现在的输出是：</p>
<blockquote>
<p>p_2<br>end<br>定时器 1</p>
</blockquote>
<p>最终，只剩下了任务队列的定时器 2 回调，重复时间循环，将定时器 2 的回调加入执行栈并执行。最终的输出结果为：</p>
<blockquote>
<p>p_2<br>end<br>定时器 1<br>定时器 2</p>
</blockquote>
<p>上面这题就说明了一个任务弹出任务队列后会执行微任务队列的任务，可是在上面的概念一章中还提到了一个任务出队列后是要执行所有的微任务，而上面的那一题只有一个微任务看不出什么蹊跷，那么我们再改一下吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p_2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p_2&quot;</span>);</span><br><span class="line">  <span class="comment">// 定时器1</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res(<span class="string">&quot;定时器1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;微任务开始&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">window</span>.queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 函数的内容</span></span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定时器2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;定时器2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这次我们更改了 then 的回调，使用了 window.queueMicrotask()来添加回调到微任务队列。这次是添加五个输出到微任务队列里面。顺着上一题的思路，我们只需将上一题的输出<strong>‘定时器 1’</strong>更改一下就行了。按照一次执行掉所有微任务的结论，我们可以作出如下更改。</p>
<blockquote>
<p>p_2<br>end<br>微任务开始<br>0<br>1<br>2<br>3<br>4<br>定时器 2</p>
</blockquote>
<p>在 chrome 里面试一下吧：）<br><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202201122327.png" alt="5"></p>
<p>可以看见，结论正确。</p>
<p><strong>参考：</strong><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>seajs源码阅读</title>
    <url>/2023/04/28/seajs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>介绍：js 模块加载器。这个开源项目应该是多年前的了，最新版本也是在 2014-03-06 的 2.2.0 版本了。所以，对于现在的浏览器，使用 script 标签的 type=”module” <a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">es6-in-depth-modules</a>,便可以使用模块化了。</p>
<blockquote>
<p>这篇起因是刷到了玉伯大佬离职的消息，了解到 seajs 这个模块加载器是他写的，所以就阅读了一手，如有冒犯，恳请原谅。</p>
</blockquote>
<p>依旧延续上次的方法，我们先从使用方式开始。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> Spinning = <span class="built_in">require</span>(<span class="string">&quot;./spinning&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exports</span>.moduleParam = <span class="string">&quot;param&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面就是 Sea.js 推荐的 CMD 模块书写格式。如果你有使用过 Node.js，一切都很自然。</p>
<h2 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h2><p>内部使用了封装的 seatools npm 包，使用的是 Grunt 打包，使用了其中的 contact file 功能。其会进行文件合并操作，所以会见到源码的 intro.js 与 outro.js 那种不完整的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">concat: &#123;</span><br><span class="line">      <span class="attr">dist</span>: &#123;</span><br><span class="line">        <span class="attr">src</span>: [</span><br><span class="line">          <span class="string">&#x27;src/intro.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/sea.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/util-lang.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/util-events.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/util-path.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/util-request.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/util-cs.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/util-deps.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/module.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/config.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;src/outro.js&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">dest</span>: <span class="string">&#x27;dist/sea-debug.js&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>seajs 使用了发布订阅模式，内置了如下事件：</p>
<ul>
<li>config</li>
<li>load</li>
<li>exec</li>
<li>fetch</li>
<li>request</li>
<li>resolve</li>
<li>define</li>
<li>save</li>
<li>error</li>
</ul>
<p>如需要处理这些事件，可以使用 <code>seajs.on</code> 添加对应事件回调。这些事件会在特定的时机触发，如 config，会在 seajs.config 函数里触发。<strong>这种非常适合插件系统</strong></p>
<h2 id="seajs-全局对象"><a href="#seajs-全局对象" class="headerlink" title="seajs 全局对象"></a>seajs 全局对象</h2><p><img src="https://cdn.jsdelivr.net/gh/PancakeDogLLL/imageBed/img/202305040833.png" alt="img"></p>
<h3 id="seajs-config"><a href="#seajs-config" class="headerlink" title="seajs.config"></a>seajs.config</h3><p>进行配置，配置的属性会保留在 seajs.data 上面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">  <span class="comment">// 设置路径，方便跨目录调用</span></span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="attr">arale</span>: <span class="string">&quot;https://a.alipayobjects.com/arale&quot;</span>,</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&quot;https://a.alipayobjects.com/jquery&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置别名，方便调用</span></span><br><span class="line">  <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&quot;arale/class/1.0.0/class&quot;</span>,</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&quot;jquery/jquery/1.10.1/jquery&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="seajs-request"><a href="#seajs-request" class="headerlink" title="seajs.request"></a>seajs.request</h3><p>分为 webWorker 与 非 webWorker 环境,通过<code>importScripts</code>判断是否是 webWorker 环境</p>
<ul>
<li>非 webWorker</li>
</ul>
<p>非 worker 环境使用 script 标签导入。 并使用 async 属性并行请求脚本。同时添加 onload 事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>;</span><br><span class="line"><span class="keyword">var</span> head =</span><br><span class="line">  doc.head || doc.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>] || doc.documentElement;</span><br><span class="line"><span class="keyword">var</span> baseElement = head.getElementsByTagName(<span class="string">&quot;base&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, callback, charset, crossorigin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = doc.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (charset) &#123;</span><br><span class="line">    node.charset = charset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isUndefined(crossorigin)) &#123;</span><br><span class="line">    node.setAttribute(<span class="string">&quot;crossorigin&quot;</span>, crossorigin);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addOnload(node, callback, url);</span><br><span class="line"></span><br><span class="line">  node.async = <span class="literal">true</span>;</span><br><span class="line">  node.src = url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For some cache cases in IE 6-8, the script executes IMMEDIATELY after</span></span><br><span class="line">  <span class="comment">// the end of the insert execution, so use `currentlyAddingScript` to</span></span><br><span class="line">  <span class="comment">// hold current node, for deriving url in `define` call</span></span><br><span class="line">  currentlyAddingScript = node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ref: #185 &amp; http://dev.jquery.com/ticket/2709</span></span><br><span class="line">  baseElement ? head.insertBefore(node, baseElement) : head.appendChild(node);</span><br><span class="line"></span><br><span class="line">  currentlyAddingScript = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOnload</span>(<span class="params">node, callback, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> supportOnload = <span class="string">&quot;onload&quot;</span> <span class="keyword">in</span> node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (supportOnload) &#123;</span><br><span class="line">    node.onload = onload;</span><br><span class="line">    node.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      emit(<span class="string">&quot;error&quot;</span>, &#123; <span class="attr">uri</span>: url, <span class="attr">node</span>: node &#125;);</span><br><span class="line">      onload(<span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/loaded|complete/</span>.test(node.readyState)) &#123;</span><br><span class="line">        onload();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onload</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Ensure only run once and handle memory leak in IE</span></span><br><span class="line">    node.onload = node.onerror = node.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the script to reduce memory leak</span></span><br><span class="line">    <span class="keyword">if</span> (!data.debug) &#123;</span><br><span class="line">      head.removeChild(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference the node</span></span><br><span class="line">    node = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    callback(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>webWorker</li>
</ul>
<p>webWorker 环境下，使用 importScripts 导入 js 脚本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestFromWebWorker</span>(<span class="params">url, callback, charset, crossorigin</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Load with importScripts</span></span><br><span class="line">  <span class="keyword">var</span> error;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    importScripts(url);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    error = e;</span><br><span class="line">  &#125;</span><br><span class="line">  callback(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="seajs-data"><a href="#seajs-data" class="headerlink" title="seajs.data"></a>seajs.data</h3><p>一个对象，存放一些路径、charset 等信息。</p>
<ul>
<li>base: root path for id2url</li>
<li>dir: loader’s full path</li>
<li>cwd: current working directory</li>
<li>charset: charset for requesting files</li>
<li>crossorigin: The CORS options, Don’t set CORS on default.</li>
<li>alias: An object containing shorthands of module id</li>
<li>paths: An object containing path shorthands in module id</li>
<li>vars: The {xxx} variables in module id</li>
<li>map: An array containing rules to map module uri</li>
<li>debug: Debug mode. The default value is false</li>
</ul>
<h3 id="seajs-resolve"><a href="#seajs-resolve" class="headerlink" title="seajs.resolve"></a>seajs.resolve</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id2Uri</span>(<span class="params">id, refUri</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!id) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  id = parseAlias(id); <span class="comment">// 如果有 Alias, 就使用 alias 中的路径</span></span><br><span class="line">  id = parsePaths(id); <span class="comment">// 如果 data.paths 中有，则使用 paths 中的路径</span></span><br><span class="line">  id = parseAlias(id);</span><br><span class="line">  id = parseVars(id);</span><br><span class="line">  id = parseAlias(id);</span><br><span class="line">  id = normalize(id);</span><br><span class="line">  id = parseAlias(id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> uri = addBase(id, refUri);</span><br><span class="line">  uri = parseAlias(uri);</span><br><span class="line">  uri = parseMap(uri);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><p>由开始的例子我们可以看到，全局定义了 define 方法，其作用是用来定义模块。那我们就从 define 开始。在谈 define 前，我们要先看看 Module 对象，因为 define 取的是 Module 的 define 方法 😂。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值到window</span></span><br><span class="line"><span class="built_in">global</span>.define = Module.define;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define 模块</span></span><br><span class="line">Module.define = <span class="function"><span class="keyword">function</span> (<span class="params">id, deps, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> argsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// define(factory)</span></span><br><span class="line">  <span class="keyword">if</span> (argsLen === <span class="number">1</span>) &#123;</span><br><span class="line">    factory = id;</span><br><span class="line">    id = <span class="literal">undefined</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argsLen === <span class="number">2</span>) &#123;</span><br><span class="line">    factory = deps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define(deps, factory)</span></span><br><span class="line">    <span class="keyword">if</span> (isArray(id)) &#123;</span><br><span class="line">      deps = id;</span><br><span class="line">      id = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// define(id, factory)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      deps = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse dependencies according to the module factory code</span></span><br><span class="line">  <span class="keyword">if</span> (!isArray(deps) &amp;&amp; isFunction(factory)) &#123;</span><br><span class="line">    deps =</span><br><span class="line">      <span class="keyword">typeof</span> parseDependencies === <span class="string">&quot;undefined&quot;</span></span><br><span class="line">        ? []</span><br><span class="line">        : parseDependencies(factory.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> meta = &#123;</span><br><span class="line">    <span class="attr">id</span>: id,</span><br><span class="line">    <span class="attr">uri</span>: Module.resolve(id),</span><br><span class="line">    <span class="attr">deps</span>: deps,</span><br><span class="line">    <span class="attr">factory</span>: factory,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to derive uri in IE6-9 for anonymous modules</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isWebWorker &amp;&amp;</span><br><span class="line">    !meta.uri &amp;&amp;</span><br><span class="line">    doc.attachEvent &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> getCurrentScript !== <span class="string">&quot;undefined&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> script = getCurrentScript();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (script) &#123;</span><br><span class="line">      meta.uri = script.src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> If the id-deriving methods above is failed, then falls back</span></span><br><span class="line">    <span class="comment">// to use onload event to get the uri</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit `define` event, used in nocache plugin, seajs node version etc</span></span><br><span class="line">  emit(<span class="string">&quot;define&quot;</span>, meta);</span><br><span class="line"></span><br><span class="line">  meta.uri</span><br><span class="line">    ? Module.save(meta.uri, meta)</span><br><span class="line">    : <span class="comment">// Save information for &quot;saving&quot; work in the script onload event</span></span><br><span class="line">      (anonymousMeta = meta);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>define 支持多种参数，其判断依据是根据参数长度</p>
<ul>
<li>define(factory)</li>
<li>define(deps, factory)</li>
<li>define(id, factory)</li>
</ul>
<p>在 deps 不为数组时，会使用 parseDependencies 方法将 factory 里的 require 依赖的提取出来。</p>
<p>在 Module.resolve 中，使用 <a href="#seajsresolve">seajs.resolve</a> 转换路径。同时创建 meta 对象，保存模块的 id, uri, deps, factory。然后执行 <a href="#modulesave">Module.save</a> 方法，将 mod 保存在 cachedMods 对象里边。 那 factory 会在什么时候执行呢，继续看。</p>
<blockquote>
<p>当我们定义好模块后，那接下来我们就应该去使用模块了。</p>
</blockquote>
<h2 id="seajs-use"><a href="#seajs-use" class="headerlink" title="seajs.use"></a>seajs.use</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">seajs.use = <span class="function"><span class="keyword">function</span> (<span class="params">ids, callback</span>) </span>&#123;</span><br><span class="line">  Module.use(ids, callback, data.cwd + <span class="string">&quot;_use_&quot;</span> + cid());</span><br><span class="line">  <span class="keyword">return</span> seajs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内部调用 <a href="#moduleuse">Module.use</a> 静态方法, 传入 ids, callback, uri。</p>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>一个模块对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">uri, deps</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.uri = uri;</span><br><span class="line">  <span class="built_in">this</span>.dependencies = deps || [];</span><br><span class="line">  <span class="built_in">this</span>.deps = &#123;&#125;; <span class="comment">// Ref the dependence modules</span></span><br><span class="line">  <span class="built_in">this</span>.status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._entry = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其提供了如下静态方法：</p>
<ul>
<li>resolve</li>
<li>define</li>
<li>save</li>
<li>get</li>
<li>use</li>
</ul>
<p>那什么时候去创建 Module 实例呢，是在 seajs.use 时。</p>
<h3 id="Module-use"><a href="#Module-use" class="headerlink" title="Module.use"></a>Module.use</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.use = <span class="function"><span class="keyword">function</span> (<span class="params">ids, callback, uri</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = Module.get(uri, isArray(ids) ? ids : [ids]);</span><br><span class="line"></span><br><span class="line">  mod._entry.push(mod);</span><br><span class="line">  mod.history = &#123;&#125;;</span><br><span class="line">  mod.remain = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  mod.callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = [];</span><br><span class="line">    <span class="keyword">var</span> uris = mod.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uris.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">exports</span>[i] = cachedMods[uris[i]].exec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      callback.apply(<span class="built_in">global</span>, <span class="built_in">exports</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> mod.callback;</span><br><span class="line">    <span class="keyword">delete</span> mod.history;</span><br><span class="line">    <span class="keyword">delete</span> mod.remain;</span><br><span class="line">    <span class="keyword">delete</span> mod._entry;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mod.load();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <a href="#moduleget">Module.get</a> 从 cachedMods 获取 module。将自身添加到 _entry 里，最后执行 mod 的 load 方法， 也就是 <a href="#moduleprototypeload">Module.prototype.load</a></p>
<h3 id="Module-save"><a href="#Module-save" class="headerlink" title="Module.save"></a>Module.save</h3><p>将 meta 对象数据保存在 cachedMods 里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.save = <span class="function"><span class="keyword">function</span> (<span class="params">uri, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = Module.get(uri);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do NOT override already saved modules</span></span><br><span class="line">  <span class="keyword">if</span> (mod.status &lt; STATUS.SAVED) &#123;</span><br><span class="line">    mod.id = meta.id || uri;</span><br><span class="line">    mod.dependencies = meta.deps || [];</span><br><span class="line">    mod.factory = meta.factory;</span><br><span class="line">    mod.status = STATUS.SAVED;</span><br><span class="line"></span><br><span class="line">    emit(<span class="string">&quot;save&quot;</span>, mod);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Module-get"><a href="#Module-get" class="headerlink" title="Module.get"></a>Module.get</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.get = <span class="function"><span class="keyword">function</span> (<span class="params">uri, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cachedMods[uri] || (cachedMods[uri] = <span class="keyword">new</span> Module(uri, deps));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Module-resolve"><a href="#Module-resolve" class="headerlink" title="Module.resolve"></a>Module.resolve</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resolve id to uri</span></span><br><span class="line">Module.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">id, refUri</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Emit `resolve` event for plugins such as text plugin</span></span><br><span class="line">  <span class="keyword">var</span> emitData = &#123; <span class="attr">id</span>: id, <span class="attr">refUri</span>: refUri &#125;;</span><br><span class="line">  emit(<span class="string">&quot;resolve&quot;</span>, emitData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> emitData.uri || seajs.resolve(emitData.id, refUri);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Module-prototype-load"><a href="#Module-prototype-load" class="headerlink" title="Module.prototype.load"></a>Module.prototype.load</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load module.dependencies and fire onload when all done</span></span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the module is being loaded, just wait it onload call</span></span><br><span class="line">  <span class="keyword">if</span> (mod.status &gt;= STATUS.LOADING) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mod.status = STATUS.LOADING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit `load` event for plugins such as combo plugin</span></span><br><span class="line">  <span class="keyword">var</span> uris = mod.resolve();</span><br><span class="line">  emit(<span class="string">&quot;load&quot;</span>, uris);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uris.length; i &lt; len; i++) &#123;</span><br><span class="line">    mod.deps[mod.dependencies[i]] = Module.get(uris[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass entry to it&#x27;s dependencies</span></span><br><span class="line">  mod.pass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If module has entries not be passed, call onload</span></span><br><span class="line">  <span class="keyword">if</span> (mod._entry.length) &#123;</span><br><span class="line">    mod.onload();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Begin parallel loading</span></span><br><span class="line">  <span class="keyword">var</span> requestCache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    m = cachedMods[uris[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m.status &lt; STATUS.FETCHING) &#123;</span><br><span class="line">      m.fetch(requestCache);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.status === STATUS.SAVED) &#123;</span><br><span class="line">      m.load();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send all requests at last to avoid cache bug in IE6-9. Issues#808</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> requestUri <span class="keyword">in</span> requestCache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCache.hasOwnProperty(requestUri)) &#123;</span><br><span class="line">      requestCache[requestUri]();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先判断 mod 的 status 是否是加载中，如果是，就由 emit 事件处理。然后通过 <a href="#moduleprototyperesolve">Module.prototype.resolve</a> 获取依赖模块的 uri 列表。赋值给 mod.deps。mod.dependencies 在 factory 函数就会通过正则获取依赖。mod.deps 就形如 <code>&#123;&quot;jquery&quot;: Module &#125;</code>。接下来就调用 <a href="#moduleprototypepass">Module.prototype.pass</a> 进行 entry 到 dependence 的转换。如果 dependence 里面都 loaded 了，就触发 <a href="Module.prototype.onload">Module.prototype.onload</a>。最后判断 cachedMods 的状态，如果 小于 FETCHING 就开始并行加载，调用 <a href="#moduleprototypefetch">Module.prototype.fetch</a>,如果状态等于 SAVED 就调用 <a href="#moduleprototypeload">Module.prototype.load</a></p>
<h3 id="Module-prototype-resolve"><a href="#Module-prototype-resolve" class="headerlink" title="Module.prototype.resolve"></a>Module.prototype.resolve</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resolve module.dependencies</span></span><br><span class="line">Module.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> ids = mod.dependencies;</span><br><span class="line">  <span class="keyword">var</span> uris = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = ids.length; i &lt; len; i++) &#123;</span><br><span class="line">    uris[i] = Module.resolve(ids[i], mod.uri);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uris;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>获取 dependencies 的 uri</p>
<h3 id="Module-prototype-pass"><a href="#Module-prototype-pass" class="headerlink" title="Module.prototype.pass"></a>Module.prototype.pass</h3><p>将当前 mod 的 _entry 添加到 dependcies 的_entry 里边。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype.pass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = mod.dependencies.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mod._entry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> entry = mod._entry[i];</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> m = mod.deps[mod.dependencies[j]];</span><br><span class="line">      <span class="comment">// If the module is unload and unused in the entry, pass entry to it</span></span><br><span class="line">      <span class="keyword">if</span> (m.status &lt; STATUS.LOADED &amp;&amp; !entry.history.hasOwnProperty(m.uri)) &#123;</span><br><span class="line">        entry.history[m.uri] = <span class="literal">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        m._entry.push(entry);</span><br><span class="line">        <span class="keyword">if</span> (m.status === STATUS.LOADING) &#123;</span><br><span class="line">          m.pass();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If has passed the entry to it&#x27;s dependencies, modify the entry&#x27;s count and del it in the module</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      entry.remain += count - <span class="number">1</span>;</span><br><span class="line">      mod._entry.shift();</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码先获取<code>mod.dependencies.length</code>。然后遍历 <code>mod._entry</code>, 二层循环遍历 <code>mod.dependencies</code>，如果 dependencies 里有未加载的且 entry.history 没有保留，那么就将 entry push 到当前 dependence 的 _entry 里，如果当前 dependence 的状态是 loading, 就 递归 pass。</p>
<h3 id="Module-prototype-onload"><a href="#Module-prototype-onload" class="headerlink" title="Module.prototype.onload"></a>Module.prototype.onload</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Call this method when module is loaded</span></span><br><span class="line">Module.prototype.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="built_in">this</span>;</span><br><span class="line">  mod.status = STATUS.LOADED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When sometimes cached in IE, exec will occur before onload, make sure len is an number</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = (mod._entry || []).length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> entry = mod._entry[i];</span><br><span class="line">    <span class="keyword">if</span> (--entry.remain === <span class="number">0</span>) &#123;</span><br><span class="line">      entry.callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> mod._entry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将 mod 的 status 变成 STATUS.LOADED。在 mod.remain 为 1 时，也就是只有 mod 自己时，执行 mod.callback</p>
<h3 id="Module-prototype-exec"><a href="#Module-prototype-exec" class="headerlink" title="Module.prototype.exec"></a>Module.prototype.exec</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype.exec = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When module is executed, DO NOT execute it again. When module</span></span><br><span class="line">  <span class="comment">// is being executed, just return `module.exports` too, for avoiding</span></span><br><span class="line">  <span class="comment">// circularly calling</span></span><br><span class="line">  <span class="keyword">if</span> (mod.status &gt;= STATUS.EXECUTING) &#123;</span><br><span class="line">    <span class="keyword">return</span> mod.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mod.status = STATUS.EXECUTING;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mod._entry &amp;&amp; !mod._entry.length) &#123;</span><br><span class="line">    <span class="keyword">delete</span> mod._entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//non-cmd module has no property factory and exports</span></span><br><span class="line">  <span class="keyword">if</span> (!mod.hasOwnProperty(<span class="string">&quot;factory&quot;</span>)) &#123;</span><br><span class="line">    mod.non = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create require</span></span><br><span class="line">  <span class="keyword">var</span> uri = mod.uri;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = mod.deps[id] || Module.get(<span class="built_in">require</span>.resolve(id));</span><br><span class="line">    <span class="keyword">if</span> (m.status == STATUS.ERROR) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;module was broken: &quot;</span> + m.uri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m.exec();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">require</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Module.resolve(id, uri);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">require</span>.async = <span class="function"><span class="keyword">function</span> (<span class="params">ids, callback</span>) </span>&#123;</span><br><span class="line">    Module.use(ids, callback, uri + <span class="string">&quot;_async_&quot;</span> + cid());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exec factory</span></span><br><span class="line">  <span class="keyword">var</span> factory = mod.factory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">exports</span> = isFunction(factory)</span><br><span class="line">    ? factory.call((mod.exports = &#123;&#125;), <span class="built_in">require</span>, mod.exports, mod)</span><br><span class="line">    : factory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exports</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">exports</span> = mod.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reduce memory leak</span></span><br><span class="line">  <span class="keyword">delete</span> mod.factory;</span><br><span class="line"></span><br><span class="line">  mod.exports = <span class="built_in">exports</span>;</span><br><span class="line">  mod.status = STATUS.EXECUTED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit `exec` event</span></span><br><span class="line">  emit(<span class="string">&quot;exec&quot;</span>, mod);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mod.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行 factory 函数，返回一个对象，包含 factory 中 exports 的变量。<br>在 exec 中，会判断 mod 的状态如果是 EXECUTING 或者 EXECUTED，就直接返回 mod.exports， 避免了重复执行。再次判断 mod._entry, 如果为空就 delete 掉。这里会将 mod.exports 与 factory 中改变的 exports 进行一个同步。</p>
<h3 id="Module-prototype-fetch"><a href="#Module-prototype-fetch" class="headerlink" title="Module.prototype.fetch"></a>Module.prototype.fetch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch a module</span></span><br><span class="line">Module.prototype.fetch = <span class="function"><span class="keyword">function</span> (<span class="params">requestCache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> uri = mod.uri;</span><br><span class="line"></span><br><span class="line">  mod.status = STATUS.FETCHING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit `fetch` event for plugins such as combo plugin</span></span><br><span class="line">  <span class="keyword">var</span> emitData = &#123; <span class="attr">uri</span>: uri &#125;;</span><br><span class="line">  emit(<span class="string">&quot;fetch&quot;</span>, emitData);</span><br><span class="line">  <span class="keyword">var</span> requestUri = emitData.requestUri || uri;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty uri or a non-CMD module</span></span><br><span class="line">  <span class="keyword">if</span> (!requestUri || fetchedList.hasOwnProperty(requestUri)) &#123;</span><br><span class="line">    mod.load();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fetchingList.hasOwnProperty(requestUri)) &#123;</span><br><span class="line">    callbackList[requestUri].push(mod);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchingList[requestUri] = <span class="literal">true</span>;</span><br><span class="line">  callbackList[requestUri] = [mod];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit `request` event for plugins such as text plugin</span></span><br><span class="line">  emit(</span><br><span class="line">    <span class="string">&quot;request&quot;</span>,</span><br><span class="line">    (emitData = &#123;</span><br><span class="line">      <span class="attr">uri</span>: uri,</span><br><span class="line">      <span class="attr">requestUri</span>: requestUri,</span><br><span class="line">      <span class="attr">onRequest</span>: onRequest,</span><br><span class="line">      <span class="attr">charset</span>: isFunction(data.charset)</span><br><span class="line">        ? data.charset(requestUri)</span><br><span class="line">        : data.charset,</span><br><span class="line">      <span class="attr">crossorigin</span>: isFunction(data.crossorigin)</span><br><span class="line">        ? data.crossorigin(requestUri)</span><br><span class="line">        : data.crossorigin,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!emitData.requested) &#123;</span><br><span class="line">    requestCache</span><br><span class="line">      ? (requestCache[emitData.requestUri] = sendRequest)</span><br><span class="line">      : sendRequest();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sendRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    seajs.request(</span><br><span class="line">      emitData.requestUri,</span><br><span class="line">      emitData.onRequest,</span><br><span class="line">      emitData.charset,</span><br><span class="line">      emitData.crossorigin</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> fetchingList[requestUri];</span><br><span class="line">    fetchedList[requestUri] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save meta data of anonymous module</span></span><br><span class="line">    <span class="keyword">if</span> (anonymousMeta) &#123;</span><br><span class="line">      Module.save(uri, anonymousMeta);</span><br><span class="line">      anonymousMeta = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call callbacks</span></span><br><span class="line">    <span class="keyword">var</span> m,</span><br><span class="line">      mods = callbackList[requestUri];</span><br><span class="line">    <span class="keyword">delete</span> callbackList[requestUri];</span><br><span class="line">    <span class="keyword">while</span> ((m = mods.shift())) &#123;</span><br><span class="line">      <span class="comment">// When 404 occurs, the params error will be true</span></span><br><span class="line">      <span class="keyword">if</span> (error === <span class="literal">true</span>) &#123;</span><br><span class="line">        m.error();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m.load();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据 mod.uri 进行 fetch 操作，如果 uri 为空或者， fetchedList 已经 fetch 了，就执行 mod.load。这里的 request 就直接执行 <a href="#seajsrequest">seajs.request</a>。进行脚本请求。最后执行 <a href="#moduleprototypeload">Module.prototype.load</a></p>
<h2 id="mod-callback"><a href="#mod-callback" class="headerlink" title="mod.callback"></a>mod.callback</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mod.callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">exports</span> = [];</span><br><span class="line">  <span class="keyword">var</span> uris = mod.resolve();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uris.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">exports</span>[i] = cachedMods[uris[i]].exec();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    callback.apply(<span class="built_in">global</span>, <span class="built_in">exports</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> mod.callback;</span><br><span class="line">  <span class="keyword">delete</span> mod.history;</span><br><span class="line">  <span class="keyword">delete</span> mod.remain;</span><br><span class="line">  <span class="keyword">delete</span> mod._entry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用每个依赖模块的 <a href="#moduleprototypeexec">exec</a> 方法。如果 seajs.use 传入了 callback, 那么会传入 exports 的对象为 callback 的参数。删除 callback, history, remain, _entry 属性，减少内存。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
